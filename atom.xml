<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cishoon&#39;s Blog</title>
  
  
  <link href="http://cishoon.top/atom.xml" rel="self"/>
  
  <link href="http://cishoon.top/"/>
  <updated>2024-11-17T05:56:10.344Z</updated>
  <id>http://cishoon.top/</id>
  
  <author>
    <name>Cishoon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python torch cuda</title>
    <link href="http://cishoon.top/python-torch-cuda/"/>
    <id>http://cishoon.top/python-torch-cuda/</id>
    <published>2024-11-16T16:00:00.000Z</published>
    <updated>2024-11-17T05:56:10.344Z</updated>
    
    <content type="html"><![CDATA[<p>https://download.pytorch.org/whl/cu124/torch/https://download.pytorch.org/whl/cu124/torchvision/</p><p>https://mirror.sjtu.edu.cn/pytorch-wheels/cu124/?mirror_intel_list</p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;https://download.pytorch.org/whl/cu124/torch/
https://download.pytorch.org/whl/cu124/torchvision/&lt;/p&gt;
&lt;p&gt;https://mirror.sjtu.edu.cn/pytorch-wheels/cu124/?mirror_intel_list&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://cishoon.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="python" scheme="http://cishoon.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>毕设10 - Juno(wasmd) 初见，节点部署和简单功能实践</title>
    <link href="http://cishoon.top/graduation-project/10/"/>
    <id>http://cishoon.top/graduation-project/10/</id>
    <published>2024-11-14T16:00:00.000Z</published>
    <updated>2024-11-17T13:47:51.718Z</updated>
    
    <content type="html"><![CDATA[<p>本文写作时 Juno 版本：v25.0.0-2-gd47e0713</p><p>还有官方 GPTs：Juno Simpler，数据库大概是 v12左右的，但是还不错基本问题都能解决。</p><p>Juno 是在 wasmd 的基础上开发的，我误打误撞从 Juno 开始学习了。本文的内容几乎可以直接迁移到 wasmd使用和学习中，部分区别我在章节末作出了补充。 <del>（只要全文替换 juno 为wasm ，修改仓库和docker地址，就是 wasmd 的初见教程了）</del></p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Nvc21vc0NvbnRyYWN0cy9KdW5v">Juno 仓库<i class="fa fa-external-link-alt"></i></span> <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Nvc21XYXNtL3dhc21kL3RyZWUvbWFpbg==">wasmd仓库<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h1 id="运行-juno-本地节点">1 运行 Juno 本地节点</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/CosmosContracts/juno.git</span><br><span class="line"><span class="built_in">cd</span> juno</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="docker">1.1 Docker</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it --<span class="built_in">rm</span> -p 26657:26657 -p 26656:26656 -p 1317:1317 -p 9090:9090 \</span><br><span class="line">  ghcr.io/cosmoscontracts/juno:latest ./setup_and_run.sh</span><br></pre></td></tr></table></figure><p>当 Docker 容器启动后，你可以通过以下命令确认节点是否运行正常：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl http://localhost:26657/status</span><br></pre></td></tr></table></figure><p>如果节点运行正常，会收到 JSON 格式的状态信息。</p><p>但是发现这个 latest 版本才到 v12。手动换到最新的 v25。</p><blockquote><p>查看版本：https://github.com/CosmosContracts/juno/pkgs/container/juno/versions?filters%5Bversion_type%5D=tagged</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull ghcr.io/cosmoscontracts/juno:25 </span><br></pre></td></tr></table></figure><p>该版本docker镜像仍存在问题，<code>/opt/run_junod.sh</code> 中设置<code>--minimum-gas-prices 0.0001ujunox</code> 代币类型是<code>ujunox</code> ，而 <code>setup_junod.sh</code> 中设置的代币类型是<code>ustake</code> 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /opt/run_junod.sh</span><br></pre></td></tr></table></figure><p>修改代币类型为 <code>ustake</code>后，退出容器，将其保存为新的镜像：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(in docker) # exit</span><br><span class="line">docker commit &lt;my_container_name&gt; &lt;new_image_name&gt;</span><br></pre></td></tr></table></figure><p>然后启动新的镜像：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --rm -it -p 26657:26657 --name my-juno-local &lt;new_image_name&gt; ./setup_and_run.sh</span><br><span class="line">docker run --rm -it -p 26657:26657 --name my-juno-local my_juno25 ./setup_and_run.sh</span><br></pre></td></tr></table></figure><h3 id="补充">补充</h3><p>wasmd 的 docker 为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cosmwasm/wasmd:latest</span><br></pre></td></tr></table></figure><p>直接使用 wasmd 的镜像不需要以上复杂的修改。</p><h2 id="本地脚本运行">1.2 本地脚本运行</h2><p><code>./setup_junod.sh [其他账户]</code></p><p>可以直接创建其他账户，但是必须提前使用<code>junod keys add &lt;账户名称&gt; $KEYRING</code> 创建好。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#set -o errexit -o nounset -o pipefail</span></span><br><span class="line"></span><br><span class="line">PASSWORD=<span class="variable">${PASSWORD:-1234567890}</span></span><br><span class="line">STAKE=<span class="variable">${STAKE_TOKEN:-ustake}</span></span><br><span class="line">FEE=<span class="variable">${FEE_TOKEN:-ucosm}</span></span><br><span class="line">CHAIN_ID=<span class="variable">${CHAIN_ID:-testing}</span></span><br><span class="line">MONIKER=<span class="variable">${MONIKER:-node001}</span></span><br><span class="line">KEYRING=<span class="string">"--keyring-backend test"</span></span><br><span class="line">TIMEOUT_COMMIT=<span class="variable">${TIMEOUT_COMMIT:-5s}</span></span><br><span class="line">BLOCK_GAS_LIMIT=<span class="variable">${GAS_LIMIT:-10000000}</span> <span class="comment"># should mirror mainnet</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Configured Block Gas Limit: <span class="variable">$BLOCK_GAS_LIMIT</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># check the genesis file</span></span><br><span class="line">GENESIS_FILE=<span class="string">"<span class="variable">$HOME</span>"</span>/.juno/config/genesis.json</span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">"<span class="variable">$GENESIS_FILE</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$GENESIS_FILE</span> exists..."</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$GENESIS_FILE</span> does not exist. Generating..."</span></span><br><span class="line"></span><br><span class="line">  junod init --chain-id <span class="string">"<span class="variable">$CHAIN_ID</span>"</span> <span class="string">"<span class="variable">$MONIKER</span>"</span></span><br><span class="line">  junod add-ica-config</span><br><span class="line">  <span class="comment"># staking/governance token is hardcoded in config, change this</span></span><br><span class="line">  sed -i <span class="string">"s/\"stake\"/\"<span class="variable">$STAKE</span>\"/"</span> <span class="string">"<span class="variable">$GENESIS_FILE</span>"</span></span><br><span class="line">  <span class="comment"># this is essential for sub-1s block times (or header times go crazy)</span></span><br><span class="line">  sed -i <span class="string">'s/"time_iota_ms": "1000"/"time_iota_ms": "10"/'</span> <span class="string">"<span class="variable">$GENESIS_FILE</span>"</span></span><br><span class="line">  <span class="comment"># change gas limit to mainnet value</span></span><br><span class="line">  sed -i <span class="string">'s/"max_gas": "-1"/"max_gas": "'</span><span class="string">"<span class="variable">$BLOCK_GAS_LIMIT</span>"</span><span class="string">'"/'</span> <span class="string">"<span class="variable">$GENESIS_FILE</span>"</span></span><br><span class="line">  <span class="comment"># change default keyring-backend to test</span></span><br><span class="line">  sed -i <span class="string">'s/keyring-backend = "os"/keyring-backend = "test"/'</span> <span class="string">"<span class="variable">$HOME</span>"</span>/.juno/config/client.toml</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">APP_TOML_CONFIG=<span class="string">"<span class="variable">$HOME</span>"</span>/.juno/config/app.toml</span><br><span class="line">APP_TOML_CONFIG_NEW=<span class="string">"<span class="variable">$HOME</span>"</span>/.juno/config/app_new.toml</span><br><span class="line">CONFIG_TOML_CONFIG=<span class="string">"<span class="variable">$HOME</span>"</span>/.juno/config/config.toml</span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$UNSAFE_CORS</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Unsafe CORS set... updating app.toml and config.toml"</span></span><br><span class="line">  <span class="comment"># sorry about this bit, but toml is rubbish for structural editing</span></span><br><span class="line">  sed -n <span class="string">'1h;1!H;${g;s/# Enable defines if the API server should be enabled.\nenable = false/enable = true/;p;}'</span> <span class="string">"<span class="variable">$APP_TOML_CONFIG</span>"</span> &gt; <span class="string">"<span class="variable">$APP_TOML_CONFIG_NEW</span>"</span></span><br><span class="line">  <span class="built_in">mv</span> <span class="string">"<span class="variable">$APP_TOML_CONFIG_NEW</span>"</span> <span class="string">"<span class="variable">$APP_TOML_CONFIG</span>"</span></span><br><span class="line">  <span class="comment"># ...and breathe</span></span><br><span class="line">  sed -i <span class="string">"s/enabled-unsafe-cors = false/enabled-unsafe-cors = true/"</span> <span class="string">"<span class="variable">$APP_TOML_CONFIG</span>"</span></span><br><span class="line">  sed -i <span class="string">"s/cors_allowed_origins = \[\]/cors_allowed_origins = \[\"\*\"\]/"</span> <span class="string">"<span class="variable">$CONFIG_TOML_CONFIG</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># speed up block times for testing environments</span></span><br><span class="line">sed -i <span class="string">"s/timeout_commit = \"5s\"/timeout_commit = \"<span class="variable">$TIMEOUT_COMMIT</span>\"/"</span> <span class="string">"<span class="variable">$CONFIG_TOML_CONFIG</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># are we running for the first time?</span></span><br><span class="line"><span class="keyword">if</span> ! junod keys show validator <span class="variable">$KEYRING</span>; <span class="keyword">then</span></span><br><span class="line">  (<span class="built_in">echo</span> <span class="string">"<span class="variable">$PASSWORD</span>"</span>; <span class="built_in">echo</span> <span class="string">"<span class="variable">$PASSWORD</span>"</span>) | junod keys add validator <span class="variable">$KEYRING</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># hardcode the validator account for this instance</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$PASSWORD</span>"</span> | junod genesis add-genesis-account validator <span class="string">"1000000000<span class="variable">$STAKE</span>,1000000000<span class="variable">$FEE</span>"</span> <span class="variable">$KEYRING</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># (optionally) add a few more genesis accounts</span></span><br><span class="line">  <span class="keyword">for</span> addr <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$addr</span></span><br><span class="line">    junod genesis add-genesis-account <span class="string">"<span class="variable">$addr</span>"</span> <span class="string">"1000000000<span class="variable">$STAKE</span>,1000000000<span class="variable">$FEE</span>,5000000000uusd"</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># submit a genesis validator tx</span></span><br><span class="line">  <span class="comment">## Workraround for https://github.com/cosmos/cosmos-sdk/issues/8251</span></span><br><span class="line">  (<span class="built_in">echo</span> <span class="string">"<span class="variable">$PASSWORD</span>"</span>; <span class="built_in">echo</span> <span class="string">"<span class="variable">$PASSWORD</span>"</span>; <span class="built_in">echo</span> <span class="string">"<span class="variable">$PASSWORD</span>"</span>) | junod genesis gentx validator <span class="string">"250000000<span class="variable">$STAKE</span>"</span> --chain-id=<span class="string">"<span class="variable">$CHAIN_ID</span>"</span> --amount=<span class="string">"250000000<span class="variable">$STAKE</span>"</span> <span class="variable">$KEYRING</span></span><br><span class="line">  <span class="comment">## should be:</span></span><br><span class="line">  <span class="comment"># (echo "$PASSWORD"; echo "$PASSWORD"; echo "$PASSWORD") | junod genesis gentx validator "250000000$STAKE" --chain-id="$CHAIN_ID"</span></span><br><span class="line">  junod genesis collect-gentxs</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><code>run_junod.sh</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -n <span class="string">"<span class="variable">$1</span>"</span>; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># need -R not -r to copy hidden files</span></span><br><span class="line">    <span class="built_in">cp</span> -R <span class="string">"<span class="variable">$1</span>/.juno"</span> /root</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p /root/log</span><br><span class="line">junod start --rpc.laddr tcp://0.0.0.0:26657 --minimum-gas-prices 0.0001ustake --trace</span><br></pre></td></tr></table></figure><p><code>setup_and_run.sh</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">./setup_junod.sh <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line">./run_junod.sh</span><br></pre></td></tr></table></figure><h3 id="补充-1">补充</h3><p>Juno 脚本在 wasmd 上进行了一些参数调整，wasmd的更简洁，适合学习：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#set -o errexit -o nounset -o pipefail</span></span><br><span class="line"></span><br><span class="line">PASSWORD=<span class="variable">${PASSWORD:-1234567890}</span></span><br><span class="line">STAKE=<span class="variable">${STAKE_TOKEN:-ustake}</span></span><br><span class="line">FEE=<span class="variable">${FEE_TOKEN:-ucosm}</span></span><br><span class="line">CHAIN_ID=<span class="variable">${CHAIN_ID:-testing}</span></span><br><span class="line">MONIKER=<span class="variable">${MONIKER:-node001}</span></span><br><span class="line"></span><br><span class="line">wasmd init --chain-id <span class="string">"<span class="variable">$CHAIN_ID</span>"</span> <span class="string">"<span class="variable">$MONIKER</span>"</span></span><br><span class="line"><span class="comment"># staking/governance token is hardcoded in config, change this</span></span><br><span class="line">sed -i <span class="string">"s/\"stake\"/\"<span class="variable">$STAKE</span>\"/"</span> <span class="string">"<span class="variable">$HOME</span>"</span>/.wasmd/config/genesis.json</span><br><span class="line"><span class="comment"># this is essential for sub-1s block times (or header times go crazy)</span></span><br><span class="line">sed -i <span class="string">'s/"time_iota_ms": "1000"/"time_iota_ms": "10"/'</span> <span class="string">"<span class="variable">$HOME</span>"</span>/.wasmd/config/genesis.json</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ! wasmd keys show validator; <span class="keyword">then</span></span><br><span class="line">  (<span class="built_in">echo</span> <span class="string">"<span class="variable">$PASSWORD</span>"</span>; <span class="built_in">echo</span> <span class="string">"<span class="variable">$PASSWORD</span>"</span>) | wasmd keys add validator</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># hardcode the validator account for this instance</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$PASSWORD</span>"</span> | wasmd genesis add-genesis-account validator <span class="string">"1000000000<span class="variable">$STAKE</span>,1000000000<span class="variable">$FEE</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># (optionally) add a few more genesis accounts</span></span><br><span class="line"><span class="keyword">for</span> addr <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span>; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$addr</span></span><br><span class="line">  wasmd genesis add-genesis-account <span class="string">"<span class="variable">$addr</span>"</span> <span class="string">"1000000000<span class="variable">$STAKE</span>,1000000000<span class="variable">$FEE</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># submit a genesis validator tx</span></span><br><span class="line"><span class="comment">## Workraround for https://github.com/cosmos/cosmos-sdk/issues/8251</span></span><br><span class="line">(<span class="built_in">echo</span> <span class="string">"<span class="variable">$PASSWORD</span>"</span>; <span class="built_in">echo</span> <span class="string">"<span class="variable">$PASSWORD</span>"</span>; <span class="built_in">echo</span> <span class="string">"<span class="variable">$PASSWORD</span>"</span>) | wasmd genesis gentx validator <span class="string">"250000000<span class="variable">$STAKE</span>"</span> --chain-id=<span class="string">"<span class="variable">$CHAIN_ID</span>"</span> --amount=<span class="string">"250000000<span class="variable">$STAKE</span>"</span></span><br><span class="line"><span class="comment">## should be:</span></span><br><span class="line"><span class="comment"># (echo "$PASSWORD"; echo "$PASSWORD"; echo "$PASSWORD") | wasmd gentx validator "250000000$STAKE" --chain-id="$CHAIN_ID"</span></span><br><span class="line">wasmd genesis collect-gentxs</span><br></pre></td></tr></table></figure><h2 id="分析输出信息">1.3 分析输出信息</h2><p>从你提供的节点输出日志来看，运行的节点正在正常参与区块链网络的共识和状态更新流程。以下是日志中各部分的解析：</p><h3 id="关键信息解析">1.3.1 关键信息解析</h3><ol type="1"><li><p><strong>区块执行和状态提交</strong></p><p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INF executed block height=171 module=state num_invalid_txs=0 num_valid_txs=0</span><br></pre></td></tr></table></figure></p><ul><li><strong>含义</strong>：第 171个区块已经被成功执行。没有无效交易（<code>num_invalid_txs=0</code>），也没有有效交易（<code>num_valid_txs=0</code>）。</li><li><strong>模块</strong>：<code>state</code>模块负责应用区块内容并更新状态。</li></ul><p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INF committed state app_hash=30D13E32FA9357F0C27B6A5DC48E65E99EA2C302B3CEEED4F44A673BA1D85AEC height=171 module=state num_txs=0</span><br></pre></td></tr></table></figure></p><ul><li><strong>含义</strong>：第 171个区块的状态变更已被提交，<code>app_hash</code>是状态哈希，用于验证状态一致性。</li><li><strong>模块</strong>：<code>state</code> 模块。</li></ul><p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INF indexed block events height=171 module=txindex</span><br></pre></td></tr></table></figure></p><ul><li><strong>含义</strong>：与第 171个区块相关的事件（如交易）已被索引，便于后续查询。</li><li><strong>模块</strong>：<code>txindex</code> 模块（交易索引）。</li></ul></li><li><p><strong>新高度的启动</strong></p><p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INF Timed out dur=1994.796713 height=172 module=consensus round=0 step=RoundStepNewHeight</span><br></pre></td></tr></table></figure></p><ul><li><strong>含义</strong>：网络进入了新的区块高度（172）的第 0轮共识阶段。这表明之前的区块已完成处理，节点正在准备生成新的区块。</li></ul></li><li><p><strong>提案接收与共识</strong></p><p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INF received proposal module=consensus proposal="Proposal{172/0 (...)}"</span><br></pre></td></tr></table></figure></p><ul><li><strong>含义</strong>：节点收到了高度为 172的区块提案（<code>proposal</code>），提议者是<code>3DAD15B485682FBD43119CDDE685C5142B9B0915</code>。</li><li><strong>模块</strong>：<code>consensus</code> 模块。</li></ul><p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INF received complete proposal block hash=01B19714D56F0DB95008F250E626B8E3531AE5A74AA3FBB22768991CD3450D4B height=172 module=consensus</span><br></pre></td></tr></table></figure></p><ul><li><strong>含义</strong>：节点接收到了完整的提案，包含区块的哈希（<code>block hash</code>）。</li><li><strong>模块</strong>：<code>consensus</code> 模块。</li></ul><p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INF finalizing commit of block hash=01B19714D56F0DB95008F250E626B8E3531AE5A74AA3FBB22768991CD3450D4B height=172 module=consensus num_txs=0</span><br></pre></td></tr></table></figure></p><ul><li><strong>含义</strong>：节点达成共识并提交高度为 172的区块，区块内没有交易。</li></ul></li><li><p><strong>铸造代币</strong></p><p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INF minted coins from module account amount=63ustake from=mint module=x/bank</span><br></pre></td></tr></table></figure></p><ul><li><strong>含义</strong>：区块链网络铸造了 63 个单位的<code>ustake</code> 代币（可能是通胀奖励或区块奖励）。</li></ul></li><li><p><strong>确保网络连接</strong></p><p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INF Ensure peers module=pex numDialing=0 numInPeers=0 numOutPeers=0 numToDial=10</span><br></pre></td></tr></table></figure></p><ul><li><strong>含义</strong>：节点当前没有入站或出站的网络连接，但它尝试拨号以连接到其他节点（最大10 个节点）。</li><li><strong>模块</strong>：<code>pex</code>模块（负责点对点连接管理）。</li></ul><p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INF No addresses to dial. Falling back to seeds module=pex</span><br></pre></td></tr></table></figure></p><ul><li><strong>含义</strong>：没有可用的节点地址用于连接，节点将回退到预设的种子节点。</li></ul></li></ol><h3 id="总结">1.3.2 总结</h3><ul><li>节点正在正常运行，且成功参与了网络共识流程。</li><li>当前的区块中没有有效交易（所有<code>num_valid_txs=0</code>），可能是因为没有用户向链发送交易。</li><li>状态哈希（<code>app_hash</code>）验证了区块链状态的一致性。</li><li>节点正在尝试建立与其他节点的连接，但暂时没有连接上，可能需要检查网络配置或种子节点的可用性。</li></ul><h1 id="简单测试">2 简单测试</h1><p>为了模拟远程网络环境（即本地通过 rpc/http 请求访问区块链），按照 1.1节的方式，使用修改后的docker镜像启动节点：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it -p 26657:26657 --name my-juno-local my_juno25 ./setup_and_run.sh</span><br></pre></td></tr></table></figure><p>为了方便关机后恢复区块链的状态，不添加 <code>--rm</code> 选项。通过log 实时获取区块链的输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker log -f my-juno-local</span><br></pre></td></tr></table></figure><p>以下提到的 <strong>本地</strong> 即宿主机，模拟普通用户通过 junod来访问区块链。</p><p><code>~/.juno/config/client.toml</code> 中设置了 <code>junod</code>作为客户端的配置，将其修改为：</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="attr">chain-id</span> = <span class="string">"testing"</span></span><br><span class="line"><span class="attr">keyring-backend</span> = <span class="string">"test"</span></span><br><span class="line"><span class="attr">output</span> = <span class="string">"text"</span></span><br><span class="line"><span class="attr">node</span> = <span class="string">"tcp://localhost:26657"</span></span><br><span class="line"><span class="attr">broadcast-mode</span> = <span class="string">"sync"</span></span><br></pre></td></tr></table></figure><p>并且记住，stake 和 交易货币的名字：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STAKE=ustake</span><br><span class="line">FEE=ucosm</span><br></pre></td></tr></table></figure><h2 id="创建本地钱包并转账">2.1 创建本地钱包，并转账</h2><h3 id="创建本地钱包">1 创建本地钱包</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">junod keys add mywallet</span><br></pre></td></tr></table></figure><p>这一步并不需要和区块链交互，只是在本地的<code>~/.juno/keyring-test</code> 中生成了 <code>mywallet.info</code>。</p><p>检查是否已创建钱包：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">junod keys show mywallet </span><br></pre></td></tr></table></figure><p>只获取钱包的地址（-a, address）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">junod keys show mywallet -a</span><br></pre></td></tr></table></figure><p>钱包地址例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">juno1ddtgryk2xgt3qlsrx8z2kat9gpluw8886wpwhu</span><br></pre></td></tr></table></figure><p>此时在本地创建了一个名叫 <code>mywallet</code>的钱包，里面什么资产都没有。</p><p>查询钱包余额：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">junod query bank balances &lt;address&gt;</span><br></pre></td></tr></table></figure><p>或合并成一行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">junod query bank balances $(junod keys show mywallet -a)</span><br></pre></td></tr></table></figure><h3 id="validator-转账">2 validator 转账</h3><p>如果你是按照第一步运行区块链的，那么区块链在创建之初，就已经分配了一个名外<code>validator</code> 的账户，有很多初始资产<code>1000000000ustake,1000000000ujuno</code> 。</p><p>现在让 validator 给 mywallet 进行转账。</p><p>（这一步不能在本地执行，因为 validator 的账户信息存放在 docker容器里，没有账户的私钥是无法让它转账的）</p><p>进入 docker ，执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">junod tx bank send validator &lt;recipient_address&gt; \</span><br><span class="line">100000ucosm --fees 200ustake --chain-id testing --keyring-backend <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>将 <code>&lt;recipient_address&gt;</code> 替换为你的钱包地址。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">junod tx bank send validator juno1ddtgryk2xgt3qlsrx8z2kat9gpluw8886wpwhu 100000ucosm --fees 200ustake --chain-id testing --keyring-backend <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">junod tx bank send validator juno1ddtgryk2xgt3qlsrx8z2kat9gpluw8886wpwhu 100000ustake --fees 200ustake --chain-id testing --keyring-backend <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>如果执行成功，可以在本地查询到你的资产：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">junod query bank balances $(junod keys show mywallet -a)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">balances:</span><br><span class="line">- amount: <span class="string">"100000"</span></span><br><span class="line">  denom: ucosm</span><br><span class="line">- amount: <span class="string">"100000"</span></span><br><span class="line">  denom: ustake</span><br><span class="line">pagination:</span><br><span class="line">  next_key: null</span><br><span class="line">  total: <span class="string">"0"</span></span><br></pre></td></tr></table></figure><h2 id="部署和调用智能合约">2.2 部署和调用智能合约</h2><h3 id="前置步骤">0 前置步骤</h3><p>安装 rust 环境</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt upgrade -y</span><br><span class="line">sudo apt install curl build-essential -y</span><br><span class="line">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>检查是否安装成功：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rustc --version</span><br><span class="line">cargo --version</span><br></pre></td></tr></table></figure><p>安装 <code>cargo</code> 和 <code>wasm</code> 编译工具链，用于编译Rust 智能合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rustup default stable</span><br><span class="line">rustup target add wasm32-unknown-unknown</span><br></pre></td></tr></table></figure><p>确保你有一个账户（例如<code>mywallet</code>）并且有足够的资产来支付部署和调用费用。</p><h3 id="创建合约项目">1 创建合约项目</h3><p>如果未安装 <code>cargo-generate</code>，请运行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cargo install cargo-generate --locked</span><br></pre></td></tr></table></figure><p>使用模板创建项目：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cargo generate --git https://github.com/CosmWasm/cw-template.git --name simple_counter</span><br><span class="line">cd simple_counter</span><br></pre></td></tr></table></figure><p>这将获取一个<strong>简单计数器</strong>智能合约。</p><h3 id="编译智能合约">2 编译智能合约</h3><h4 id="编译未优化">编译（未优化）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cargo wasm</span><br></pre></td></tr></table></figure><p>得到编译好的wasm文件<code>./target/wasm32-unknown-unknown/release/simple_counter.wasm</code></p><h4 id="编译并优化">编译并优化</h4><p>只要不超过大小限制， Juno 支持上传未优化的wasm。但是为了减少合约的大小，以节省区块链上的存储成本和提高加载效率，通常需要对wasm 文件进行<strong>优化</strong>。</p><p>cosmwasm提供了一个优化器，封装了<strong>编译和优化</strong>的全过程。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull cosmwasm/optimizer:0.16.0</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 确保位于智能合约项目的根目录</span></span><br><span class="line">docker run --<span class="built_in">rm</span> -v <span class="string">"<span class="subst">$(pwd)</span>"</span>:/code cosmwasm/optimizer:0.16.0</span><br></pre></td></tr></table></figure><ul><li><code>-v "$(pwd)":/code</code> 将当前目录挂载到容器中的 /code目录。</li><li>镜像会自动构建和优化你的智能合约，并输出优化后的 .wasm 文件到项目的artifacts 目录中。</li></ul><p>但是有两个问题：</p><ol type="1"><li>下载速度很慢，甚至有 crate下载失败，可能docker镜像不能走我宿主机的代理？</li><li>每次启动都得下载，效率太低。</li></ol><p>为了解决这些问题：</p><ol type="1"><li><p>使用共享 Cargo 缓存</p><p>将宿主机的 Cargo缓存目录挂载到容器中，这样即使重新运行也能复用已下载的依赖：</p><p><code>-v "$HOME/.cargo/registry":/usr/local/cargo/registry</code>：挂载依赖缓存。</p><p><code>-v "$HOME/.cargo/git":/usr/local/cargo/git</code>：挂载 Git缓存。</p></li><li><p>运行 docker run 时传递代理环境变量：</p><p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-e HTTP_PROXY=http://your-proxy:port</span><br><span class="line">-e HTTPS_PROXY=http://your-proxy:port </span><br></pre></td></tr></table></figure></p></li></ol><p>完整的命令如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> -v <span class="string">"<span class="subst">$(pwd)</span>"</span>:/code \</span><br><span class="line">    -v <span class="string">"<span class="variable">$HOME</span>/.cargo/registry"</span>:/usr/local/cargo/registry \</span><br><span class="line">    -v <span class="string">"<span class="variable">$HOME</span>/.cargo/git"</span>:/usr/local/cargo/git \</span><br><span class="line">    -e HTTP_PROXY=http://192.168.3.56:21882 \</span><br><span class="line">    -e HTTPS_PROXY=http://192.168.3.56:21882 \</span><br><span class="line">    cosmwasm/optimizer:0.16.0</span><br></pre></td></tr></table></figure><p>此时在 <code>./artifacts</code> 中得到了优化后的 wasm文件，文件缩小了约 25%：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">240K    simple_counter.wasm(优化前)</span><br><span class="line">184K    simple_counter.wasm(优化后)</span><br></pre></td></tr></table></figure><h3 id="部署智能合约">3 部署智能合约</h3><h4 id="上传合约">3.1 <strong>上传合约</strong>：</h4><p>（注意需要 mywallet 钱包里有足够的钱）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">junod tx wasm store simple_counter.wasm --from mywallet --gas 2000000 --fees 50000ustake</span><br></pre></td></tr></table></figure><ul><li><code>gas</code> 表示交易执行所允许的最大 Gas 单位数量。</li><li><code>fees</code> 是为交易支付的手续费。</li></ul><p>最后会返回 <code>txhash</code> ，根据 <code>txhash</code>查询结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">junod query tx &lt;txhash&gt; --output json | jq '.raw_log | fromjson'</span><br></pre></td></tr></table></figure><p>记录其中的 <code>code_id</code> 。</p><h4 id="实例化合约">3.2 <strong>实例化合约</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">junod tx wasm instantiate &lt;code_id&gt; <span class="string">'{"count":0}'</span> --from mywallet --label <span class="string">"Simple Counter"</span> --gas 200000 --fees 5000ustake --admin $(junod keys show mywallet -a)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">junod tx wasm instantiate 1 <span class="string">'{"count":0}'</span> --from mywallet --label <span class="string">"Simple Counter"</span> --gas 200000 --fees 5000ustake --admin $(junod keys show mywallet -a)</span><br></pre></td></tr></table></figure><ul><li><code>--admin</code> 指定一个管理员账户</li><li>或者设置 <code>--no-admin</code>表示合约不可更改，一旦部署，任何人都不能升级或迁移该合约。</li></ul><p>根据 <code>txhash</code> 查询结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">junod query tx &lt;txhash&gt; --output json | jq '.raw_log | fromjson'</span><br></pre></td></tr></table></figure><p>记录其中的 <code>_contract_address</code> ，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">juno14hj2tavq8fpesdwxxcu44rty3hh90vhujrvcmstl4zr3txmfvw9skjuwg8</span><br></pre></td></tr></table></figure><h4 id="调用合约方法">3.3 <strong>调用合约方法</strong></h4><ul><li><p><strong>增加计数器的值</strong>：</p><p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">junod tx wasm execute &lt;contract_address&gt; <span class="string">'{"increment":{}}'</span> --from mywallet --gas 200000 --fees 5000ustake</span><br></pre></td></tr></table></figure></p><p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">junod tx wasm execute juno14hj2tavq8fpesdwxxcu44rty3hh90vhujrvcmstl4zr3txmfvw9skjuwg8 <span class="string">'{"increment":{}}'</span> --from mywallet --gas 200000 --fees 5000ustake</span><br></pre></td></tr></table></figure></p></li><li><p><strong>查询计数器的值</strong>：</p><p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">junod query wasm contract-state smart &lt;contract_address&gt; <span class="string">'{"get_count":{}}'</span></span><br></pre></td></tr></table></figure></p><p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">junod query wasm contract-state smart juno14hj2tavq8fpesdwxxcu44rty3hh90vhujrvcmstl4zr3txmfvw9skjuwg8 <span class="string">'{"get_count":{}}'</span></span><br></pre></td></tr></table></figure></p></li></ul><p>尝试多次增加计数器的值，查看返回结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data:</span><br><span class="line">  count: 2</span><br></pre></td></tr></table></figure><table><colgroup><col style="width: 19%"><col style="width: 18%"><col style="width: 20%"><col style="width: 22%"><col style="width: 18%"></colgroup><thead><tr><th><strong>操作类型</strong></th><th><strong>是否消耗 Gas</strong></th><th><strong>是否支付手续费</strong></th><th><strong>是否改变链上状态</strong></th><th><strong>是否需要签名</strong></th></tr></thead><tbody><tr><td>查询（<code>query</code>）</td><td>否</td><td>否</td><td>否</td><td>否</td></tr><tr><td>执行（<code>execute</code>）</td><td>是</td><td>是</td><td>是</td><td>是</td></tr></tbody></table><h2 id="增加新节点">2.3 增加新节点</h2><p>新增一个节点，加入这个区块链。使用本地的多个 docker容器模拟多个独立的节点。</p><h3 id="初始化新节点">1 初始化新节点</h3><p>用之前配置好的镜像 my_juno25 启动一个新的 docker容器。（记得换一个端口映射）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it -p 26658:26657 --name my-juno-local-2 my_juno25 /bin/sh</span><br></pre></td></tr></table></figure><p>初始化新节点：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">junod init &lt;new_node_name&gt; --chain-id &lt;existing_chain_id&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">junod init node002 --chain-id testing</span><br></pre></td></tr></table></figure><h3 id="复制创世区块">2 复制创世区块</h3><p>从主节点（现有节点）获取 <code>genesis.json</code>文件，并复制到新节点的配置目录。在宿主机中使用<code>docker cp</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/tmp/</span><br><span class="line">docker cp my-juno-local:/root/.juno/config/genesis.json /root/tmp/</span><br><span class="line">docker cp /root/tmp/genesis.json my-juno-local-2:/root/.juno/config/</span><br></pre></td></tr></table></figure><h3 id="设置种子节点">3 设置种子节点</h3><p>种子节点是区块链网络中特定设置的几个稳定的节点，能保持在线状态并提供稳定的连接。新节点通过和种子节点建立P2P连接，来加入区块链网络。</p><p>在我们这个例子里，种子节点就是第一个创建的主节点。</p><p>修改 <code>~/.juno/config/config.toml</code> 中的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi ~/.juno/config/config.toml </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">seeds = "&lt;node_id&gt;@&lt;ip_address&gt;:26656"</span><br></pre></td></tr></table></figure><p>其中 <code>node_id</code> 是种子节点的 id，在 my-juno-local镜像中执行如下命令获取节点 id：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">junod tendermint show-node-id</span><br></pre></td></tr></table></figure><p>ip地址，使用 docker 的默认虚拟网络，在主节点中执行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure><p>如果主节点是第一个 docker 容器，应该是 <code>172.17.0.2</code>。（也可以自定义新的docker network，不在此赘述）</p><p>最终修改为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">seeds = "4a47e5f773f7012fd82ea195be94ace24bca13ca@172.17.0.2:26656"</span><br></pre></td></tr></table></figure><p>或者使用一行指令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i 's/^seeds = ""/seeds = "&lt;node_id&gt;@&lt;ip_address&gt;:26656"/' ~/.juno/config/config.toml</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i 's/^seeds = ""/seeds = "4a47e5f773f7012fd82ea195be94ace24bca13ca@172.17.0.2:26656"/' ~/.juno/config/config.toml</span><br></pre></td></tr></table></figure><h3 id="启动新节点">4 启动新节点</h3><p>使用 <code>run_junod.sh</code> 脚本：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt</span><br><span class="line">./run_junod.sh</span><br></pre></td></tr></table></figure><p>会开始同步区块链数据，直到同步到最近的节点。</p><h3 id="验证新节点">5 验证新节点</h3><p>在宿主机中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl http://localhost:26658/status</span><br></pre></td></tr></table></figure><p>向新的节点发起查询请求：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">junod query wasm contract-state smart &lt;contract_address&gt; '{"get_count":{}}' \</span><br><span class="line">--node "tcp://localhost:26658"</span><br></pre></td></tr></table></figure><h1 id="总结-1">总结</h1><p>至此，终于运行了一个 cosmos 区块链，并且在上面部署运行了 Wasm智能合约。</p><p>最后，我发现 Juno 是在 wasmd 的基础上开发的，我误打误撞从 Juno开始学习了。本文的内容几乎可以直接迁移到 wasmd 使用和学习中。</p><p>之后的任务是：</p><ol type="1"><li>如何把 Wasm 模块单独拿出来，例如把 CosmWasm的虚拟机放到另一个服务器上，让节点通过远程调用的方式执行智能合约。</li><li>把 CosmWasm 虚拟机移植到 TEE 中。</li></ol><p>明天先继续写专利。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文写作时 Juno 版本：v25.0.0-2-gd47e0713&lt;/p&gt;
&lt;p&gt;还有官方 GPTs：Juno Simpler，数据库大概是 v12
左右的，但是还不错基本问题都能解决。&lt;/p&gt;
&lt;p&gt;Juno 是在 wasmd 的基础上开发的，我误打误撞从 Juno 开始学习了。
本文的内容几乎可以直接迁移到 wasmd
使用和学习中，部分区别我在章节末作出了补充。 &lt;del&gt;（只要全文替换 juno 为
wasm ，修改仓库和docker地址，就是 wasmd 的初见教程了）&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL0Nvc21vc0NvbnRyYWN0cy9KdW5v&quot;&gt;Juno 仓库&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL0Nvc21XYXNtL3dhc21kL3RyZWUvbWFpbg==&quot;&gt;wasmd仓库&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://cishoon.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="毕设" scheme="http://cishoon.top/tags/%E6%AF%95%E8%AE%BE/"/>
    
    <category term="Cosmos" scheme="http://cishoon.top/tags/Cosmos/"/>
    
    <category term="Juno" scheme="http://cishoon.top/tags/Juno/"/>
    
    <category term="CosmWasm" scheme="http://cishoon.top/tags/CosmWasm/"/>
    
    <category term="wasmd" scheme="http://cishoon.top/tags/wasmd/"/>
    
  </entry>
  
  <entry>
    <title>毕设09 - 毕业实训 &amp; 专利撰写</title>
    <link href="http://cishoon.top/graduation-project/09/"/>
    <id>http://cishoon.top/graduation-project/09/</id>
    <published>2024-11-11T16:00:00.000Z</published>
    <updated>2024-11-15T03:40:30.459Z</updated>
    
    <content type="html"><![CDATA[<p>专利的部分不能发博客。</p><span id="more"></span><p>加密内容◼️◼️◼️◼️◼️◼️◼️◼️◼️◼️◼️◼️◼️◼️◼️◼️◼️◼️◼️◼️</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;专利的部分不能发博客。&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://cishoon.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="毕设" scheme="http://cishoon.top/tags/%E6%AF%95%E8%AE%BE/"/>
    
    <category term="软著" scheme="http://cishoon.top/tags/%E8%BD%AF%E8%91%97/"/>
    
  </entry>
  
  <entry>
    <title>新加坡国立 CS2030 期中模拟考讲解</title>
    <link href="http://cishoon.top/CS2030/Mock/"/>
    <id>http://cishoon.top/CS2030/Mock/</id>
    <published>2024-11-10T16:00:00.000Z</published>
    <updated>2024-11-11T06:58:14.084Z</updated>
    
    <content type="html"><![CDATA[<p>模拟考试题讲解。</p><span id="more"></span><h1 id="level-1">Level 1</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;模拟考试题讲解。&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://cishoon.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="http://cishoon.top/tags/Java/"/>
    
    <category term="CS2030" scheme="http://cishoon.top/tags/CS2030/"/>
    
  </entry>
  
  <entry>
    <title>毕设08 - Cosmos 构建自己的区块链</title>
    <link href="http://cishoon.top/graduation-project/08/"/>
    <id>http://cishoon.top/graduation-project/08/</id>
    <published>2024-11-07T16:00:00.000Z</published>
    <updated>2024-11-15T03:34:25.021Z</updated>
    
    <content type="html"><![CDATA[<p>根据 https://docs.ignite.com/guide/getting-started 中的教程，实现一个Cosmos 区块链的搭建。</p><p>使用 ignite 提供的自动化构建脚本，实现 Cosmos区块链的搭建和模块设计。</p><p>内容不全面，详细的看链接网站。</p><p>但是因为 ignite 封装太多了，没完全明白如何继承模块。</p><span id="more"></span><h1 id="前置准备">前置准备</h1><ul><li><p>安装 go (1.21+)</p><p>https://ubuntuhandbook.org/index.php/2024/02/how-to-install-go-golang-1-22-in-ubuntu-22-04/#google_vignette</p><p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -c https://go.dev/dl/go1.23.1.linux-amd64.tar.gz</span><br><span class="line">tar -C /usr/local/ -xzf go1.23.1.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure></p><p>在 <code>~/.bashrc</code> 中添加：</p><p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -d <span class="string">"/usr/local/go/bin"</span> ] ; <span class="keyword">then</span></span><br><span class="line">    PATH=<span class="string">"/usr/local/go/bin:<span class="variable">$PATH</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p><p>重新载入 <code>~/.bashrc</code>：</p><p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></p><p>设置中国代理：</p><p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go env -w GO111MODULE=on</span><br><span class="line">go env -w GOPROXY=https://mirrors.aliyun.com/goproxy/,direct</span><br></pre></td></tr></table></figure></p></li><li><p>安装 Ignite CLI</p><p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo snap set system proxy.http="http://192.168.3.56:21882"</span><br><span class="line">sudo snap set system proxy.https="http://192.168.3.56:21882"</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart snapd</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">snap install ignite --classic</span><br></pre></td></tr></table></figure></p></li></ul><h1 id="创建一个新的区块链">1 创建一个新的区块链</h1><p>要使用 Ignite 创建一个新的区块链项目，需要运行以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ignite scaffold chain example</span><br></pre></td></tr></table></figure><p>在国内，安装过程中可能会有很多报错，都是代理的问题。安装成功之后输出如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@cishoon-virtual-machine:~/go]# ignite scaffold chain example</span><br><span class="line"></span><br><span class="line">⭐️ Successfully created a new blockchain 'example'.</span><br><span class="line">👉 Get started with the following commands:</span><br><span class="line"></span><br><span class="line"> % cd example</span><br><span class="line"> % ignite chain serve</span><br><span class="line"></span><br><span class="line">Documentation: https://docs.ignite.com</span><br></pre></td></tr></table></figure><p>新目录 example 中创建一个新的基于 Cosmos SDK的区块链。默认导入了多个标准模块：</p><ul><li><strong>staking</strong>：用于实现 PoS 共识机制。</li><li><strong>bank</strong>：用于实现代币的转账。</li><li><strong>gov</strong>：用于链上治理。</li></ul><h2 id="目录结构">1.1 目录结构</h2><ul><li><strong>app/目录</strong>：包含连接区块链各部分的文件。该目录中最重要的文件是<code>app.go</code>，它包含区块链的类型定义以及创建和初始化区块链的函数。此文件负责将区块链的各个组件连接在一起，并定义它们之间的交互方式。</li><li><strong>cmd/目录</strong>：包含负责已编译二进制文件的命令行接口（CLI）的主程序包。此程序包定义了可以通过CLI运行的命令以及它们的执行方式。它是区块链项目的重要组成部分，为开发人员和用户提供了一种与区块链交互的方式，例如查询区块链状态或发送交易。</li><li><strong>proto/ 目录</strong>：包含协议缓冲区（protocolbuffer）文件，用于描述区块链的数据结构。协议缓冲区是一种语言和平台无关的机制，用于序列化结构化数据，通常用于分布式系统（如区块链网络）的开发。<code>proto/</code>目录中的协议缓冲区文件定义了区块链使用的数据结构和消息，并用于生成可用于与区块链交互的各种编程语言的代码。在Cosmos SDK中，协议缓冲区文件用于定义可以被区块链发送和接收的特定数据类型，以及可用于访问区块链功能的特定RPC 端点。</li><li><strong>testutil/目录</strong>：包含用于测试的辅助函数。这些函数提供了一种方便的方式来执行编写区块链测试时所需的常见任务，例如创建测试账户、生成交易以及检查区块链状态。使用<code>testutil/</code>目录中的辅助函数，开发人员可以更快速、高效地编写测试，并确保测试全面而有效。</li><li><strong>x/ 目录</strong>：包含添加到区块链的自定义 Cosmos SDK模块。标准的 Cosmos SDK 模块是预构建的组件，提供了 Cosmos SDK区块链的常见功能，例如质押和治理支持。另一方面，自定义模块是专门为区块链项目开发的模块，用于提供特定的项目功能。</li><li><strong>config.yml文件</strong>：是一个配置文件，用于在开发过程中自定义区块链。该文件包含控制区块链各方面的设置，例如网络ID、账户余额和节点参数等。</li></ul><h1 id="启用项目">2 启用项目</h1><p>执行以下命令启用区块链：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ignite chain serve</span><br></pre></td></tr></table></figure><p><code>ignite chain serve</code>命令用于在开发模式下启动区块链节点。该命令首先使用<code>ignite chain build</code> 编译并安装二进制文件，然后使用<code>ignite chain init</code>初始化单个验证人的区块链数据目录。之后，它会在本地启动节点，并启用自动代码重载功能，使代码的更改可以直接反映在运行中的区块链上，而无需重启节点。这样可以加快区块链的开发和测试进程。</p><h1 id="hello-world">3 Hello World!</h1><p>在本教程中，你将使用 Ignite CLI构建一个简单的区块链，该区块链响应一个自定义查询并返回 "Hello %s!"，其中"%s" 是查询中传入的名字。通过此教程，你将更深入地了解如何在 Cosmos SDK区块链中<strong>创建自定义查询</strong>。</p><h2 id="创建一个新的链">3.1 创建一个新的链</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ignite scaffold chain hello</span><br><span class="line"><span class="built_in">cd</span> hello</span><br></pre></td></tr></table></figure><h2 id="生成查询代码">3.2 生成查询代码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ignite scaffold query say-hello name --response name</span></span><br><span class="line"></span><br><span class="line">modify proto/hello/hello/query.proto</span><br><span class="line">create x/hello/keeper/query_say_hello.go</span><br><span class="line">modify x/hello/module/autocli.go</span><br><span class="line"></span><br><span class="line">🎉 Created a query `say-hello`.</span><br></pre></td></tr></table></figure><p>此命令会为一个新的查询 <code>say-hello</code> 生成代码，该查询接受<code>name</code> 作为输入，并将它返回在响应中。</p><p><strong>生成的代码</strong>：</p><ul><li><code>proto/hello/hello/query.proto</code>：定义请求和响应结构。</li><li><code>x/hello/module/autocli.go</code>：包含查询的 CLI 命令。</li><li><code>x/hello/keeper/query_say_hello.go</code>：存放查询响应的逻辑。</li></ul><h3 id="proto">3.2.1 proto</h3><p>增加了一个查询接口：</p><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Queries a list of SayHello items.</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> SayHello (QuerySayHelloRequest) <span class="keyword">returns</span> (QuerySayHelloResponse) </span>{</span><br><span class="line"><span class="keyword">option</span> (google.api.http).get = <span class="string">"/hello/hello/say_hello/{name}"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">QuerySayHelloRequest</span> {</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">QuerySayHelloResponse</span> {</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="cli">3.2.2 cli</h3><p>新增了一个请求接口，但是没有包括具体实现代码，应该是封装进 Cosmos SDK中的 autocliv1 了。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Query: &amp;autocliv1.ServiceCommandDescriptor{</span><br><span class="line">    Service: modulev1.Query_ServiceDesc.ServiceName,</span><br><span class="line">    RpcCommandOptions: []*autocliv1.RpcCommandOptions{</span><br><span class="line">        {</span><br><span class="line">            RpcMethod: <span class="string">"Params"</span>,</span><br><span class="line">            Use:       <span class="string">"params"</span>,</span><br><span class="line">            Short:     <span class="string">"Shows the parameters of the module"</span>,</span><br><span class="line">        },</span><br><span class="line">        {</span><br><span class="line">            RpcMethod:      <span class="string">"SayHello"</span>,</span><br><span class="line">            Use:            <span class="string">"say-hello [name]"</span>,</span><br><span class="line">            Short:          <span class="string">"Query say-hello"</span>,</span><br><span class="line">            PositionalArgs: []*autocliv1.PositionalArgDescriptor{{ProtoField: <span class="string">"name"</span>}},</span><br><span class="line">        },</span><br><span class="line"></span><br><span class="line">        <span class="comment">// this line is used by ignite scaffolding # autocli/query</span></span><br><span class="line">    },</span><br><span class="line">},</span><br></pre></td></tr></table></figure><h3 id="keeper">3.2.3 keeper</h3><p>新增了 <code>query_say_hello.go</code> 文件：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> keeper</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"context"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"hello/x/hello/types"</span></span><br><span class="line"></span><br><span class="line">    sdk <span class="string">"github.com/cosmos/cosmos-sdk/types"</span></span><br><span class="line">    <span class="string">"google.golang.org/grpc/codes"</span></span><br><span class="line">    <span class="string">"google.golang.org/grpc/status"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q queryServer)</span></span> SayHello(ctx context.Context, req *types.QuerySayHelloRequest) (*types.QuerySayHelloResponse, <span class="type">error</span>) {</span><br><span class="line">    <span class="keyword">if</span> req == <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, status.Error(codes.InvalidArgument, <span class="string">"invalid request"</span>)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证和上下文解包</span></span><br><span class="line">    ctx := sdk.UnwrapSDKContext(ctx)</span><br><span class="line"></span><br><span class="line">    _ = ctx</span><br><span class="line">    <span class="comment">// 自定义响应</span></span><br><span class="line">    <span class="keyword">return</span> &amp;types.QuerySayHelloResponse{Name: fmt.Sprintf(<span class="string">"Hello %s!"</span>, req.Name)}, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="自定义查询响应">3.3 自定义查询响应</h2><p>修改 <code>query_say_hello.go</code>：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(k Keeper)</span></span> SayHello(goCtx context.Context, req *types.QuerySayHelloRequest) (*types.QuerySayHelloResponse, <span class="type">error</span>) {</span><br><span class="line"><span class="keyword">if</span> req == <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, status.Error(codes.InvalidArgument, <span class="string">"invalid request"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ctx := sdk.UnwrapSDKContext(goCtx)</span><br><span class="line"></span><br><span class="line">_ = ctx</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;types.QuerySayHelloResponse{Name: fmt.Sprintf(<span class="string">"Hello %s!"</span>, req.Name)}, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="启动区块链并测试">3.4 启动区块链并测试</h2><p><strong>启动区块链</strong>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ignite chain serve</span></span><br><span class="line"></span><br><span class="line">  Blockchain is running</span><br><span class="line"></span><br><span class="line">  Blockchain is running</span><br><span class="line"></span><br><span class="line">  Blockchain is running</span><br><span class="line">  </span><br><span class="line">  ✔ Added account alice with address cosmos1h2tqat8zme35fmkvk7yhp6r7r54edkg8eg0x43 and mnemonic:</span><br><span class="line">  coffee coffee female clap cake kind pledge lamp give lens accuse reopen captain poverty program reward music trust transfer ski heavy husband </span><br><span class="line">  </span><br><span class="line">  ✔ Added account bob with address cosmos1g7eamf74zkg629sd8wc0hdj88sqas8pfgrga7l and mnemonic:</span><br><span class="line">  deputy fix marble merge toy rice traffic <span class="built_in">wait</span> wife arrive laptop injury twelve doll shrimp guilt issue ripple position cereal width consider s</span><br><span class="line">  </span><br><span class="line">  🌍 Tendermint node: http://0.0.0.0:26657</span><br><span class="line">  🌍 Blockchain API: http://0.0.0.0:1317</span><br><span class="line">  🌍 Token faucet: http://0.0.0.0:4500</span><br><span class="line">  </span><br><span class="line">  ⋆ Data directory: /root/.hello</span><br><span class="line">  ⋆ App binary: /root/go/bin/hellod</span><br><span class="line">  </span><br><span class="line">  Press the <span class="string">'q'</span> key to stop serve</span><br></pre></td></tr></table></figure><p><strong>运行测试</strong>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cd /root/go/bin/hellod</span></span><br><span class="line"><span class="comment"># ./hellod q hello say-hello world</span></span><br><span class="line">name: Hello world!</span><br></pre></td></tr></table></figure><h1 id="博客增删改查">4 博客（增删改查）</h1><p>https://docs.ignite.com/guide/blog</p><p>不细写了，直接看原文吧，底下记录一点关键代码。</p><h2 id="ignite-参数类型">4.1 Ignite 参数类型</h2><blockquote><p>Ignite CLI 支持在 Cosmos SDK区块链中定义多种数据类型，以下是常用的数据类型：</p><p><strong>基本数据类型</strong></p><ul><li><strong><code>string</code></strong>：字符串类型，用于存储文本。</li><li><strong><code>bool</code></strong>：布尔类型，值为 <code>true</code>或 <code>false</code>。</li><li><strong><code>int</code></strong>：有符号整数类型，用于存储整数值。</li><li><strong><code>uint</code></strong>：无符号整数类型，只能存储非负整数。</li><li><strong><code>int64</code> / <code>uint64</code></strong>：64位的有符号和无符号整数，适合存储较大的整数值。</li></ul><p><strong>数值类型</strong></p><ul><li><strong><code>float</code></strong>：浮点数类型，用于存储小数。</li><li><strong><code>float32</code> / <code>float64</code></strong>：32位和 64 位浮点数类型，分别提供不同的精度。</li></ul><p><strong>数组和列表类型</strong></p><ul><li><strong><code>[]&lt;type&gt;</code></strong>：泛型数组类型，用于存储指定类型的多个值。例如，<code>[]string</code>表示字符串数组，<code>[]uint64</code> 表示无符号整数数组。</li></ul><p><strong>特殊类型</strong></p><ul><li><strong><code>sdk.Coin</code></strong>：用于表示 Cosmos SDK中的代币（coin）类型。代币包含数量和单位（例如<code>100atom</code>），用于表示特定数量的原生代币。</li><li><strong><code>sdk.Coins</code></strong>：表示多个代币，用于处理不同类型的资产组合。</li></ul><p><strong>自定义类型</strong></p><ul><li><strong>枚举类型（enums）</strong>：通过定义特定的字符串或整数值集合，用于表示具有有限可能值的数据。</li><li><strong>时间类型（<code>time.Time</code>）</strong>：用于存储日期和时间，通常在Cosmos SDK 项目中用于处理区块时间戳或事件时间。</li></ul><p><strong>复杂结构类型</strong></p><ul><li><strong>结构体（structs）</strong>：可以定义复杂的数据结构，包含多个字段，适用于具有多个属性的数据类型。</li></ul><p>这些数据类型提供了灵活的数据建模能力，支持开发者根据需要定义区块链的存储和处理需求。IgniteCLI 会根据指定的数据类型自动生成相关的代码、查询和接口。</p></blockquote><h2 id="codec.binarycodeccdc">4.2 codec.BinaryCodec（cdc）</h2><p><code>codec.BinaryCodec</code> 是 Cosmos SDK中用于数据编码和解码的接口。该接口包含一系列常用的函数，用于序列化（编码）和反序列化（解码）数据结构，以便进行存储、传输或模块间的数据交换。以下是<code>BinaryCodec</code> 接口中常用的函数及其作用：</p><ol type="1"><li><p><strong>MarshalBinaryBare</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">MarshalBinaryBare(o <span class="keyword">interface</span>{}) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>作用</strong>：将数据结构 <code>o</code>编码为二进制格式。</li><li><strong>使用场景</strong>：当需要将结构化数据（如消息、状态）存储到数据库或进行网络传输时，可以调用该函数进行序列化。</li><li><strong>注意</strong>：<code>MarshalBinaryBare</code>通常用于内部存储，因为它不包含附加元数据（例如字段的类型信息），编码效率较高。</li></ul></li><li><p><strong>UnmarshalBinaryBare</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">UnmarshalBinaryBare(bz []<span class="type">byte</span>, ptr <span class="keyword">interface</span>{}) <span class="type">error</span></span><br></pre></td></tr></table></figure><ul><li><strong>作用</strong>：将二进制数据 <code>bz</code>解码为结构化数据，并将结果存储在指针 <code>ptr</code>指向的变量中。</li><li><strong>使用场景</strong>：当从数据库或网络中获取到二进制数据并需要还原为原始结构时使用该函数。</li><li><strong>注意</strong>：该函数必须知道数据的具体类型，通常在解码前已经知道数据结构的类型。</li></ul></li><li><p><strong>MarshalBinaryLengthPrefixed</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">MarshalBinaryLengthPrefixed(o <span class="keyword">interface</span>{}) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>作用</strong>：将数据结构 <code>o</code>编码为带有长度前缀的二进制格式。</li><li><strong>使用场景</strong>：带长度前缀的二进制格式在传输时可以明确表示数据的边界，常用于网络通信和日志记录。</li><li><strong>优势</strong>：长度前缀提供了更好的数据包分割管理，可用于防止数据被截断或破坏。</li></ul></li><li><p><strong>UnmarshalBinaryLengthPrefixed</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">UnmarshalBinaryLengthPrefixed(bz []<span class="type">byte</span>, ptr <span class="keyword">interface</span>{}) <span class="type">error</span></span><br></pre></td></tr></table></figure><ul><li><strong>作用</strong>：将带有长度前缀的二进制数据 <code>bz</code>解码为结构化数据，并将结果存储在指针 <code>ptr</code>指向的变量中。</li><li><strong>使用场景</strong>：从网络流或文件中读取带有长度前缀的二进制数据，并还原为结构化数据时使用。</li></ul></li><li><p><strong>MarshalJSON</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">MarshalJSON(o <span class="keyword">interface</span>{}) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>作用</strong>：将数据结构 <code>o</code> 编码为 JSON格式的字节切片。</li><li><strong>使用场景</strong>：当需要将数据以 JSON格式与外部系统或前端交互时使用，便于人类阅读和调试。</li><li><strong>优势</strong>：JSON是一种通用格式，易于调试，适用于对外提供的 API 接口。</li></ul></li><li><p><strong>UnmarshalJSON</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">UnmarshalJSON(bz []<span class="type">byte</span>, ptr <span class="keyword">interface</span>{}) <span class="type">error</span></span><br></pre></td></tr></table></figure><ul><li><strong>作用</strong>：将 JSON 格式的字节切片 <code>bz</code>解码为结构化数据，并将结果存储在指针 <code>ptr</code>指向的变量中。</li><li><strong>使用场景</strong>：从外部系统或用户接口接收到 JSON数据并需要解析为结构化数据时使用。</li></ul></li><li><p><strong>MustMarshalBinaryBare</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">MustMarshalBinaryBare(o <span class="keyword">interface</span>{}) []<span class="type">byte</span></span><br></pre></td></tr></table></figure><ul><li><strong>作用</strong>：将数据结构 <code>o</code>编码为二进制格式，与 <code>MarshalBinaryBare</code>类似，但若编码出错则直接触发 <code>panic</code>。</li><li><strong>使用场景</strong>：在对编码错误容忍度较低的场景中使用，如编码错误几乎不可能发生时使用，简化代码结构。</li></ul></li><li><p><strong>MustUnmarshalBinaryBare</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">MustUnmarshalBinaryBare(bz []<span class="type">byte</span>, ptr <span class="keyword">interface</span>{})</span><br></pre></td></tr></table></figure><ul><li><strong>作用</strong>：将二进制数据 <code>bz</code>解码为结构化数据，与 <code>UnmarshalBinaryBare</code>类似，但若解码出错则直接触发 <code>panic</code>。</li><li><strong>使用场景</strong>：在确定数据不会出错的情况下简化代码，减少错误处理代码的写法。</li></ul></li><li><p><strong>MustMarshalJSON</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">MustMarshalJSON(o <span class="keyword">interface</span>{}) []<span class="type">byte</span></span><br></pre></td></tr></table></figure><ul><li><strong>作用</strong>：将数据结构 <code>o</code> 编码为 JSON格式，若编码出错则直接触发 <code>panic</code>。</li><li><strong>使用场景</strong>：在高置信度场景中快速编码 JSON数据，而无需处理编码错误。</li></ul></li><li><p><strong>MustUnmarshalJSON</strong></p></li></ol><p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">MustUnmarshalJSON(bz []<span class="type">byte</span>, ptr <span class="keyword">interface</span>{})</span><br></pre></td></tr></table></figure> - <strong>作用</strong>：将 JSON 字节切片<code>bz</code> 解码为结构化数据，若解码出错则直接触发<code>panic</code>。 - <strong>使用场景</strong>：在确定 JSON数据格式正确的场景下，减少错误处理逻辑。</p><p><code>codec.BinaryCodec</code>提供了一套完整的数据序列化和反序列化方法，适用于二进制、JSON等不同编码格式。常用的函数包括带有或不带长度前缀的二进制编码和解码、JSON编码和解码，以及支持 <code>panic</code>的编码/解码版本。选择具体函数时，可以根据数据格式要求、错误处理需求和应用场景来使用这些编码和解码函数。</p><p>直接使用 <code>MustMarshal</code> (不加后缀指定类型)会根据具体实现自动选择二进制编码或 JSON 编码，开发者无需显式指定。</p><h1 id="附录">附录</h1><h2 id="proto-简要教程">proto 简要教程</h2><p>一个 <code>.proto</code> 文件用于定义协议缓冲区（ProtocolBuffers）的消息和服务结构，主要包含以下几部分：</p><h3 id="语法声明syntax-declaration">1. <strong>语法声明（SyntaxDeclaration）</strong></h3><p><figure class="highlight proto"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br></pre></td></tr></table></figure> - 这行代码指定使用 <code>proto3</code>语法版本。<code>proto3</code> 是 Protocol Buffers 的最新版本，相比<code>proto2</code>，简化了一些规则和功能（例如，移除了可选字段默认值等）。</p><h3 id="包声明package-declaration">2. <strong>包声明（PackageDeclaration）</strong></h3><p><figure class="highlight proto"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example;</span><br></pre></td></tr></table></figure> - 声明了 <code>.proto</code>文件所属的包。包名用于组织代码结构，避免命名冲突。在生成代码时，这个包名会映射到目标语言中的命名空间，例如在Go 中会生成相应的 <code>package</code>。</p><h3 id="导入imports">3. <strong>导入（Imports）</strong></h3><p><figure class="highlight proto"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"google/protobuf/timestamp.proto"</span>;</span><br></pre></td></tr></table></figure> - 用于引入其他 <code>.proto</code>文件，重用其中定义的消息或服务。比如<code>google/protobuf/timestamp.proto</code> 提供了<code>Timestamp</code>类型，用于表示时间戳。导入的文件可以是标准库文件或用户自定义文件。</p><h3 id="消息定义message-definition">4. <strong>消息定义（MessageDefinition）</strong></h3><p><figure class="highlight proto"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">ExampleMessage</span> {</span><br><span class="line">    <span class="type">int32</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">repeated</span> <span class="type">string</span> tags = <span class="number">3</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure> - <code>message</code> 定义了数据结构，每个<code>message</code>相当于一个对象或结构体。消息中包含字段，每个字段都有类型、名称和唯一的标签编号。- 字段的标签编号（如<code>id = 1</code>）用于在序列化数据时标识字段，确保消息的兼容性。不同类型字段的作用：- <code>int32</code>、<code>string</code> 等基本类型。 -<code>repeated</code> 表示数组或列表，可以包含多个相同类型的元素。</p><h3 id="服务定义service-definition">5. <strong>服务定义（ServiceDefinition）</strong></h3><p><figure class="highlight proto"><table><tr><td class="code"><pre><span class="line"><span class="keyword">service </span><span class="title class_">ExampleService</span> {</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> GetExample (ExampleRequest) <span class="keyword">returns</span> (ExampleResponse)</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure> - 定义服务接口，类似于定义 API的端点。<code>service</code> 内部包含一组 RPC方法，用于客户端和服务器之间的远程过程调用。 - 每个 RPC方法指定请求和响应的消息类型（如 <code>ExampleRequest</code> 和<code>ExampleResponse</code>），定义了客户端调用该方法时需要的输入和返回的输出。</p><h3 id="枚举类型enum-definition">6. <strong>枚举类型（EnumDefinition）</strong></h3><p><figure class="highlight proto"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum </span><span class="title class_">Status</span> {</span><br><span class="line">    UNKNOWN = <span class="number">0</span>;</span><br><span class="line">    ACTIVE = <span class="number">1</span>;</span><br><span class="line">    INACTIVE = <span class="number">2</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure> -定义枚举类型，提供一组命名常量。每个枚举值都有一个编号，通常从<code>0</code>开始。这些常量可以在消息中用作字段的值，用于表示一组有限的选项或状态。</p><h3 id="示例-.proto-文件结构">示例 <code>.proto</code> 文件结构</h3><figure class="highlight proto"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"google/protobuf/timestamp.proto"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">ExampleRequest</span> {</span><br><span class="line">    <span class="type">int32</span> id = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">ExampleResponse</span> {</span><br><span class="line">    <span class="type">string</span> message = <span class="number">1</span>;</span><br><span class="line">    google.protobuf.Timestamp timestamp = <span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum </span><span class="title class_">Status</span> {</span><br><span class="line">    UNKNOWN = <span class="number">0</span>;</span><br><span class="line">    ACTIVE = <span class="number">1</span>;</span><br><span class="line">    INACTIVE = <span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">service </span><span class="title class_">ExampleService</span> {</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> GetExample (ExampleRequest) <span class="keyword">returns</span> (ExampleResponse)</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><p><strong>Protocol Buffers（.proto 文件）</strong>是一种与语言无关、平台无关的序列化数据结构定义方式，主要用于定义复杂的数据实体以及服务接口。虽然它在Go 中非常常用，但它并不局限于 Go，其他语言（如Python、Java、C++）也可以通过 <code>.proto</code>文件生成相应的数据结构和代码。</p><p>在 Go 中，<code>.proto</code> 文件通常用来定义以下内容：</p><ol type="1"><li><strong>数据结构</strong>：定义复杂的数据实体（<code>message</code>），包含字段类型和序号，用于跨网络传输和存储。</li><li><strong>服务接口</strong>：定义 gRPC服务（<code>service</code>），包含可调用的 RPC方法，规定了请求和响应类型，使不同服务之间能够进行 RPC 通信。</li></ol><p>因此，<code>.proto</code>文件的作用不仅仅是定义数据结构，还可以定义服务接口，使得不同服务之间能够高效通信。</p><h2 id="keeper-1">Keeper</h2><p>在 Cosmos SDK 的项目结构中，<code>keeper</code>文件夹主要负责模块内部的核心业务逻辑和状态管理。<code>keeper</code>是每个 Cosmos SDK模块的重要组件，它封装了模块的数据访问和操作逻辑，确保数据的读取和写入是安全且一致的。以下是<code>keeper</code> 文件夹的主要内容：</p><h3 id="keeper-结构体">1. <strong>Keeper 结构体</strong></h3><ul><li><code>keeper</code> 文件夹通常包含一个 <code>Keeper</code>结构体，该结构体负责管理模块的状态、配置和依赖。它通常包含一些存储的引用、其他模块的接口以及上下文，方便模块与Cosmos SDK 的其他部分进行交互。</li><li>典型的 <code>Keeper</code>结构体定义会包含模块的存储器（store）、上下文（context）、其他模块的引用等，确保模块之间的数据可以安全地访问和修改。</li></ul><p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Keeper <span class="keyword">struct</span> {</span><br><span class="line">    storeKey   sdk.StoreKey</span><br><span class="line">    cdc        codec.BinaryCodec</span><br><span class="line">    bankKeeper types.BankKeeper</span><br><span class="line">    <span class="comment">// 其他依赖</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></p><h3 id="构造函数">2. <strong>构造函数</strong></h3><ul><li><code>keeper</code> 文件夹中通常会定义一个构造函数，用于初始化<code>Keeper</code>结构体。构造函数会接受必要的依赖（如存储键、编码器和其他模块的keeper），并将其赋值给 <code>Keeper</code> 结构体。</li><li>通过构造函数，模块可以确保在创建时正确配置并提供所有依赖关系。</li></ul><p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewKeeper</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    cdc codec.BinaryCodec,</span></span></span><br><span class="line"><span class="params"><span class="function">    key sdk.StoreKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    bankKeeper types.BankKeeper,</span></span></span><br><span class="line"><span class="params"><span class="function">    // 其他依赖</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> Keeper {</span><br><span class="line">    <span class="keyword">return</span> Keeper{</span><br><span class="line">        storeKey: key,</span><br><span class="line">        cdc:      cdc,</span><br><span class="line">        bankKeeper: bankKeeper,</span><br><span class="line">        <span class="comment">// 其他赋值</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p><h3 id="查询逻辑">3. <strong>查询逻辑</strong></h3><ul><li><code>keeper</code>文件夹包含查询函数，用于处理模块的自定义查询请求。这些函数通过<code>gRPC</code> 和 <code>CLI</code>接口向外部提供模块数据的查询。</li><li>查询函数会接受上下文和请求参数，访问状态存储，并返回响应。这些函数一般位于<code>query_xxx.go</code> 文件中，例如<code>query_say_hello.go</code>。</li></ul><p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(k Keeper)</span></span> SayHello(ctx context.Context, req *types.QuerySayHelloRequest) (*types.QuerySayHelloResponse, <span class="type">error</span>) {</span><br><span class="line">    <span class="comment">// 实现查询逻辑</span></span><br><span class="line">    <span class="keyword">return</span> &amp;types.QuerySayHelloResponse{Name: <span class="string">"Hello Cosmos"</span>}, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></p><h3 id="消息处理逻辑">4. <strong>消息处理逻辑</strong></h3><ul><li><code>keeper</code>文件夹中还包含模块的消息处理逻辑。消息是模块对区块链状态进行操作的主要手段。每个消息处理函数都会在<code>keeper</code> 中实现，并且通常会在 <code>msg_xxx.go</code>文件中定义。</li><li>消息处理函数通过接收请求参数和上下文执行特定的状态更改，如更新账户余额、修改参数等。</li></ul><p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(k Keeper)</span></span> HandleMsgSend(ctx sdk.Context, msg *types.MsgSend) (*types.MsgSendResponse, <span class="type">error</span>) {</span><br><span class="line">    <span class="comment">// 实现消息处理逻辑</span></span><br><span class="line">    <span class="keyword">return</span> &amp;types.MsgSendResponse{}, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></p><h3 id="状态管理">5. <strong>状态管理</strong></h3><ul><li><code>keeper</code>文件夹还包含状态管理相关的逻辑，用于直接与区块链的存储层交互。<code>Keeper</code>结构体会使用存储器访问模块的状态数据，并提供创建、读取、更新和删除（CRUD）操作。</li><li>这些状态管理函数确保数据的持久性和一致性。例如，可以有<code>SetData</code> 和 <code>GetData</code>函数，用于写入和读取模块数据。</li></ul><p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(k Keeper)</span></span> SetData(ctx sdk.Context, key <span class="type">string</span>, value <span class="type">string</span>) {</span><br><span class="line">    store := ctx.KVStore(k.storeKey)</span><br><span class="line">    store.Set([]<span class="type">byte</span>(key), []<span class="type">byte</span>(value))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(k Keeper)</span></span> GetData(ctx sdk.Context, key <span class="type">string</span>) (<span class="type">string</span>, <span class="type">error</span>) {</span><br><span class="line">    store := ctx.KVStore(k.storeKey)</span><br><span class="line">    bz := store.Get([]<span class="type">byte</span>(key))</span><br><span class="line">    <span class="keyword">if</span> bz == <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"not found"</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(bz), <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></p><h3 id="事件记录">6. <strong>事件记录</strong></h3><ul><li>在某些业务逻辑中，<code>Keeper</code>还会使用事件记录来追踪操作。这些事件可以用于链上和链下分析，如记录交易或数据更新。</li><li>事件记录通常通过 <code>ctx.EventManager()</code>生成，并随模块的操作一起写入区块链日志。</li></ul><h3 id="总结-1">总结</h3><p><code>keeper</code> 文件夹在 Cosmos SDK模块中扮演了核心角色，负责管理模块的业务逻辑、查询和状态存储。它为模块提供了统一的接口与其他模块和存储进行交互，确保数据操作的安全性和一致性。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;根据 https://docs.ignite.com/guide/getting-started 中的教程，实现一个
Cosmos 区块链的搭建。&lt;/p&gt;
&lt;p&gt;使用 ignite 提供的自动化构建脚本，实现 Cosmos
区块链的搭建和模块设计。&lt;/p&gt;
&lt;p&gt;内容不全面，详细的看链接网站。&lt;/p&gt;
&lt;p&gt;但是因为 ignite 封装太多了，没完全明白如何继承模块。&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://cishoon.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="区块链" scheme="http://cishoon.top/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="毕设" scheme="http://cishoon.top/tags/%E6%AF%95%E8%AE%BE/"/>
    
    <category term="Cosmos" scheme="http://cishoon.top/tags/Cosmos/"/>
    
    <category term="Go" scheme="http://cishoon.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>新加坡国立 CS2030 知识点整理</title>
    <link href="http://cishoon.top/CS2030/2024-11-02-%E6%96%B0%E5%8A%A0%E5%9D%A1%E5%9B%BD%E7%AB%8B-CS2030-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <id>http://cishoon.top/CS2030/2024-11-02-%E6%96%B0%E5%8A%A0%E5%9D%A1%E5%9B%BD%E7%AB%8B-CS2030-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</id>
    <published>2024-11-01T16:00:00.000Z</published>
    <updated>2024-11-07T13:41:46.661Z</updated>
    
    <content type="html"><![CDATA[<ul><li>CS2030 PA2 知识点整理</li><li>Stringable 和 StateM 详细解析</li></ul><span id="more"></span><p>[TOC]</p><h1 id="知识点整理">知识点整理</h1><h2 id="纯函数">1 纯函数</h2><h3 id="构造定义纯函数">1.1 构造（定义纯函数）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;输入参数类型, 返回值类型&gt; f = $Lambda表达式$;</span><br></pre></td></tr></table></figure><blockquote><p>Lambda 表达式形如：</p><ul><li><code>x -&gt; x + 1</code> ：输入参数→返回值</li><li><code>x -&gt; {return x + 1;}</code> 输入参数 → 语句体（内含有return 返回值）</li></ul></blockquote><p>用数学语言表达，就是： <span class="math display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="12.507ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 5528 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(550,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(939,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mo" transform="translate(1511,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2177.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(3233.6,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mo" transform="translate(4027.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(5028,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></span> 代入不同的 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.294ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 572 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g></g></g></svg></mjx-container></span>会返回不同的值： <span class="math display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="16.329ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 7217.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(550,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(939,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(1439,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2105.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(3161.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(3883.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(4884,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(5661.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(6717.6,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g></g></g></svg></mjx-container></span>纯函数只有<strong>一个输入参数</strong>，想要实现多个输入参数的纯函数比较复杂，如果作业中没有用到就不记。</p><p>本质上就是把返回值的类型变成另一个函数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;输入类型<span class="number">1</span>, </span><br><span class="line"> Funciont&lt;输入类型<span class="number">2</span>, 返回值类型&gt;</span><br><span class="line">&gt; f = $Lambda表达式$</span><br></pre></td></tr></table></figure><p>举例，两数求和。输入参数是两个 <code>Integer</code>，返回类型是<code>Integer</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;Integer, Function&lt;Integer, Integer&gt;&gt; add = arg1 -&gt; (这是外层的返回值，应该是一个Lambda表达式);</span><br><span class="line"></span><br><span class="line">(这是外层的返回值，应该是一个Lambda表达式) = arg2 -&gt; arg1 + arg2;</span><br><span class="line"></span><br><span class="line">合起来：</span><br><span class="line">Function&lt;Integer, Function&lt;Integer, Integer&gt;&gt; add = arg1 -&gt; arg2 -&gt; arg1 + arg2;</span><br></pre></td></tr></table></figure><h3 id="调用">1.2 调用</h3><p>使用 <code>apply</code> 方法进行调用。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jshell&gt; add.apply(1)</span><br><span class="line"><span class="variable">$3</span> ==&gt; <span class="variable">$Lambda</span>@1$ </span><br><span class="line"></span><br><span class="line">jshell&gt; add.apply(1).apply(2)</span><br><span class="line"><span class="variable">$4</span> ==&gt; 3  </span><br></pre></td></tr></table></figure><h3 id="组合嵌套">1.3 组合（嵌套）</h3><p>在数学中经常有函数嵌套的写法： $$ f(x) = x + 1 \ g(x) = x \</p><p>h(x) = g(f(x)) $$ <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="1.079ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 477 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g></g></g></svg></mjx-container></span> 嵌套 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="1.244ex" height="2.059ex" role="img" focusable="false" viewbox="0 -705 550 910"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g></g></g></svg></mjx-container></span> ，就是把 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.299ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 1900 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(550,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(939,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mo" transform="translate(1511,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></span> 的返回值，当做 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.133ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 1827 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mo" transform="translate(477,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(866,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mo" transform="translate(1438,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></span> 的输入。</p><p>使用 <code>compose</code> 方法，实现函数的嵌套。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;Integer, Integer&gt; f = x -&gt; x + <span class="number">1</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; g = x -&gt; x * <span class="number">2</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; h = g.compose(f); <span class="comment">// g 嵌套 f，g compose f</span></span><br></pre></td></tr></table></figure><p>代码的写法很符合自然语序。</p><p>使用嵌套的函数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jshell&gt; h.apply(<span class="number">3</span>)</span><br><span class="line">$<span class="number">8</span> ==&gt; <span class="number">8</span></span><br></pre></td></tr></table></figure><p>就等价与 <span class="math display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="44.253ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 19559.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mo" transform="translate(576,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(965,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g><g data-mml-node="mo" transform="translate(1465,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2131.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(3187.6,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mo" transform="translate(3664.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(4053.6,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(4603.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(4992.6,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g><g data-mml-node="mo" transform="translate(5492.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(5881.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(6548.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(7604.1,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mo" transform="translate(8081.1,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(8470.1,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g><g data-mml-node="mo" transform="translate(9192.3,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(10192.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(10692.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(11359.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(12415.1,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mo" transform="translate(12892.1,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(13281.1,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"/></g><g data-mml-node="mo" transform="translate(13781.1,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(14447.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(15503.7,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"/></g><g data-mml-node="mo" transform="translate(16225.9,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"/></g><g data-mml-node="mn" transform="translate(17226.1,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(18003.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(19059.7,0)"><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z"/></g></g></g></svg></mjx-container></span></p><h3 id="comsumer-和-supplier">1.4 Comsumer 和 Supplier</h3><p>这两个接口是 Function 的子集。分别没有返回值和输入参数。</p><h4 id="comsumer">Comsumer</h4><p>Comsumer&lt;输入参数类型&gt;</p><p>只有一个接口：accept</p><p>定义：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Consumer&lt;String&gt; printer = s -&gt; System.out.println("Output: " + s);</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jshell&gt; printer.accept(<span class="string">"Hello"</span>)</span><br><span class="line">Output: Hello</span><br></pre></td></tr></table></figure><h4 id="supplier">Supplier</h4><p>Supplier&lt;返回值类型&gt;</p><p>只有一个接口：get</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Supplier&lt;Double&gt; randomSupplier = () -&gt; Math.random();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jshell&gt; randomSupplier.get()</span><br><span class="line">$.. ==&gt; 0.7238678136192443</span><br></pre></td></tr></table></figure><h2 id="map-与-flatmap">2 map 与 flatMap</h2><p>考点中经常会要手动实现 <code>map</code> 和 <code>flatMap</code>这两个函数。先理解他们的作用。</p><p><code>map</code> 和 <code>flatMap</code> 都是<code>Stream&lt;T&gt;</code> 接口的成员。</p><p>通常，一个类如果可以被遍历，就是实现了 <code>Stream&lt;T&gt;</code>接口。</p><ul><li><p><strong>map</strong></p><ul><li><p>输入参数：<code>Function&lt;T, R&gt;</code>表示一个映射关系</p></li><li><p>作用：将流中的每一个元素，从类型 T 转换为类型 R。</p></li></ul></li><li><p><strong>flatMap</strong></p><ul><li>输入参数：<code>Function&lt;T, Stream&lt;R&gt;&gt;</code></li><li>返回值：Stream&lt;R&gt;。<strong><code>flatMap</code>的返回值，和调用他对象的类型必须一样</strong></li><li>作用：通常用于处理<strong>嵌套</strong>的列表，将列表中的每一项<strong>展开</strong>，返回一个解除嵌套的列表。</li></ul></li></ul><p>举例：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jshell&gt; Stream.of(1, 2, 3, 4, 5).map(x -&gt; x + 1).toList();</span><br><span class="line"><span class="variable">$129</span> ==&gt; [2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jshell&gt; Stream.of(</span><br><span class="line">   ...&gt; Stream.of(1, 2, 3),</span><br><span class="line">   ...&gt;Stream.of(4, 5, 6), </span><br><span class="line">   ...&gt; Stream.of(7, 8)</span><br><span class="line">   ...&gt; ).flatMap(stream -&gt; stream).toList() <span class="comment"># 其中的stream是每一个子Stream</span></span><br><span class="line"><span class="variable">$133</span> ==&gt; [1, 2, 3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jshell&gt; Stream.of(</span><br><span class="line">   ...&gt; Stream.of(1, 2, 3),Stream.of(4, 5, 6), Stream.of(7, 8)</span><br><span class="line">   ...&gt; ).flatMap(stream -&gt; stream.map(x-&gt;x+1)).toList() <span class="comment"># 对每一个子类先进行+1的操作，再合并</span></span><br><span class="line"><span class="variable">$134</span> ==&gt; [2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jshell&gt; Stream.of(</span><br><span class="line">   ...&gt; Stream.of(1, 2, 3),Stream.of(4, 5, 6), Stream.of(7, 8)</span><br><span class="line">   ...&gt; ).flatMap(x -&gt; x).map(x-&gt;x+1).toList() <span class="comment"># 先合并，再+1</span></span><br><span class="line"><span class="variable">$135</span> ==&gt; [2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure><p>但是，在作业中，<code>flatMap</code>通常不用做<strong>展开</strong>，而是用于把某个类的操作<strong>串联</strong>起来。</p><p>题目中并不喜欢让你写应用在数组上的 <code>map</code> 和<code>flatMap</code> ，而是仿照 <code>Optional</code>，应用在一个类上，是用来提取类中包裹的数据的。</p><h2 id="泛型-generic">3 泛型 generic</h2><p>考试中，不需要写复杂的 &lt;? extend XXX&gt;类似的内容，所以单从语法上出发，泛型的考点很少。</p><p>重点见 <a href="#%20成员函数泛型">附录-成员函数泛型</a></p><h1 id="练习-ay2324-semester-2-statem">练习 <span class="exturl" data-url="aHR0cHM6Ly9ydXNzZWxsZGFzaDMzMi5naXRodWIuaW8vQ1MyMDMwL1BBL1BBMi8yMzIwL1BBMl8yMzIwLmh0bWw=">AY23/24Semester 2: StateM<i class="fa fa-external-link-alt"></i></span></h1><p>https://russelldash332.github.io/CS2030/PA/PA2/2320/PA2_2320.html</p><h2 id="level-1">Level 1</h2><p>要求：实现两个函数，<code>unit</code> 和 <code>toString</code>，<strong>不允许添加任何成员变量</strong>。</p><p><img src="/CS2030/2024-11-02-%E6%96%B0%E5%8A%A0%E5%9D%A1%E5%9B%BD%E7%AB%8B-CS2030-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/202411021336879.png" alt="image-20241102133529986" style="zoom:50%;"></p><p>分析源码，只有一个成员变量，是一个纯函数。所以是那种<code>lazy</code>延迟计算的思路，把需要初始化的变量添加成函数的返回值。</p><p><code>unit</code> 是一个静态工厂方法，输入参数 T，返回 StateM的实例。输入参数包裹在他的成员变量纯函数f里。</p><p>toString 直接返回 <code>StateM</code> 。</p><figure><img src="/CS2030/2024-11-02-%E6%96%B0%E5%8A%A0%E5%9D%A1%E5%9B%BD%E7%AB%8B-CS2030-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/202411021343887.png" alt="image-20241102134330517"><figcaption aria-hidden="true">image-20241102134330517</figcaption></figure><p>现在问题就是，纯函数 <code>f</code>长什么样？换言之，怎么<strong>构造</strong>、怎么<strong>调用</strong></p><p>构造：</p><ul><li>输入类型：S</li><li>返回类型：Pair&lt;T, S&gt;</li><li>函数关系（表达式）：传进去的参数 f<ul><li>unit里提供的参数，是返回值的 T，accept 提供的参数，是返回值的 S</li></ul></li></ul><p>调用：</p><ul><li>accept方法，直接调用成员变量参数 f 。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="comment">// extends 继承，父类和子类，抽象类也是类，用继承</span></span><br><span class="line"><span class="comment">// implements 实现，接口和类，接口用实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StateM</span>&lt;T, S&gt; <span class="keyword">extends</span> <span class="title class_">AbstractStateM</span>&lt;T, S&gt; {    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">StateM</span><span class="params">(T t)</span> {</span><br><span class="line">        <span class="built_in">super</span>(t);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 错误，没有泛型参数</span></span><br><span class="line">    <span class="comment">// public static StateM&lt;T, S&gt; unit(T t) {</span></span><br><span class="line">    <span class="comment">//     return new StateM&lt;T, S&gt;(t);</span></span><br><span class="line">    <span class="comment">// }</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态方法的类型，需要在 static 后面声明 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, S&gt; StateM&lt;T, S&gt; <span class="title function_">unit</span><span class="params">(T t)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StateM</span>&lt;T, S&gt;(t);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"StateM"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="level-2">Level 2</h2><p>新增两个方法，用于 state 的读和写：</p><ul><li><p>&lt;T&gt;get：</p><ul><li>作用：构造一个新的 StateM，其函数：<ul><li>输入类型：T</li><li>返回类型：Pair&lt;T, T&gt;</li><li>x -&gt; Pair(x, x)</li></ul></li><li>输入参数：无</li><li>返回类型：StateM</li></ul><p><img src="/CS2030/2024-11-02-%E6%96%B0%E5%8A%A0%E5%9D%A1%E5%9B%BD%E7%AB%8B-CS2030-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/202411021416686.png" alt="image-20241102141639202" style="zoom:50%;"></p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">StateM</span><span class="params">(Function&lt;S,Pair&lt;T,S&gt;&gt; f)</span> {</span><br><span class="line">    <span class="built_in">super</span>(f);</span><br><span class="line">}</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; StateM&lt;T, T&gt; <span class="title function_">get</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StateM</span>&lt;T, T&gt;(x -&gt; <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;T, T&gt;(x, x));</span><br><span class="line">}</span><br></pre></td></tr></table></figure><ul><li><p>put</p><p>示例：</p><p><img src="/CS2030/2024-11-02-%E6%96%B0%E5%8A%A0%E5%9D%A1%E5%9B%BD%E7%AB%8B-CS2030-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20241102160127264.png" alt="image-20241102160127264" style="zoom: 33%;"></p><ul><li>作用：构造一个新的 StateM，其函数：<ul><li>输入类型：S</li><li>输出类型：Pair(Nothing, S)</li><li>x -&gt; Pair(Nothing, S)</li></ul></li></ul></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">public <span class="type">static</span> &lt;S&gt; StateM&lt;Nothing, S&gt; <span class="title function_">put</span><span class="params">(S s)</span> {</span><br><span class="line">    <span class="keyword">return</span> new StateM&lt;Nothing, S&gt;(x -&gt; new Pair&lt;Nothing, S&gt;(Nothing.nothing(), s));</span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Nothing</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Nothing</span><span class="params">()</span> {}</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Nothing <span class="title function_">nothing</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Nothing</span>();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"-"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="level-3">Level 3</h2><p>写一个 flatMap 函数。复习一下：<code>flatMap</code>的返回值，和调用他对象的类型必须一样。</p><p>所以这里的 StateM 的 flatMap ，返回值一定是 StateM。</p><figure><img src="/CS2030/2024-11-02-%E6%96%B0%E5%8A%A0%E5%9D%A1%E5%9B%BD%E7%AB%8B-CS2030-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20241102150451624.png" alt="image-20241102150451624"><figcaption aria-hidden="true">image-20241102150451624</figcaption></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StateM.&lt;String, Integer&gt;unit(<span class="string">"init"</span>);</span><br><span class="line">(init, ) <span class="comment">// 返回值是 unit 传进去的参数, 后面 accept 传进去的参数，所以只用管</span></span><br></pre></td></tr></table></figure><ul><li>输入参数：Function<ul><li>输入：原始的 StateM ，unit传进去的参数！（更准确的，返回值的first），后面我们叫他 value</li><li>输出：新的 StateM</li></ul></li><li>返回值：新的 StateM （Function的输出！）</li></ul><p>这里有点绕，一步步来：</p><p>根据分析的输入参数和返回值，写出函数的声明：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; StateM&lt;U, S&gt; <span class="title function_">flatMap</span><span class="params">(Function&lt;T, StateM&lt;U, S&gt;&gt; mapper)</span> {</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>根据示例，很显然，<code>flatMap</code> 返回值就是 <code>mapper</code>的返回值，所以有：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; StateM&lt;U, S&gt; <span class="title function_">flatMap</span><span class="params">(Function&lt;T, StateM&lt;U, S&gt;&gt; mapper)</span> {</span><br><span class="line"><span class="keyword">return</span> mapper.apply(t);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>但是这里没有 <code>t</code> 啊。t 就是当前 <code>StateM</code> 构造时<code>unit</code> 传进去的参数，被我们叫做 <code>value</code>的变量。我们可以通过 <code>this.accept(s)</code>来得到函数的返回值，所以有：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; StateM&lt;U, S&gt; <span class="title function_">flatMap</span><span class="params">(Function&lt;T, StateM&lt;U, S&gt;&gt; mapper)</span> {</span><br><span class="line">    <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="built_in">this</span>.accept(s).first();</span><br><span class="line"><span class="keyword">return</span> mapper.apply(t);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>但是还是不知道 <code>s</code> 啊！<code>s</code> 是<code>accept</code> 的参数，用户调用 <code>accept</code> 的时候，才把<code>accept</code> 传进来，调用 this.f 。这不就是所说的 lazy延迟计算吗？所以这里的 s，应该是我自己定义的一个<code>Lambda</code>函数的参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; StateM&lt;U, S&gt; <span class="title function_">flatMap</span><span class="params">(Function&lt;T, StateM&lt;U, S&gt;&gt; mapper)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StateM</span>&lt;U, S&gt; (s -&gt; {</span><br><span class="line">       <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="built_in">this</span>.accept(s).first();</span><br><span class="line">       StateM&lt;U, S&gt; state = mapper.apply(t);</span><br><span class="line">       <span class="keyword">return</span> state.accept(s);</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>然后执行测试，运行到这一句发现不对了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StateM&lt;Integer, Integer&gt; <span class="title function_">bar</span><span class="params">(StateM&lt;String, Integer&gt; sm)</span> {</span><br><span class="line">    <span class="keyword">return</span> sm.flatMap(x -&gt; StateM.&lt;Integer&gt;get().flatMap(y -&gt; StateM.&lt;Integer&gt;put(y + <span class="number">10</span>))</span><br><span class="line">             .flatMap(z -&gt; StateM.&lt;Integer, Integer&gt;unit(x.length())));</span><br><span class="line">}</span><br><span class="line">bar(StateM.&lt;String, Integer&gt;unit(<span class="string">"init"</span>)).accept(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">(<span class="number">4</span>, <span class="number">11</span>)</span><br></pre></td></tr></table></figure><p>我的结果是 <code>(4, 1)</code> ，显然是 <code>put(y + 10)</code>没被执行。</p><p>因为 pair 的第二个值经过 <code>accept</code> 会被修改，而我在<code>flatMap</code> 里一直用的是最早的 s 。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; StateM&lt;U, S&gt; <span class="title function_">flatMap</span><span class="params">(Function&lt;T, StateM&lt;U, S&gt;&gt; mapper)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StateM</span>&lt;U, S&gt;(s -&gt; {</span><br><span class="line">        Pair&lt;T, S&gt; pair = <span class="built_in">this</span>.accept(s);</span><br><span class="line">        StateM&lt;U, S&gt; state = mapper.apply(pair.first());</span><br><span class="line">        Pair&lt;U, S&gt; newPair = state.accept(pair.second());</span><br><span class="line">        <span class="keyword">return</span> newPair;</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="level-4">Level 4</h2><p>创建 inc() ，但是不允许使用构造函数，因为是 <code>private</code>的。上面的 <code>bar</code> 其实提供了提示。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StateM&lt;Nothing, Integer&gt; <span class="title function_">inc</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> StateM.&lt;Integer&gt;get().flatMap(x -&gt; StateM.&lt;Integer&gt;put(x + <span class="number">1</span>));</span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StateM&lt;Integer, Integer&gt; <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="keyword">return</span> inc().flatMap(ignore -&gt; {</span><br><span class="line">       <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) {</span><br><span class="line">           <span class="keyword">return</span> StateM.unit(n);</span><br><span class="line">       } <span class="keyword">else</span> {</span><br><span class="line">           <span class="keyword">return</span> fib(n - <span class="number">1</span>).flatMap(x -&gt; fib(n - <span class="number">2</span>).flatMap(y -&gt; StateM.unit(x + y)));</span><br><span class="line">       }</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>解释：考试时，捋不清楚，想不明白他的含义没事，也能做完 Level 3.</p><ul><li>Pair&lt;T, S&gt; 的 T ，是计算的结果，S是历史记录、状态</li><li>get，用于返回历史记录，把现在的历史记录设置给 T。把 s 赋值给t。</li><li>put，用于修改历史记录，把 T 设置为 Nothing 。</li><li>flatMap，用于串联计算。inc().flatMap(ignore -&gt; inc());表示连续执行 inc，inc，两次。</li></ul><p>fib(n - 1).flatMap(x -&gt; fib(n - 2).flatMap(y -&gt; StateM.unit(x +y)));</p><p>先执行 fib(n - 1) ，再执行 fib (n - 2) ，在执行 StateM.unit(x +y);</p><h2 id="level-5">Level 5</h2><p>很难，很绕。考试时没时间就不写，很合理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FuncStat</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer depth;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer maxDepth;</span><br><span class="line">    </span><br><span class="line">    FuncStat() {</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.depth = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.maxDepth = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    FuncStat(<span class="type">int</span> count, <span class="type">int</span> depth, <span class="type">int</span> maxDepth) {</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">        <span class="built_in">this</span>.depth = depth;</span><br><span class="line">        <span class="built_in">this</span>.maxDepth = Math.max(depth, maxDepth);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> FuncStat <span class="title function_">incCount</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FuncStat</span>(count + <span class="number">1</span>, depth, maxDepth);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> FuncStat <span class="title function_">incDepth</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FuncStat</span>(count, depth + <span class="number">1</span>, Math.max(depth + <span class="number">1</span>, maxDepth));</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> FuncStat <span class="title function_">decDepth</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FuncStat</span>(count, depth - <span class="number">1</span>, maxDepth);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[count="</span> + count + <span class="string">" maxDepth="</span> + maxDepth + <span class="string">"]"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ack</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> ack(m - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ack(m - <span class="number">1</span>, ack(m, n - <span class="number">1</span>));</span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StateM&lt;Integer, FuncState&gt; <span class="title function_">ack</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        inc();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> unit(n + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">do</span> {</span><br><span class="line">                x &lt;- ack(m - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> unit(x);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">        x &lt;- ack(m, n - <span class="number">1</span>);</span><br><span class="line">    y &lt;- ack(m - <span class="number">1</span>, x);</span><br><span class="line">            <span class="keyword">return</span> unit(y);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StateM&lt;Nothing, FuncStat&gt; <span class="title function_">incCount</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> StateM.&lt;FuncStat&gt;get().flatMap(x -&gt; StateM.&lt;FuncStat&gt;put(x.incCount()));</span><br><span class="line">}</span><br><span class="line">StateM&lt;Nothing, FuncStat&gt; <span class="title function_">incDepth</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> StateM.&lt;FuncStat&gt;get().flatMap(x -&gt; StateM.&lt;FuncStat&gt;put(x.incDepth()));</span><br><span class="line">}</span><br><span class="line">StateM&lt;Nothing, FuncStat&gt; <span class="title function_">decDepth</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> StateM.&lt;FuncStat&gt;get().flatMap(x -&gt; StateM.&lt;FuncStat&gt;put(x.decDepth()));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">StateM&lt;Integer, FuncStat&gt; <span class="title function_">ack</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="keyword">return</span> incCount().flatMap(ignoreCount -&gt; </span><br><span class="line">        incDepth().flatMap(ignoreDepth -&gt; {</span><br><span class="line">            <span class="keyword">if</span> (m == <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">return</span> decDepth().flatMap(ignore -&gt; StateM.unit(n + <span class="number">1</span>));</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">return</span> ack(m - <span class="number">1</span>, <span class="number">1</span>).flatMap(result -&gt; </span><br><span class="line">                    decDepth().flatMap(ignore -&gt; StateM.unit(result))</span><br><span class="line">                );</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> ack(m, n - <span class="number">1</span>).flatMap(tempResult -&gt; </span><br><span class="line">                ack(m - <span class="number">1</span>, tempResult).flatMap(result -&gt; </span><br><span class="line">                    decDepth().flatMap(ignore -&gt; StateM.unit(result))</span><br><span class="line">                )</span><br><span class="line">            );</span><br><span class="line">        })</span><br><span class="line">    );</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h1 id="练习-ay2324-semester-1-stringable">练习 <span class="exturl" data-url="aHR0cHM6Ly9ydXNzZWxsZGFzaDMzMi5naXRodWIuaW8vQ1MyMDMwL1BBL1BBMi8yMzEwL1BBMl8yMzEwLmh0bWw=">AY23/24Semester 1: Stringable<i class="fa fa-external-link-alt"></i></span></h1><p>https://russelldash332.github.io/CS2030/PA/PA2/2310/PA2_2310.html</p><p>同样的，题面很长，可以不细看。</p><h2 id="level-1-1">Level 1</h2><p>Str 类</p><ul><li>of，输入 String，返回 Str</li><li>run，输入 Consumer，返回 void</li><li>print，run的一个封装</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Str</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String str;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Str</span><span class="params">(String s)</span> {</span><br><span class="line">        str = s;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Str <span class="title function_">of</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Str</span>(s);</span><br><span class="line">    }   </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Consumer&lt;String&gt; action)</span> {</span><br><span class="line">        action.accept(<span class="built_in">this</span>.str);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>.run(x -&gt; System.out.println(x));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="level-2-1">Level 2</h2><p>在 Str 里实现 map 和 flatMap</p><p>map：</p><ul><li>输入参数 Funcion&lt;String, String&gt; mapper;</li><li>返回值：Str，Str.of(mapper返回值)</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Str <span class="title function_">map</span><span class="params">(Function&lt;String, String&gt; mapper)</span> {</span><br><span class="line">    <span class="keyword">return</span> Str.of(mapper.apply(<span class="built_in">this</span>.str));</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>flatMap:</p><ul><li>输入参数：Function&lt;String, Str&gt;</li><li>返回值：Str，就是mapper返回值</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Str <span class="title function_">flatMap</span><span class="params">(Function&lt;String, Str&gt; mapper)</span> {</span><br><span class="line">    <span class="keyword">return</span> mapper.apply(<span class="built_in">this</span>.str);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>实现 join</p><ul><li>输入参数：String | Str</li><li>返回值，新的 Str</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Str <span class="title function_">join</span><span class="params">(Str str)</span> {</span><br><span class="line">    <span class="keyword">return</span> str.map(s -&gt; <span class="built_in">this</span>.str + s);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Str <span class="title function_">join</span><span class="params">(String str)</span> {</span><br><span class="line">    <span class="keyword">return</span> Str.of(<span class="built_in">this</span>.str + str);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="level-3-1">Level 3</h2><p>重写一个 of，实现延迟计算。</p><p>输入参数：Supplier</p><p>返回值：Str</p><p>增加一个 Supplier 的成员变量。</p><p>得重新写之前的所有函数，把所有直接计算的地方改成传一个 supplier</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Str</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;String&gt; supplier;</span><br><span class="line"></span><br><span class="line">    Str(Supplier&lt;String&gt; supplier) {</span><br><span class="line">        <span class="built_in">this</span>.supplier = supplier;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Str <span class="title function_">of</span><span class="params">(String str)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Str</span>(() -&gt; str);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Str <span class="title function_">of</span><span class="params">(Supplier&lt;String&gt; supplier)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Str</span>(supplier);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getStr</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Consumer&lt;String&gt; action)</span> {</span><br><span class="line">        action.accept(<span class="built_in">this</span>.getStr());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>.run(x -&gt; System.out.println(x));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Str <span class="title function_">map</span><span class="params">(Function&lt;String, String&gt; mapper)</span> {</span><br><span class="line">        <span class="keyword">return</span> Str.of(() -&gt; mapper.apply(<span class="built_in">this</span>.getStr()));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Str <span class="title function_">flatMap</span><span class="params">(Function&lt;String, Str&gt; mapper)</span> {</span><br><span class="line">        <span class="keyword">return</span> Str.of(() -&gt; mapper.apply(<span class="built_in">this</span>.getStr()).getStr());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Str <span class="title function_">join</span><span class="params">(Str other)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.flatMap(s1 -&gt; other.map(s2 -&gt; s1 + s2));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Str <span class="title function_">join</span><span class="params">(String other)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.map(s -&gt; s + other);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="level-4-1">Level 4</h2><p>重点在看底下的解释，这里让我发现前面的 <code>join</code>实现不太对。</p><p><img src="/CS2030/2024-11-02-%E6%96%B0%E5%8A%A0%E5%9D%A1%E5%9B%BD%E7%AB%8B-CS2030-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20241105215810800.png" alt="image-20241105215810800" style="zoom:50%;"></p><p>第一个 <code>join</code> 调用了 <code>flatMap</code>，<code>flatMap</code> 又调用了 <code>map</code> ，<code>map</code>又调用了 <code>Str.of</code></p><p>所以修改一下这几个函数的实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Str <span class="title function_">map</span><span class="params">(Function&lt;String, String&gt; mapper)</span> {</span><br><span class="line">    <span class="keyword">return</span> Str.of(() -&gt; mapper.apply(<span class="built_in">this</span>.getStr()));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Str <span class="title function_">flatMap</span><span class="params">(Function&lt;String, Str&gt; mapper)</span> {</span><br><span class="line">    <span class="keyword">return</span> Str.of(() -&gt; mapper.apply(<span class="built_in">this</span>.getStr()).getStr());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Str <span class="title function_">join</span><span class="params">(Str other)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.flatMap(s1 -&gt; other.map(s2 -&gt; s1 + s2));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Str <span class="title function_">join</span><span class="params">(String other)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.map(s -&gt; s + other);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>这里其实就是常见的 <code>map</code> <code>flatMap</code>的实现方法，可以记一下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">外部类型 map(Funcion&lt;内部类型, 内部类型&gt; mapper) {</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> 外部类型(mapper.apply(内部数据));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">外部类型 flatMap(Funcion&lt;内部类型, 外部类型&gt; mapper) {</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> 外部类型(mapper.apply(内部数据).get内部数据());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">外部类型 join(外部类型 other) {</span><br><span class="line">    <span class="keyword">return</span> flatMap(a -&gt; other.map(b -&gt; a + b));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">外部类型 join(内部类型 other) {</span><br><span class="line">    <span class="keyword">return</span> map(a -&gt; a + other);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>考试的时候遇到需要写这几个函数的时候，直接用这个模板。</p><p>检验一下上一题中的 <code>flatMap</code>，有泛型看起来很不一样，实际上还是一样的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的内部类型就是 T，外部类型就是 U</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; StateM&lt;U, S&gt; <span class="title function_">flatMap</span><span class="params">(Function&lt;T, StateM&lt;U, S&gt;&gt; mapper)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StateM</span>&lt;U, S&gt; <span class="comment">// 构造新的外部类型</span></span><br><span class="line">        (s -&gt; { <span class="comment">// 因为StateM的构造函数接受的只能是函数，是延迟计算的，所以传进去的是lambda函数</span></span><br><span class="line">        Pair&lt;T, S&gt; pair = <span class="built_in">this</span>.accept(s);   <span class="comment">// 取出 T，就是pair.first()内部数据</span></span><br><span class="line">        StateM&lt;U, S&gt; state = mapper.apply(pair.first()); <span class="comment">// 应用 mapper</span></span><br><span class="line">        Pair&lt;U, S&gt; newPair = state.accept(pair.second()); <span class="comment">// 函数的返回值一定是 Pair&lt;U, S&gt;，打个包</span></span><br><span class="line">        <span class="keyword">return</span> newPair;</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>然后实现一下 trace：</p><p>再注意到一个细节，System.out.println 的输出是夹在 trace输出中间的，所以 trace 中应该是直接输出，而不是先保存再输出。</p><figure><img src="/CS2030/2024-11-02-%E6%96%B0%E5%8A%A0%E5%9D%A1%E5%9B%BD%E7%AB%8B-CS2030-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20241105223035806.png" alt="image-20241105223035806"><figcaption aria-hidden="true">image-20241105223035806</figcaption></figure><p>这题想了很久很久……直到看见 Level 5 的提示，告诉我可以设置 trace的参数，我才知道 supplier的类型原来是允许修改的……心好累，不想写解释了，代码应该能看懂的……</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Str</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Function&lt;Boolean, String&gt; supplier;</span><br><span class="line"></span><br><span class="line">    Str(Function&lt;Boolean, String&gt; supplier) {</span><br><span class="line">        <span class="built_in">this</span>.supplier = supplier;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Str <span class="title function_">of</span><span class="params">(String str)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Str</span>(tracer -&gt; {</span><br><span class="line">            <span class="keyword">if</span> (tracer) {</span><br><span class="line">                System.out.println(<span class="string">"traced Str: "</span> + str);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Str <span class="title function_">of</span><span class="params">(Supplier&lt;String&gt; supplier)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Str</span>(tracer -&gt; {</span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> supplier.get();</span><br><span class="line">            <span class="keyword">if</span> (tracer) {</span><br><span class="line">                System.out.println(<span class="string">"traced Str: "</span> + result);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getStr</span><span class="params">(<span class="type">boolean</span> tracer)</span> {</span><br><span class="line">        <span class="keyword">return</span> supplier.apply(tracer);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Consumer&lt;String&gt; action)</span> {</span><br><span class="line">        action.accept(<span class="built_in">this</span>.getStr(<span class="literal">false</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>.run(x -&gt; System.out.println(x));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Str <span class="title function_">map</span><span class="params">(Function&lt;String, String&gt; mapper)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Str</span>(tracer -&gt; {</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="built_in">this</span>.getStr(tracer);</span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> mapper.apply(str);</span><br><span class="line">            <span class="keyword">if</span> (tracer) {</span><br><span class="line">                System.out.println(<span class="string">"traced map: "</span> + result);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Str <span class="title function_">flatMap</span><span class="params">(Function&lt;String, Str&gt; mapper)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Str</span>(tracer -&gt; {</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="built_in">this</span>.getStr(tracer);</span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> mapper.apply(str).getStr(tracer);</span><br><span class="line">            <span class="keyword">if</span> (tracer) {</span><br><span class="line">                System.out.println(<span class="string">"traced flatMap: "</span> + result);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Str <span class="title function_">join</span><span class="params">(Str other)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.flatMap(s1 -&gt; other.map(s2 -&gt; s1 + s2));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Str <span class="title function_">join</span><span class="params">(String other)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.map(s -&gt; s + other);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trace</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.getStr(<span class="literal">true</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="level-5-1">Level 5</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Str</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Function&lt;Consumer&lt;String&gt;, String&gt; supplier;</span><br><span class="line"></span><br><span class="line">    Str(Function&lt;Consumer&lt;String&gt;, String&gt; supplier) {</span><br><span class="line">        <span class="built_in">this</span>.supplier = supplier;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Str <span class="title function_">of</span><span class="params">(String str)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Str</span>(tracer -&gt; {</span><br><span class="line">            <span class="keyword">if</span> (tracer != <span class="literal">null</span>) {</span><br><span class="line">                tracer.accept(<span class="string">"traced Str: "</span> + str);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Str <span class="title function_">of</span><span class="params">(Supplier&lt;String&gt; supplier)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Str</span>(tracer -&gt; {</span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> supplier.get();</span><br><span class="line">            <span class="keyword">if</span> (tracer != <span class="literal">null</span>) {</span><br><span class="line">                tracer.accept(<span class="string">"traced Str: "</span> + result);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getStr</span><span class="params">(Consumer&lt;String&gt; tracer)</span> {</span><br><span class="line">        <span class="keyword">return</span> supplier.apply(tracer);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getStr</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> getStr(<span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Consumer&lt;String&gt; action)</span> {</span><br><span class="line">        action.accept(<span class="built_in">this</span>.getStr());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>.run(x -&gt; System.out.println(x));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Str <span class="title function_">map</span><span class="params">(Function&lt;String, String&gt; mapper)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Str</span>(tracer -&gt; {</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="built_in">this</span>.getStr(tracer);</span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> mapper.apply(str);</span><br><span class="line">            <span class="keyword">if</span> (tracer != <span class="literal">null</span>) {</span><br><span class="line">                tracer.accept(<span class="string">"traced map: "</span> + result);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Str <span class="title function_">flatMap</span><span class="params">(Function&lt;String, Str&gt; mapper)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Str</span>(tracer -&gt; {</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="built_in">this</span>.getStr(tracer);</span><br><span class="line">            <span class="type">Str</span> <span class="variable">mappedStr</span> <span class="operator">=</span> mapper.apply(str);</span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> mappedStr.getStr(tracer);</span><br><span class="line">            <span class="keyword">if</span> (tracer != <span class="literal">null</span>) {</span><br><span class="line">                tracer.accept(<span class="string">"traced flatMap: "</span> + result);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Str <span class="title function_">join</span><span class="params">(Str other)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.flatMap(s1 -&gt; other.map(s2 -&gt; s1 + <span class="string">" "</span> + s2));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Str <span class="title function_">join</span><span class="params">(String other)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.map(s -&gt; s + other);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trace</span><span class="params">(Consumer&lt;String&gt; tracer)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.getStr(tracer);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trace</span><span class="params">()</span> {</span><br><span class="line">        trace(x -&gt; System.out.println(x));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h1 id="附录">附录</h1><h2 id="extends-与-implements">extends 与 implements</h2><ul><li><code>extends</code> 继承，父类和子类，抽象类也是类，用继承</li><li><code>implements</code> 实现，接口和类，接口用实现</li></ul><h2 id="成员函数泛型">成员函数泛型</h2><p>成员函数的声明格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[访问修饰符] [其他修饰符] [泛型参数] 返回类型 方法名(参数类型 参数名, ...) [<span class="keyword">throws</span> 异常类型] {</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><ul><li><strong>访问修饰符</strong>：public、private、protected</li><li><strong>其他修饰符</strong>：<ul><li>static（静态方法）</li><li>final（最终方法，不能被子类重写）</li><li>abstract（抽象方法，没有方法体）</li></ul></li><li><strong>泛型参数</strong>：用于声明方法独有的泛型参数（如果方法需要自己的泛型）。通常写在返回类型之前，例如<code>&lt;T&gt;</code>, <code>&lt;K, V&gt;</code> 等。</li></ul><p>静态方法，被静态调用的时候不能使用这个类的泛型！！必须要自己定义泛型参数。</p><blockquote><p>静态调用：直接使用 类名.方法名 ，而不是先创建对象。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;CS2030 PA2 知识点整理&lt;/li&gt;
&lt;li&gt;Stringable 和 StateM 详细解析&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://cishoon.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="http://cishoon.top/tags/Java/"/>
    
    <category term="CS2030" scheme="http://cishoon.top/tags/CS2030/"/>
    
  </entry>
  
  <entry>
    <title>毕设06 - 在 TEE 中运行 WASM</title>
    <link href="http://cishoon.top/graduation-project/06/"/>
    <id>http://cishoon.top/graduation-project/06/</id>
    <published>2024-10-29T16:00:00.000Z</published>
    <updated>2024-10-31T07:04:06.432Z</updated>
    
    <content type="html"><![CDATA[<p>截止目前已经编译成功了 WATZ。接下来尝试如何使用 WATZ 运行一个 WASM程序。</p><p>本文是 debug 的记录，大多数内容都是废话2333，只看总结就好。</p><span id="more"></span><h2 id="解析参数">1 解析参数</h2><p><code>optee_wamr</code> 参数：</p><ul><li><code>heap_size</code> ：堆大小</li><li><code>wasm_path</code> ：wasm 文件路径（仅支持 aot 文件）</li><li><code>[wasm_args]</code> ：wasm 的运行参数，不定长。</li></ul><p>示例，在 Normal World 中运行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">optee_wamr 4092 hello.aot</span><br></pre></td></tr></table></figure><h2 id="分配缓存空间">2 分配缓存空间</h2><p>在其他的 TA 中，tee_ctx 的结构如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tee_ctx</span> {</span></span><br><span class="line">TEEC_Context ctx;</span><br><span class="line">TEEC_Session sess;</span><br><span class="line">};</span><br></pre></td></tr></table></figure><p>WATZ 中，tee_ctx 的结构扩展为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tee_ctx</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">TEEC_Context ctx;</span><br><span class="line">TEEC_Session sess;</span><br><span class="line"><span class="type">uint8_t</span> *output_buffer;</span><br><span class="line"><span class="type">uint64_t</span> output_buffer_size;</span><br><span class="line"><span class="type">uint8_t</span> *benchmark_buffer;</span><br><span class="line"><span class="type">uint64_t</span> benchmark_buffer_size;</span><br><span class="line">} tee_ctx;</span><br></pre></td></tr></table></figure><p>增加了 <code>output_buffer</code> 和 <code>benchmark_buffer</code>，后者应该是论文中的测试用的，之后可以删除。</p><p>main 函数中执行了：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tee_ctx ctx;</span><br><span class="line">allocate_buffers(&amp;ctx, <span class="number">5</span> * <span class="number">1024</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">allocate_buffers</span><span class="params">(tee_ctx *ctx, <span class="type">uint64_t</span> buffers_size)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// The output buffer is used to capture writes to stdout from the WASM</span></span><br><span class="line">ctx-&gt;output_buffer = <span class="built_in">malloc</span>(buffers_size);</span><br><span class="line">ctx-&gt;output_buffer_size = buffers_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The benchmark buffer is used to capture benchmark information from the TA</span></span><br><span class="line">ctx-&gt;benchmark_buffer = <span class="built_in">malloc</span>(buffers_size);</span><br><span class="line">ctx-&gt;benchmark_buffer_size = buffers_size;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>分配了一个 5K 字节的空间用于捕获 WASM 对 stdout 的写入。</p><h2 id="初始化上下文并打开对话">3 初始化上下文并打开对话</h2><p>这一步就是标准的 TEE 启动流程。</p><h2 id="配置堆空间">4 配置堆空间</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">configure_heap_size(&amp;ctx, heap_size);</span><br></pre></td></tr></table></figure><p>这一步调用了一个 TA Command：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(&amp;op, <span class="number">0</span>, <span class="keyword">sizeof</span>(op));</span><br><span class="line">op.paramTypes = TEEC_PARAM_TYPES(TEEC_VALUE_INPUT, TEEC_NONE, TEEC_NONE, TEEC_NONE);</span><br><span class="line">op.params[<span class="number">0</span>].value.a = size;</span><br><span class="line"></span><br><span class="line">res = TEEC_InvokeCommand(&amp;ctx-&gt;sess, COMMAND_CONFIGURE_HEAP, &amp;op, &amp;origin);</span><br></pre></td></tr></table></figure><p>传递一个参数 <code>size</code> （即为输入的 <code>heap_size</code>）</p><p>执行 TA 的函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TA_SetHeapSize(params[<span class="number">0</span>].value.a); <span class="comment">// params[0].value.a = size</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> heap_size;</span><br><span class="line"><span class="type">static</span> TEE_Result <span class="title function_">TA_SetHeapSize</span><span class="params">(<span class="type">uint32_t</span> size)</span></span><br><span class="line">{</span><br><span class="line">    heap_size = size;</span><br><span class="line">    DMSG(<span class="string">"The heap set is set to %u"</span>, heap_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TEE_SUCCESS;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>这里的 <code>heap_size</code> 是一个静态全局变量。</p><h2 id="启动-wasm">5 启动 wasm</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">success = start_wasm(&amp;ctx, wasm_path, arg);</span><br></pre></td></tr></table></figure><p>输入 <code>wasm_path</code> 和启动参数。以下代码都是<code>start_wasm</code> 内部的片段：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> wasm_file_length;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *wasm_bytecode;</span><br><span class="line"></span><br><span class="line">wasm_file = fopen(wasm_path, <span class="string">"rb"</span>);</span><br><span class="line"><span class="keyword">if</span> (wasm_file == <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: the file %s cannot be opened.\n"</span>, wasm_path);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// Jump to the end of the file</span></span><br><span class="line">fseek(wasm_file, <span class="number">0</span>, SEEK_END);</span><br><span class="line"><span class="comment">// Get the current byte offset in the file</span></span><br><span class="line">wasm_file_length = ftell(wasm_file);</span><br><span class="line"><span class="comment">// Allocate the buffer for the bytecode with the size of the file</span></span><br><span class="line">wasm_bytecode = <span class="built_in">malloc</span>(ftell(wasm_file) * <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>));</span><br><span class="line"><span class="comment">// Jump back to the beginning of the file</span></span><br><span class="line">rewind(wasm_file);</span><br><span class="line"><span class="comment">// Dump the bytecode into the buffer</span></span><br><span class="line">fread(wasm_bytecode, wasm_file_length, <span class="number">1</span>, wasm_file);</span><br><span class="line"><span class="comment">// Close the file</span></span><br><span class="line">fclose(wasm_file);</span><br></pre></td></tr></table></figure><p>得到 wasm 文件的字节码和文件长度。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(&amp;op, <span class="number">0</span>, <span class="keyword">sizeof</span>(op));</span><br><span class="line">op.paramTypes = TEEC_PARAM_TYPES(TEEC_MEMREF_TEMP_INPUT,</span><br><span class="line"> TEEC_MEMREF_TEMP_INPUT, </span><br><span class="line">                                    TEEC_MEMREF_TEMP_INOUT, </span><br><span class="line">                                    TEEC_MEMREF_TEMP_INOUT);</span><br><span class="line">op.params[<span class="number">0</span>].tmpref.buffer = wasm_bytecode;</span><br><span class="line">op.params[<span class="number">0</span>].tmpref.size = wasm_file_length;</span><br><span class="line">op.params[<span class="number">1</span>].tmpref.buffer = arg;</span><br><span class="line">op.params[<span class="number">1</span>].tmpref.size = arg != <span class="literal">NULL</span> ? <span class="built_in">strlen</span>(arg) : <span class="number">0</span>;</span><br><span class="line">op.params[<span class="number">2</span>].tmpref.buffer = ctx-&gt;output_buffer;</span><br><span class="line">op.params[<span class="number">2</span>].tmpref.size = ctx-&gt;output_buffer_size;</span><br><span class="line">op.params[<span class="number">3</span>].tmpref.buffer = ctx-&gt;benchmark_buffer;</span><br><span class="line">op.params[<span class="number">3</span>].tmpref.size = ctx-&gt;benchmark_buffer_size;</span><br><span class="line"></span><br><span class="line">res = TEEC_InvokeCommand(&amp;ctx-&gt;sess, COMMAND_RUN_WASM, &amp;op, &amp;origin);</span><br></pre></td></tr></table></figure><p>执行 <code>COMMAND_RUN_WASM</code> ，参数：</p><ul><li>wasm 字节码</li><li>参数</li><li>输出缓冲区</li><li>benchmark 缓冲区</li></ul><p>随后执行 TA 的函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TA_RunWasm((<span class="type">unsigned</span> <span class="type">char</span> *)params[<span class="number">0</span>].memref.buffer, <span class="comment">// wasm_bytecode</span></span><br><span class="line">                          params[<span class="number">0</span>].memref.size,<span class="comment">// wasm_file_length</span></span><br><span class="line">                          (<span class="type">char</span> *)params[<span class="number">1</span>].memref.buffer, <span class="comment">// args</span></span><br><span class="line">                          params[<span class="number">2</span>].memref.buffer, <span class="comment">// output_buffer</span></span><br><span class="line">                          params[<span class="number">2</span>].memref.size,</span><br><span class="line">                          params[<span class="number">3</span>].memref.buffer, <span class="comment">// benchmark_buffer</span></span><br><span class="line">                          params[<span class="number">3</span>].memref.size);</span><br></pre></td></tr></table></figure><p>以下的代码都是 <code>TA_RunWasm</code> 内部的片段：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate secure memory locations</span></span><br><span class="line"><span class="type">uint8_t</span> *global_heap_buf = TEE_Malloc(heap_size, TEE_USER_MEM_HINT_NO_FILL_ZERO);</span><br><span class="line"><span class="type">uint8_t</span> *trusted_wasm_bytecode = TEE_Malloc(wasm_bytecode_size, </span><br><span class="line">                                            TEE_USER_MEM_HINT_NO_FILL_ZERO);</span><br><span class="line"><span class="comment">// Copy the shared memory that contains the WASM bytecode into the secure memory</span></span><br><span class="line">TEE_MemMove(trusted_wasm_bytecode, wasm_bytecode, wasm_bytecode_size);</span><br></pre></td></tr></table></figure><p>分配一个全局堆缓冲区和可信 wasm 字节码的空间。并将 wasm字节码的内容移动过来。</p><p>这部分的空间都是 TEE_Malloc 分配的。</p><blockquote><p>在 OP-TEE 中，<code>TEE_Malloc</code>是用于内存分配的一个函数。它的主要作用是为 TrustZone 中的 TrustedApplication (TA) 分配内存空间。<code>TEE_Malloc</code> 的用法和标准 C语言中的 <code>malloc</code>类似，但在安全性和内存管理方面有特殊的优化，以适应可信执行环境（TEE）的需求。以下是一些具体细节：</p><p><strong>基本用法</strong></p><ul><li><strong>函数签名</strong>：<code>void* TEE_Malloc(size_t size, uint32_t hint);</code><ul><li><code>size</code>: 需要分配的字节数。</li><li><code>hint</code>:内存分配的提示选项，可帮助优化内存分配策略。例如：<ul><li><code>TEE_MALLOC_FILL_ZERO</code>：表示在分配内存时将其初始化为零。</li><li><code>TEE_USER_MEM_HINT_NO_FILL</code>：表示无需填充，通常是为了加速内存分配。</li></ul></li></ul></li><li><strong>返回值</strong>：返回分配的内存块的指针，如果分配失败则返回NULL。</li></ul><p><strong>内存管理的特点</strong></p><ol type="1"><li><strong>隔离性</strong>：<code>TEE_Malloc</code> 所分配的内存位于 TA的隔离区域内，不可被普通世界访问。这保证了内存的安全性，使得 TA可以安全地存储敏感信息。</li><li><strong>自动释放</strong>：在 TA 退出时，OP-TEE 会自动释放由<code>TEE_Malloc</code>分配的所有内存。开发者可以省去手动释放的步骤，但也可以在不需要时主动调用<code>TEE_Free</code> 来释放。</li><li><strong>性能优化</strong>：OP-TEE使用专用的内存管理器来优化分配和释放性能，特别是在对小块内存频繁操作的场景下。</li></ol></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set the output buffer to gather the stdout once the application ended</span></span><br><span class="line">TA_SetOutputBuffer(output_buffer, output_buffer_size);</span><br></pre></td></tr></table></figure><p>设置输出缓冲区，以便在应用程序结束时收集 stdout 。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// General settings for the runtime</span></span><br><span class="line">TEE_Result result;</span><br><span class="line">wamr_context context =</span><br><span class="line">    {</span><br><span class="line">        .heap_buf = global_heap_buf,</span><br><span class="line">        .heap_size = heap_size,</span><br><span class="line">        <span class="comment">// .native_symbols = wasi_ra_native_symbols,</span></span><br><span class="line">        <span class="comment">// .native_symbols_size = wasi_ra_native_symbols_size,</span></span><br><span class="line">        .wasm_bytecode = trusted_wasm_bytecode,</span><br><span class="line">        .wasm_bytecode_size = wasm_bytecode_size};</span><br></pre></td></tr></table></figure><p>一些配置，注释掉的是远程验证的部分。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hash the WASM bytecode for future RA quotes</span></span><br><span class="line">result = TA_HashWasmBytecode(&amp;context);</span><br></pre></td></tr></table></figure><p>生成 WASM 字节码的哈希值，应该也是远程验证的一部分。TEE中的这部分输出就是该函数的运行结果。</p><figure><img src="/graduation-project/06/image-20241029214618345.png" alt="image-20241029214618345"><figcaption aria-hidden="true">image-20241029214618345</figcaption></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DMSG(<span class="string">"TA_InitializeWamrRuntime\n"</span>);</span><br><span class="line"><span class="type">int</span> argc = arg_buff != <span class="literal">NULL</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> *argv[] = {(<span class="type">char</span> *)<span class="string">""</span>, arg_buff};</span><br><span class="line">result = TA_InitializeWamrRuntime(&amp;context, argc, argv);</span><br><span class="line"><span class="keyword">if</span> (result != TEE_SUCCESS)</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br></pre></td></tr></table></figure><p>初始化 Wamr 运行时。代码就是运行到 Initialize 报错的。</p><figure><img src="/graduation-project/06/image-20241029221321275.png" alt="image-20241029221321275"><figcaption aria-hidden="true">image-20241029221321275</figcaption></figure><p>下面详细看 TA_InitializeWamrRuntime 干了什么。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">RuntimeInitArgs init_args;</span><br><span class="line">TEE_MemFill(&amp;init_args, <span class="number">0</span>, <span class="keyword">sizeof</span>(RuntimeInitArgs));</span><br><span class="line"></span><br><span class="line">init_args.mem_alloc_type = Alloc_With_Pool;</span><br><span class="line">init_args.mem_alloc_option.pool.heap_buf = context-&gt;heap_buf;</span><br><span class="line">init_args.mem_alloc_option.pool.heap_size = context-&gt;heap_size;</span><br></pre></td></tr></table></figure><p>运行时初始化参数，内存分配类型为 <code>Alloc_With_Pool</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 内存分配类型 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> {</span></span><br><span class="line">    Alloc_With_Pool = <span class="number">0</span>,</span><br><span class="line">    Alloc_With_Allocator,</span><br><span class="line">    Alloc_With_System_Allocator,</span><br><span class="line">} <span class="type">mem_alloc_type_t</span>;</span><br></pre></td></tr></table></figure><ol type="1"><li><p><code>Alloc_With_Pool</code></p><p>这是池模式（poolmode），即从用户定义的堆缓冲区中分配内存。这种方式通常适用于应用有固定内存池的情况，有利于控制内存的总占用量并提高内存管理的效率。</p></li><li><p><code>Alloc_With_Allocator</code></p><p>用户分配器模式（user allocator mode），即从用户定义的<code>malloc</code>函数中分配内存。用户可以通过提供自定义的分配器函数来控制内存的分配方式，这样可以实现更灵活的内存管理。</p></li><li><p><code>Alloc_With_System_Allocator</code></p><p>系统分配器模式（system allocator mode），即使用系统分配器或平台的<code>os_malloc</code>函数进行内存分配。这是使用操作系统的默认内存分配器，通常是最简单的选择，但可能不如自定义的分配器那样高效。</p></li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!wasm_runtime_full_init(&amp;init_args))</span><br><span class="line">{</span><br><span class="line">    EMSG(<span class="string">"Init runtime environment failed.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> TEE_ERROR_GENERIC;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the WASM runtime environment, and also initialize</span></span><br><span class="line"><span class="comment"> * the memory allocator and register native symbols, which are specified</span></span><br><span class="line"><span class="comment"> * with init arguments</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param init_args specifies the init arguments</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return return true if success, false otherwise</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">WASM_RUNTIME_API_EXTERN <span class="type">bool</span></span><br><span class="line"><span class="title function_">wasm_runtime_full_init</span><span class="params">(RuntimeInitArgs *init_args)</span>;</span><br></pre></td></tr></table></figure><p>这个函数的主要作用是初始化 WASM运行时环境。它还会初始化内存分配器，并注册一些本地符号，这些符号是通过初始化参数<code>init_args</code> 指定的。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> error_buf[<span class="number">128</span>];</span><br><span class="line">context-&gt;module = wasm_runtime_load(context-&gt;wasm_bytecode, context-&gt;wasm_bytecode_size, error_buf, <span class="keyword">sizeof</span>(error_buf));</span><br><span class="line"><span class="keyword">if</span> (!context-&gt;module)</span><br><span class="line">{</span><br><span class="line">    EMSG(<span class="string">"Load wasm module failed. error: %s\n"</span>, error_buf); </span><br><span class="line">    <span class="keyword">return</span> TEE_ERROR_GENERIC;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>载入 wasm 字节码，返回一个 <code>WASMModuleCommon*</code> 指针</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">WASMModuleCommon</span> {</span></span><br><span class="line">    <span class="comment">/* Module type, for module loaded from WASM bytecode binary,</span></span><br><span class="line"><span class="comment">       this field is Wasm_Module_Bytecode, and this structure should</span></span><br><span class="line"><span class="comment">       be treated as WASMModule structure;</span></span><br><span class="line"><span class="comment">       for module loaded from AOT binary, this field is</span></span><br><span class="line"><span class="comment">       Wasm_Module_AoT, and this structure should be treated as</span></span><br><span class="line"><span class="comment">       AOTModule structure. */</span></span><br><span class="line">    uint32 module_type;</span><br><span class="line">    uint8 module_data[<span class="number">1</span>];</span><br><span class="line">} WASMModuleCommon;</span><br></pre></td></tr></table></figure><p>定义了 <code>WASMModuleCommon</code> 结构体，用于表示一个通用的 WASM模块。该结构体包含两个字段：</p><ul><li><code>module_type</code>：表示模块类型。对于从 WASM字节码加载的模块，该字段为 <code>Wasm_Module_Bytecode</code>；而对于从AOT（Ahead Of Time）二进制加载的模块，则为<code>Wasm_Module_AoT</code>。</li><li><code>module_data[1]</code>：表示模块的数据，这个字段大小为 1字节，但在实际使用中可能作为指针或动态数组使用。</li></ul><p>下面看 <code>wasm_runtime_load</code> 的内容：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">module_common = (WASMModuleCommon*)</span><br><span class="line">       aot_load_from_aot_file(buf, size, error_buf, error_buf_size);</span><br><span class="line"><span class="keyword">return</span> register_module_with_null_name(module_common,</span><br><span class="line">                                      error_buf, error_buf_size);</span><br></pre></td></tr></table></figure><p>调用 <code>aot_load_from_aot_file</code> 载入 <code>aot</code>文件。下面的代码<strong>有所简化</strong>，删除了部分错误检查，分析见注释：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AOTModule</span> {</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 内容非常多，总而言之就是解析之后的AOT文件，内部结构的反序列化</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">AOTModule* <span class="title function_">aot_load_from_aot_file</span><span class="params">(<span class="type">const</span> uint8 *buf, uint32 size,</span></span><br><span class="line"><span class="params">                       <span class="type">char</span> *error_buf, uint32 error_buf_size)</span></span><br><span class="line">{</span><br><span class="line">    AOTModule *module = create_module(error_buf, error_buf_size); <span class="comment">// 创建一个AOT module</span></span><br><span class="line">    load_from_sections(module, section_list,error_buf, error_buf_size));</span><br><span class="line">    LOG_VERBOSE(<span class="string">"Load module success.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> module;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> AOTModule* <span class="title function_">create_module</span><span class="params">(<span class="type">char</span> *error_buf, uint32 error_buf_size)</span></span><br><span class="line">{</span><br><span class="line">    AOTModule *module =</span><br><span class="line">        loader_malloc(<span class="keyword">sizeof</span>(AOTModule), error_buf, error_buf_size); <span class="comment">// 分配内存空间</span></span><br><span class="line">    module-&gt;module_type = Wasm_Module_AoT; <span class="comment">// 指定类型</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给module中的字符串常量分配空间，结构是一个哈希表。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    module-&gt;const_str_set = bh_hash_map_create(<span class="number">32</span>, <span class="literal">false</span>, ...)))</span><br><span class="line">    <span class="keyword">return</span> module;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个哈希映射。C语言的哈希表实现。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param size: 哈希映射的初始大小</span></span><br><span class="line"><span class="comment"> * @param use_lock: 是否在操作哈希映射时加锁</span></span><br><span class="line"><span class="comment"> * @param hash_func: 键的哈希函数，必须指定</span></span><br><span class="line"><span class="comment"> * @param key_equal_func: 键相等判断函数，用于检查两个键是否相等，必须指定</span></span><br><span class="line"><span class="comment"> * @param key_destroy_func: 键销毁函数，当哈希元素被移除时调用，如果为 NULL 则不调用</span></span><br><span class="line"><span class="comment"> * @param value_destroy_func: 值销毁函数，当哈希元素被移除时调用，如果为 NULL 则不调用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 创建的哈希映射，如果失败则返回 NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">HashMap* <span class="title function_">bh_hash_map_create</span><span class="params">(uint32 size, <span class="type">bool</span> use_lock,</span></span><br><span class="line"><span class="params">                           HashFunc hash_func,</span></span><br><span class="line"><span class="params">                           KeyEqualFunc key_equal_func,</span></span><br><span class="line"><span class="params">                           KeyDestroyFunc key_destroy_func,</span></span><br><span class="line"><span class="params">                           ValueDestroyFunc value_destroy_func)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span></span><br><span class="line"><span class="title function_">load</span><span class="params">(<span class="type">const</span> uint8 *buf, uint32 size, AOTModule *module,</span></span><br><span class="line"><span class="params">     <span class="type">char</span> *error_buf, uint32 error_buf_size)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">const</span> uint8 *buf_end = buf + size;</span><br><span class="line">    <span class="type">const</span> uint8 *p = buf, *p_end = buf_end;</span><br><span class="line">    uint32 magic_number, version;</span><br><span class="line">    AOTSection *section_list = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">bool</span> ret;</span><br><span class="line"></span><br><span class="line">    read_uint32(p, p_end, magic_number); <span class="comment">// 读入 magic number</span></span><br><span class="line">    <span class="keyword">if</span> (magic_number != AOT_MAGIC_NUMBER) {</span><br><span class="line">        set_error_buf(error_buf, error_buf_size, <span class="string">"magic header not detected"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    read_uint32(p, p_end, version); <span class="comment">// 读入 version</span></span><br><span class="line">    <span class="keyword">if</span> (version != AOT_CURRENT_VERSION) {</span><br><span class="line">        set_error_buf(error_buf, error_buf_size, <span class="string">"unknown binary version"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    create_sections实现了从给定的缓冲区 buf 中解析 AOT（Ahead of Time）二进制文件</span></span><br><span class="line"><span class="comment">    的各个部分（sections），并将其存储到一个链表中</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (!create_sections(buf, size, &amp;section_list, error_buf, error_buf_size))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    load_from_sections负责加载 AOT 模块中的各个部分（sections），</span></span><br><span class="line"><span class="comment">    并在模块中解析并初始化特定的函数，如 malloc、free 和 retain 等。</span></span><br><span class="line"><span class="comment">    成功完成则返回 true，否则返回 false</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ret = load_from_sections(module, section_list, error_buf, error_buf_size);</span><br><span class="line">    <span class="keyword">if</span> (!ret) {</span><br><span class="line">        <span class="comment">/* If load_from_sections() fails, then aot text is destroyed</span></span><br><span class="line"><span class="comment">           in destroy_sections() */</span></span><br><span class="line">        destroy_sections(section_list, <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">/* aot_unload() won't destroy aot text again */</span></span><br><span class="line">        module-&gt;code = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">/* If load_from_sections() succeeds, then aot text is set to</span></span><br><span class="line"><span class="comment">           module-&gt;code and will be destroyed in aot_unload() */</span></span><br><span class="line">        destroy_sections(section_list, <span class="literal">false</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">fail:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>根据报错信息，可以定位到这行代码发生了错误：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">create_sections(buf, size, &amp;section_list, error_buf, error_buf_size)</span><br><span class="line">  </span><br><span class="line">    total_size = (uint64)section_size + aot_get_plt_table_size();</span><br><span class="line">    total_size = (total_size + <span class="number">3</span>) &amp; ~((uint64)<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (total_size &gt;= UINT32_MAX</span><br><span class="line">        || !(aot_text = os_mmap(<span class="literal">NULL</span>, (uint32)total_size,</span><br><span class="line">                                map_prot, map_flags))) {</span><br><span class="line">        wasm_runtime_free(section);</span><br><span class="line">        set_error_buf(error_buf, error_buf_size,</span><br><span class="line">                      <span class="string">"mmap memory failed"</span>);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    }</span><br></pre></td></tr></table></figure><p>有可能是 <code>total_size &gt;= UNIT32_MAX</code>，也可能是<code>os_mmap</code> 发生错误。</p><p>输出一下 <code>total_size: 7700</code> ，所以是 <code>os_mmap</code>的问题。</p><p>最终定位到 <code>os_mprotect</code> 中执行的<code>tee_mprotect</code> 发生了问题。</p><p>这个好像是，移植 <code>optee_os</code> 时候做的东西……</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TEE_Result <span class="title function_">tee_mprotect</span><span class="params">(<span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">uint32_t</span> prot)</span></span><br><span class="line">{</span><br><span class="line">TEE_Result res = TEE_SUCCESS;</span><br><span class="line"><span class="type">uint32_t</span> param_types = TEE_PARAM_TYPES(TEE_PARAM_TYPE_VALUE_INPUT,</span><br><span class="line">       TEE_PARAM_TYPE_VALUE_INPUT,</span><br><span class="line">       TEE_PARAM_TYPE_NONE,</span><br><span class="line">       TEE_PARAM_TYPE_NONE);</span><br><span class="line">TEE_Param params[TEE_NUM_PARAMS] = { };</span><br><span class="line"></span><br><span class="line">params[<span class="number">0</span>].value.a = len;</span><br><span class="line">params[<span class="number">0</span>].value.b = prot;</span><br><span class="line">reg_pair_from_64((<span class="type">vaddr_t</span>)buf, &amp;params[<span class="number">1</span>].value.a, &amp;params[<span class="number">1</span>].value.b);</span><br><span class="line"></span><br><span class="line">res = invoke_system_pta(PTA_SYSTEM_MPROTECT, param_types, params);</span><br><span class="line"><span class="keyword">if</span> (res)</span><br><span class="line">EMSG(<span class="string">"Invoke PTA_SYSTEM_MPROTECT: buf %p, len %#zx, prot %u"</span>, buf, len, prot);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTA_SYSTEM_MPROTECT20</span></span><br></pre></td></tr></table></figure><p>但是我 PTA_SYSTEM_MPROTECT好像没有被任何地方使用过，应该是有一个系统调用函数表的，找一找别的<code>PTA_SYSTEM</code> 宏定义在哪里被使用。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> TEE_Result <span class="title function_">invoke_system_pta</span><span class="params">(<span class="type">uint32_t</span> cmd_id, <span class="type">uint32_t</span> param_types,</span></span><br><span class="line"><span class="params">    TEE_Param params[TEE_NUM_PARAMS])</span></span><br><span class="line">{</span><br><span class="line"><span class="type">static</span> TEE_TASessionHandle sess = TEE_HANDLE_NULL;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TEE_UUID uuid = PTA_SYSTEM_UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sess == TEE_HANDLE_NULL) {</span><br><span class="line">TEE_Result res = TEE_OpenTASession(&amp;uuid, TEE_TIMEOUT_INFINITE,</span><br><span class="line">   <span class="number">0</span>, <span class="literal">NULL</span>, &amp;sess, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (res)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TEE_InvokeTACommand(sess, TEE_TIMEOUT_INFINITE, cmd_id,</span><br><span class="line">   param_types, params, <span class="literal">NULL</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TEE_Result <span class="title function_">TEE_InvokeTACommand</span><span class="params">(TEE_TASessionHandle session,</span></span><br><span class="line"><span class="params"><span class="type">uint32_t</span> cancellationRequestTimeout,</span></span><br><span class="line"><span class="params"><span class="type">uint32_t</span> commandID, <span class="type">uint32_t</span> paramTypes,</span></span><br><span class="line"><span class="params">TEE_Param params[TEE_NUM_PARAMS],</span></span><br><span class="line"><span class="params"><span class="type">uint32_t</span> *returnOrigin)</span></span><br><span class="line">{</span><br><span class="line">TEE_Result res = TEE_SUCCESS;</span><br><span class="line"><span class="type">uint32_t</span> ret_origin = TEE_ORIGIN_TEE;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utee_params</span> <span class="title">up</span> =</span> { };</span><br><span class="line"><span class="type">void</span> *tmp_buf = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">size_t</span> tmp_len = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> *tmp_va[TEE_NUM_PARAMS] = { <span class="literal">NULL</span> };</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (paramTypes) {</span><br><span class="line">__utee_check_inout_annotation(params,</span><br><span class="line">      <span class="keyword">sizeof</span>(TEE_Param) *</span><br><span class="line">      TEE_NUM_PARAMS);</span><br><span class="line">check_invoke_param(paramTypes, params);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (returnOrigin)</span><br><span class="line">__utee_check_out_annotation(returnOrigin,</span><br><span class="line">    <span class="keyword">sizeof</span>(*returnOrigin));</span><br><span class="line"></span><br><span class="line">copy_param(&amp;up, paramTypes, params);</span><br><span class="line">res = map_tmp_param(&amp;up, &amp;tmp_buf, &amp;tmp_len, tmp_va);</span><br><span class="line"><span class="keyword">if</span> (res)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">res = _utee_invoke_ta_command((<span class="type">uintptr_t</span>)session,</span><br><span class="line">      cancellationRequestTimeout,</span><br><span class="line">      commandID, &amp;up, &amp;ret_origin);</span><br><span class="line">update_out_param(params, tmp_va, &amp;up);</span><br><span class="line"><span class="keyword">if</span> (tmp_buf) {</span><br><span class="line">TEE_Result res2 = tee_unmap(tmp_buf, tmp_len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (res2)</span><br><span class="line">TEE_Panic(res2);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="keyword">if</span> (returnOrigin != <span class="literal">NULL</span>)</span><br><span class="line">*returnOrigin = ret_origin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret_origin == TEE_ORIGIN_TRUSTED_APP)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (res != TEE_SUCCESS &amp;&amp;</span><br><span class="line">    res != TEE_ERROR_OUT_OF_MEMORY &amp;&amp;</span><br><span class="line">    res != TEE_ERROR_TARGET_DEAD)</span><br><span class="line">TEE_Panic(res);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>现在把系统调用添加进去了，重新试一次……修改的地方已经更新进了 毕设05。</p><p>OK！现在是下一个错了！</p><figure><img src="/graduation-project/06/image-20241030152722875.png" alt="image-20241030152722875"><figcaption aria-hidden="true">image-20241030152722875</figcaption></figure><p><code>wasm_runtime_load</code> → <code>aot_load_from_aot_file</code>→ <code>load</code> → <code>load_from_sections</code> →<code>load_target_info_section</code></p><p><code>load_from_sections</code> 函数的参数：<code>section_list</code>是由 <code>create_sections</code>生成的，所以还是得把这两个函数的具体实现看一下。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">read_uint16(p, p_end, target_info.bin_type);</span><br><span class="line">read_uint16(p, p_end, target_info.abi_type);</span><br><span class="line">read_uint16(p, p_end, target_info.e_type);</span><br><span class="line">read_uint16(p, p_end, target_info.e_machine);</span><br><span class="line">read_uint32(p, p_end, target_info.e_version);</span><br><span class="line">read_uint32(p, p_end, target_info.e_flags);</span><br><span class="line">read_uint32(p, p_end, target_info.reserved);</span><br><span class="line">read_byte_array(p, p_end, target_info.arch, <span class="keyword">sizeof</span>(target_info.arch));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p != buf_end) {</span><br><span class="line">    <span class="comment">// set_error_buf(error_buf, error_buf_size, "invalid section size");</span></span><br><span class="line">    set_error_buf_v(error_buf, error_buf_size, <span class="string">"invalid section size, "</span></span><br><span class="line">                    <span class="string">"p=%p, buf_end=%p, buf=%p"</span>, p, buf_end, buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure><img src="/graduation-project/06/image-20241030164512775.png" alt="image-20241030164512775"><figcaption aria-hidden="true">image-20241030164512775</figcaption></figure><p>差了 12 位。</p><p>说明是在读取 <code>AOT_SECTION_TYPE_TARGET_INFO</code> 即 AOT 的<strong>Target Info Section</strong>（目标信息段）的时候发生的错误。</p><p>这个段的主要作用是提供以下关于目标平台的信息，以确保 AOT模块的代码可以正确加载并运行：</p><ol type="1"><li><strong>平台字节序</strong>：是否为小端序（Little-endian）或大端序（Big-endian）。</li><li><strong>架构位数</strong>：是否为 32 位或 64 位平台。</li><li><strong>目标处理器架构类型</strong>：比如 x86、ARM、MIPS等，确保编译出的代码与处理器架构匹配。</li><li><strong>ABI（Application BinaryInterface）类型</strong>：不同平台可能会使用不同的ABI，确保函数调用、数据传递等方式正确。</li><li><strong>额外标识</strong>：包含与特定平台相关的附加信息，如编译时的标志等。</li></ol><p>我看了一下现在的 <code>wasm</code>的代码，发现这里的数据结构变了！！</p><p>现在的：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Target info, read from ELF header of object file */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AOTTargetInfo</span> {</span></span><br><span class="line">    <span class="comment">/* Binary type, elf32l/elf32b/elf64l/elf64b */</span></span><br><span class="line">    uint16 bin_type;</span><br><span class="line">    <span class="comment">/* ABI type */</span></span><br><span class="line">    uint16 abi_type;</span><br><span class="line">    <span class="comment">/* Object file type */</span></span><br><span class="line">    uint16 e_type;</span><br><span class="line">    <span class="comment">/* Architecture */</span></span><br><span class="line">    uint16 e_machine;</span><br><span class="line">    <span class="comment">/* Object file version */</span></span><br><span class="line">    uint32 e_version;</span><br><span class="line">    <span class="comment">/* Processor-specific flags */</span></span><br><span class="line">    uint32 e_flags;</span><br><span class="line">    <span class="comment">/* Specify wasm features supported */</span></span><br><span class="line">    uint64 feature_flags;</span><br><span class="line">    <span class="comment">/* Reserved */</span></span><br><span class="line">    uint64 reserved;</span><br><span class="line">    <span class="comment">/* Arch name */</span></span><br><span class="line">    <span class="type">char</span> arch[<span class="number">16</span>];</span><br><span class="line">} AOTTargetInfo;</span><br></pre></td></tr></table></figure><p>之前的：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Target info, read from ELF header of object file */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AOTTargetInfo</span> {</span></span><br><span class="line">    <span class="comment">/* Binary type, elf32l/elf32b/elf64l/elf64b */</span></span><br><span class="line">    uint16 bin_type;</span><br><span class="line">    <span class="comment">/* ABI type */</span></span><br><span class="line">    uint16 abi_type;</span><br><span class="line">    <span class="comment">/* Object file type */</span></span><br><span class="line">    uint16 e_type;</span><br><span class="line">    <span class="comment">/* Architecture */</span></span><br><span class="line">    uint16 e_machine;</span><br><span class="line">    <span class="comment">/* Object file version */</span></span><br><span class="line">    uint32 e_version;</span><br><span class="line">    <span class="comment">/* Processor-specific flags */</span></span><br><span class="line">    uint32 e_flags;</span><br><span class="line">    <span class="comment">/* Reserved */</span></span><br><span class="line">    uint32 reserved;</span><br><span class="line">    <span class="comment">/* Arch name */</span></span><br><span class="line">    <span class="type">char</span> arch[<span class="number">16</span>];</span><br><span class="line">} AOTTargetInfo;</span><br></pre></td></tr></table></figure><p>也就是说，<code>WATZ</code> 的代码只支持运行老版本的 wasm程序，新版本的 wasm 就会类型不匹配。</p><p>现在有两个方法：</p><ol type="1"><li>移植 runtime，以适应最新的版本.</li><li>直接使用 watz 里的 runtime 进行 wasm 的编译，编译得到老版本的wasm.</li></ol><p>根据 <a href="##WASM%20与%20AOT%20的补充">附录-WASM 与 AOT 的补充</a>，方案二更合理，相当于我们基于的就是老版本的 wamr，使用我这个项目必须用我们的 <code>wasmc</code> 将 <code>wasm</code>文件转换为 <code>aot</code>。</p><p>目测了一下变化不小，我先用方法二测试一下 watz移植的有没有问题吧。</p><p>下载 <code>WATZ</code> 使用的 <code>wasm-micro-runtime</code>版本：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git clone --no-checkout https:<span class="comment">//github.com/bytecodealliance/wasm-micro-runtime.git wasm-micro-runtime-cba4c782</span></span><br><span class="line">cd wasm-micro-runtime-cba4c782</span><br><span class="line">git checkout cba4c782</span><br></pre></td></tr></table></figure><p>编译 <code>wamrc</code> 详细内容见<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2J5dGVjb2RlYWxsaWFuY2Uvd2FzbS1taWNyby1ydW50aW1lL2Jsb2IvbWFpbi93YW1yLWNvbXBpbGVyL1JFQURNRS5tZA==">官方文档<i class="fa fa-external-link-alt"></i></span>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> wamr-compiler</span><br><span class="line">./build_llvm.sh (or <span class="string">"./build_llvm_xtensa.sh"</span> to support xtensa target)</span><br><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake .. (or <span class="string">"cmake .. -DWAMR_BUILD_PLATFORM=darwin"</span> <span class="keyword">for</span> MacOS)</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>重新编译 <code>aot</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./wamrc --target=aarch64 -o hello_aarch64.aot hello.wasm</span><br></pre></td></tr></table></figure><p>很遗憾，报了新的错：</p><figure><img src="/graduation-project/06/image-20241030210559791.png" alt="image-20241030210559791"><figcaption aria-hidden="true">image-20241030210559791</figcaption></figure><p>但是已经从 load failed 变成了 instantiate failed 了，进了一步233</p><p>定位错误位置：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">wasm_runtime_instantiate_internal -&gt; aot_instantiate -&gt; memories_instantiate -&gt; memory_instantiate</span><br></pre></td></tr></table></figure><p>沃趣，de了半天 bug，发现是 heap_size 设置的大小不合适：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">optee_wamr 4096000 hello_aarch64.aot </span><br></pre></td></tr></table></figure><figure><img src="/graduation-project/06/image-20241030222255649.png" alt="image-20241030222255649"><figcaption aria-hidden="true">image-20241030222255649</figcaption></figure><p>经过二分的测试，上下界：<code>[408340, 12573936]</code></p><p>所以截止当前！已经可以在 OPTEE 中运行 wasm 的程序了！……吗</p><h2 id="更多测试">更多测试</h2><h3 id="复读机">复读机</h3><p>换了一个测试程序，复读机：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">char</span> input[<span class="number">100</span>]; <span class="comment">// 定义一个字符数组来存储输入</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入内容，按 Ctrl+C 退出程序。\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"输入: "</span>);</span><br><span class="line">        fgets(input, <span class="keyword">sizeof</span>(input), <span class="built_in">stdin</span>);  <span class="comment">// 从标准输入读取一行</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"输出: %s"</span>, input);           <span class="comment">// 输出读取的内容</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>再次报错，还是之前的问题，但是此时把 heap_size 调到最大也不行。</p><figure><img src="/graduation-project/06/image-20241031135339147.png" alt="image-20241031135339147"><figcaption aria-hidden="true">image-20241031135339147</figcaption></figure><p>发现很奇怪的地方是 <code>num_bytes_per_page</code>的大小变成了<code>16916384</code> ，16 MB！之前的 hello.aot是：<code>139168</code> 139 KB！</p><p>仅仅多了几行代码，<code>num_bytes_per_page</code> 竟然大了 100多倍。而且也不应该让 page 这么大啊？</p><p>发现必须使用 <code>wasi-sdk</code> 来编译 wasm 文件，再交给 wamrc编译 aot ，得到的文件大小最小，能在 TEE 里执行。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/opt/wasi-sdk/bin/clang -O3 -o test.wasm test.c</span><br></pre></td></tr></table></figure><p>（其实有问题，<code>num_bytes_per_page</code> 还是不应该这么大）</p><p>等一下，可能是 -O3 的原因？试了下用了 O3 也不行。</p><h3 id="带参主函数">带参主函数</h3><p>仅支持传递 0 或 1 个主函数参数。</p><h1 id="总结">总结</h1><ol type="1"><li><p>提供的 <code>aot</code> 文件，必须由老版本的<code>wasm-micro-runtime</code> 的 <code>wasmc</code>编译得到。</p></li><li><p><del>提供的 <code>wasm</code> 文件可以任选编译器，因为<code>wasm</code> 有官方标准，而 <code>aot</code>每个编译器有自己的标准。</del></p><p>目前测试结果：</p><table><thead><tr><th>编译器</th><th>结果</th></tr></thead><tbody><tr><td>emcc</td><td>❌</td></tr><tr><td>wasi-sdk</td><td>✅</td></tr><tr><td>待补充</td><td></td></tr></tbody></table></li><li><p>运行时的堆空间上下界为<code>[408340, 12573936]</code>。可能不同的环境中，这个数值会有所不同，还不太清楚。总之取一个中间数比较稳，例如 1000000 一百万。</p></li></ol><p>明天的工作：</p><p>整理一遍 WATZ 的移植，并开源一个项目。</p><p>然后思考接下来的工作，wasm + 智能合约。</p><h1 id="附录">附录</h1><h2 id="wasm-与-aot-的补充">WASM 与 AOT 的补充</h2><p><code>wasm</code> 是有一个标准的，不同的 <code>wasm</code> 编译器（如Emscripten、AssemblyScript、WasmEdge）可能会有不同的优化，生成的<code>wasm</code>文件不完全一样，但是最终的执行效果应该是等价的。并且编译出来的<code>wasm</code> 文件能被任何运行时理解。</p><p>但是 <code>AOT</code> 不同。<code>AOT</code> 是由特定的编译器，将<code>wasm</code> 文件转换成对应的 <code>aot</code> 文件。每个编译器生成<code>aot</code> 文件的格式都是不一样的。</p><p>因此，我移植了老版的 <code>wasm-micro-runtime</code>运行时，就必须用老版运行时中提供的 <code>wamrc</code> 将<code>wasm</code> 文件编译成 <code>aot</code> 文件才能使用。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;截止目前已经编译成功了 WATZ。接下来尝试如何使用 WATZ 运行一个 WASM
程序。&lt;/p&gt;
&lt;p&gt;本文是 debug 的记录，大多数内容都是废话2333，只看总结就好。&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://cishoon.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="毕设" scheme="http://cishoon.top/tags/%E6%AF%95%E8%AE%BE/"/>
    
    <category term="op-tee" scheme="http://cishoon.top/tags/op-tee/"/>
    
    <category term="TrustZone" scheme="http://cishoon.top/tags/TrustZone/"/>
    
    <category term="WebAssembly" scheme="http://cishoon.top/tags/WebAssembly/"/>
    
    <category term="WaTZ" scheme="http://cishoon.top/tags/WaTZ/"/>
    
  </entry>
  
  <entry>
    <title>毕设08 - Cosmos 简介与 Cosmos SDK 模块详解</title>
    <link href="http://cishoon.top/graduation-project/07(%E5%BE%85)/"/>
    <id>http://cishoon.top/graduation-project/07(%E5%BE%85)/</id>
    <published>2024-10-29T16:00:00.000Z</published>
    <updated>2024-11-12T03:43:02.861Z</updated>
    
    <content type="html"><![CDATA[<p>截止目前，已经成功在 optee 中运行 wasm 程序。</p><p>接下来要尝试怎么用 wasm 实现智能合约。</p><p>技术选型为 Cosmos。</p><span id="more"></span><h1 id="cosmos-介绍">1 Cosmos 介绍</h1><p>https://zhuanlan.zhihu.com/p/59651447</p><p>待补充，先进行代码的实验。</p><h1 id="其他工具">2 其他工具</h1><h2 id="ignite-cli">Ignite CLI</h2><p><strong>Ignite</strong> 是一个用于快速构建基于 <strong>CosmosSDK</strong>的区块链应用的开发工具。它提供了从模板生成、模块添加、代码生成到应用部署的一整套功能，帮助开发者简化开发流程。</p><h1 id="cosmos-sdk-模块详解">3 Cosmos SDK 模块详解</h1><h2 id="staking">1 staking</h2><p>用于实现权益委托证明（PoS）公式机制。Pos取代的是工作量证明（PoW）机制。对区块的证明不再使用大量的计算——挖矿来实现，而是让用户把自己的代币（Token）作为质押，以获得验证资格。</p><h3 id="pow-与-pos-的对比">1.1 PoW 与 PoS 的对比</h3><p><strong>PoW（Proof of Work，工作量证明）：</strong></p><ul><li>产生一个新的区块的过程依赖于矿工的计算能力（算力）。</li><li>矿工通过大量计算，寻找一个符合难度目标的哈希值（例如开头为多个零的哈希值，常用的是SHA-256）。这一过程称为“挖矿”。</li><li>一旦矿工成功找到符合条件的哈希值，就将这个新的区块及其哈希值提交到区块链网络。</li><li>网络会验证该哈希值，若有效，则将区块加入主链，且矿工获得奖励（通常是代币奖励和交易手续费的组合）。</li></ul><p><strong>PoS（Proof of Stake，权益证明）：</strong></p><ul><li>用户通过质押代币来获得验证资格，质押的代币越多，被选为验证人的机会越大。</li><li>当一个新的区块产生时，系统会从有验证资格的用户（验证人）中选择一个或多个用户来验证和打包该区块。</li><li>验证人在验证区块后，将区块信息发送至网络。</li><li>一旦区块得到确认，验证人获得奖励，通常以质押的代币奖励形式。</li></ul><h3 id="关键概念">1.2 关键概念</h3><ul><li><p><strong>验证人（Validators）</strong>：</p><ul><li>验证人是运行节点并负责验证区块的用户。</li><li>需要将自身或其他用户委托的代币作为抵押来获得验证资格。</li><li>验证人会根据所抵押的代币数量来竞争进入“活跃验证人集合”，即质押的代币越多越容易被选中。</li><li>验证人需要保持节点的高可用性和诚实性，若出现双签、宕机等情况会受到惩罚。</li></ul></li><li><p><strong>委托人（Delegators）</strong>：</p><ul><li>委托人是持有代币的用户，可以将代币委托给他们信任的验证人，以参与网络的共识过程。</li><li>委托人将代币交给验证人后，便与验证人共同承担网络的安全性责任。验证人获得的奖励和惩罚也会按照比例分配给委托人。</li><li>委托人有权选择撤回委托（即“解锁”），但是解锁过程通常需要经过一个解锁期，防止系统因频繁的资金移动而失稳。</li></ul></li><li><p><strong>抵押和解锁机制（Bonding and Unbonding）</strong>：</p><ul><li>当用户（无论是验证人还是委托人）将代币锁定在 staking模块中时，这些代币即被抵押。抵押的代币使验证人有资格进入活跃验证人集合。</li><li>抵押的代币要解除时会经历一个“解锁期”（通常为几周），在这期间用户无法动用这部分代币。解锁期可以防止网络因大量代币突然解锁而失去安全性。</li></ul></li><li><p><strong>奖励分配（Reward Distribution）</strong>：</p><ul><li>staking 模块与分配奖励的 <strong>distribution</strong>模块协同工作，为验证人和委托人分配奖励。</li><li>验证人可以设置佣金费率（即奖励的某一比例作为其运营费用），其余部分则分配给委托人。</li><li>奖励的来源通常是区块链的通胀部分（增发代币）或交易手续费。</li></ul></li><li><p><strong>惩罚机制（Slashing）</strong></p><ul><li><p>为保障网络的安全，staking 模块配合 <strong>slashing</strong>模块引入了惩罚机制，旨在对不诚信或表现不佳的验证人进行惩罚。</p></li><li><p>常见的惩罚行为有双签（Double Signing）和宕机（Downtime）。</p><blockquote><p>双签的例子：</p><p>假设区块链网络发生了短暂分叉。验证人 A 在区块高度 100 签署了区块A_100。与此同时，网络中的另一部分在同一高度 100 也签署了另一个区块B_100。</p><p>如果验证人 A 无意中在网络恢复后又对 B_100进行了签名，网络就会记录到验证人 A 在高度 100 发生了双签。</p></blockquote></li></ul></li><li><p><strong>治理（Governance）参与</strong></p><ul><li>staking模块中的验证人和委托人都有权参与链上治理，即投票表决提案。这些提案可能包括升级链的参数或添加新功能。</li><li>委托人通常会继承他们所选择的验证人的投票意向，但也可以自主投票，确保自身权益得到更好保障。</li></ul></li></ul><h3 id="bft-与-staking">1.3 BFT 与 staking</h3><ul><li>他们并不是同一层级的概念，BFT 共识协议在 Tendermint的共识层中实现。</li><li>staking机制作用于<strong>验证人选拔和激励层</strong>，决定哪些验证人可以参与共识，并通过奖励和惩罚保障验证人的行为。</li><li>BFT共识作用于<strong>共识层</strong>，解决已选出的验证人如何就区块内容达成一致的问题。</li></ul><h2 id="bank-模块">2 bank 模块</h2><p>Cosmos SDK 的 <code>bank</code>模块是一个核心模块，专门用于在账户之间实现可替代代币（fungibletokens）的转账。该模块提供了基本的代币管理功能，包括发送、接收、查询余额等，是Cosmos SDK 应用中资金流转的基础。以下是 <code>bank</code>模块的详细介绍：</p><h3 id="模块概述">2.1 <strong>模块概述</strong></h3><ul><li><code>bank</code> 模块负责管理账户中的可替代代币（如 Cosmos 的 ATOM或应用链自定义的代币）。</li><li>提供了基本的转账功能，允许账户之间进行代币转移。</li><li>支持自定义多个代币（多资产）和配置转账权限（如黑名单、白名单等）。</li></ul><h3 id="主要功能">2.2 <strong>主要功能</strong></h3><ul><li><strong>转账（Transfers）</strong>：实现账户之间的代币转移，并通过权限控制（如<code>send_enabled</code>）设置哪些代币可以进行转账。</li><li><strong>查询余额（BalanceQueries）</strong>：允许查询指定账户的代币余额，并支持查询所有代币余额。</li><li><strong>多资产支持（Multi-AssetSupport）</strong>：支持在链上创建和管理多个类型的代币，每种代币都可以独立操作。</li></ul><h3 id="账户类型">2.3 <strong>账户类型</strong></h3><ul><li>Cosmos SDK 的 <code>bank</code>模块将每个账户的代币余额存储在账户模块（<code>auth</code>）的<code>Account</code>对象中。每个账户有一个唯一的地址和一个与之关联的余额。</li><li>账户类型通常有：<ul><li><strong>BaseAccount</strong>：标准账户，用于存储基本的余额和公钥信息。</li><li><strong>ModuleAccount</strong>：模块账户，通常用于协议或模块操作的资金池，比如治理模块的储备资金。</li></ul></li></ul><h3 id="转账权限控制">2.4 <strong>转账权限控制</strong></h3><ul><li><code>bank</code>模块允许设置特定代币的转账权限，主要用于控制哪些代币可以转账、是否暂停某类代币的转账等。</li><li>通过 <code>SendEnabled</code>配置参数，可以启用或禁用某种特定代币的转账功能。这对于防止恶意代币或临时冻结某些代币具有重要意义。</li></ul><h3 id="关键操作流程">2.5 <strong>关键操作流程</strong></h3><ul><li><strong>发送代币流程</strong>：<ul><li>用户通过提交 <code>MsgSend</code> 消息请求发送代币。</li><li><code>bank</code>模块验证发送者的余额是否充足，并确保接收者的地址有效。</li><li>代币成功从发送者账户转移到接收者账户，事件系统记录该转账事件。</li></ul></li><li><strong>批量转账流程</strong>：<ul><li>用户通过提交 <code>MsgMultiSend</code>消息请求多个账户之间的批量转账。</li><li>模块会验证所有发送方的余额是否足够，并在验证成功后批量执行转账操作。</li></ul></li></ul><h3 id="与其他模块的交互">2.6 <strong>与其他模块的交互</strong></h3><ul><li><code>bank</code> 模块通常会与以下模块交互：<ul><li><strong>auth 模块</strong>：管理账户结构及其权限，与<code>bank</code> 模块协作存储和读取账户的余额信息。</li><li><strong>staking模块</strong>：当用户将代币抵押给验证人时，这些代币会从<code>bank</code>模块中“冻结”，不可转账，形成一种账户余额的“锁定”状态。</li><li><strong>distribution模块</strong>：用于将奖励分配给验证人和委托人，资金通过<code>bank</code> 模块进行流转。</li></ul></li></ul><h2 id="gov">3 gov</h2><h3 id="模块概述-1">3.1 模块概述</h3><ul><li><code>gov</code>模块是一个链上治理系统，允许任何代币持有者发起提案，并通过社区投票来决定提案是否通过。</li><li>主要功能包括提案创建、投票过程、提案生效与否的判定等。</li><li><code>gov</code>模块使区块链变得更具弹性和适应性，代币持有者可以直接参与协议的变更。</li></ul><h3 id="提案类型">3.2 提案类型</h3><p><code>gov</code>模块支持多种提案类型，每种类型对应链上不同的管理事项：</p><ul><li><strong>文本提案（TextProposal）</strong>：仅供讨论和表决的提案，没有直接操作链上参数的权限，通常用于提出改进建议或社区讨论。</li><li><strong>参数变更提案（Parameter ChangeProposal）</strong>：提议修改链上的参数配置（如交易费用、质押参数等），通过后自动更新链上参数。</li><li><strong>软件升级提案（Software UpgradeProposal）</strong>：提议进行链上软件升级。通过后链上的升级模块会执行更新。</li><li><strong>社区资金提案（Community Pool SpendProposal）</strong>：提议从社区资金池中提取资金，支持对某些项目或社区活动进行资助。</li></ul><h3 id="提案生命周期">3.3 <strong>提案生命周期</strong></h3><ul><li><strong>提交提案</strong>：用户提交提案并支付一定数量的代币作为押金，押金可防止垃圾提案泛滥。若提案未通过押金将被扣除。</li><li><strong>存款阶段（DepositPeriod）</strong>：提案需要达到一定的存款门槛（通常是由其他用户补充押金），才能进入投票阶段。</li><li><strong>投票阶段（VotingPeriod）</strong>：提案进入投票阶段后，所有有投票权的代币持有者都可以对其进行投票。</li><li><strong>投票结果</strong>：在投票阶段结束后，系统根据预设的通过标准判断提案是否通过。</li><li><strong>提案结果执行</strong>：若提案通过，则根据提案的类型执行相应操作；若未通过，则押金会被退还或销毁。</li></ul><h3 id="投票机制">3.4 <strong>投票机制</strong></h3><p><code>gov</code>模块允许所有拥有投票权的代币持有者对提案进行投票。投票方式通常包括以下几种：</p><ul><li><p><strong>Yes</strong>：赞成提案。</p></li><li><p><strong>No</strong>：反对提案。</p></li><li><p><strong>NoWithVeto</strong>：强烈反对提案并主张否决，若此选项票数达到一定比例，提案将被直接拒绝，且押金会被销毁。</p></li><li><p><strong>Abstain</strong>：弃权，表示中立意见，弃权票不影响提案通过率的计算。</p></li><li><p><strong>通过标准</strong>：提案的通过率由参数控制，通常包括最低投票参与率、赞成票占比等。只有满足这些标准，提案才会被视为通过。</p></li></ul><h3 id="section"></h3><h3 id="存款机制">3.5 <strong>存款机制</strong></h3><ul><li>提案发起时需要支付一定数量的押金（Deposit），押金的数量和形式由治理参数决定。</li><li>如果提案未达到存款门槛，提案将不会进入投票阶段；未达到存款门槛的提案在一定时间后会被自动关闭，押金返还。</li><li>若提案被否决或否决比例超过特定标准，押金可能会被销毁，以减少恶意提案的产生。</li></ul><h3 id="与其他模块的交互-1">3.6 与其他模块的交互</h3><ul><li><strong>bank模块</strong>：在用户支付提案押金、提取社区资金等操作时，需要与<code>bank</code> 模块交互来转移代币。</li><li><strong>distribution模块</strong>：在社区资金提案通过后，<code>gov</code> 模块会调用<code>distribution</code> 模块以分配社区资金。</li><li><strong>staking 模块</strong>：治理模块与 staking模块交互，以决定未投票用户的投票意向是否与其所委托的验证人一致。</li></ul><h3 id="提案流程示例">3.7 提案流程示例</h3><ul><li>用户创建一个新提案并支付最小押金。</li><li>其他用户可以为该提案增加押金，直到达到最低存款要求。</li><li>达到要求后提案进入投票阶段，代币持有者在 <code>VotingPeriod</code>内可以对提案进行投票。</li><li>投票结束后，系统依据投票结果判断提案是否通过，并触发相应的操作（如更改参数、升级软件等）。</li></ul><h2 id="slashing">4 slashing</h2><h2 id="distribution">5 distribution</h2><h2 id="auth">6 auth</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;截止目前，已经成功在 optee 中运行 wasm 程序。&lt;/p&gt;
&lt;p&gt;接下来要尝试怎么用 wasm 实现智能合约。&lt;/p&gt;
&lt;p&gt;技术选型为 Cosmos。&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://cishoon.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="区块链" scheme="http://cishoon.top/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="毕设" scheme="http://cishoon.top/tags/%E6%AF%95%E8%AE%BE/"/>
    
    <category term="Cosmos" scheme="http://cishoon.top/tags/Cosmos/"/>
    
  </entry>
  
  <entry>
    <title>毕设05 - WATZ 迁移</title>
    <link href="http://cishoon.top/graduation-project/05/"/>
    <id>http://cishoon.top/graduation-project/05/</id>
    <published>2024-10-25T16:00:00.000Z</published>
    <updated>2024-10-30T14:53:47.679Z</updated>
    
    <content type="html"><![CDATA[<ul><li>单独编译 OPTEE 的 CA/TA 的方法。</li><li>移植 WATZ 到现在的 OPTEE 中。</li><li>测试 WATZ 。</li></ul><span id="more"></span><h1 id="备忘">备忘</h1><h2 id="makefile中-debug-方式">MakeFile中 Debug 方式</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">log_to_file = <span class="variable">$(<span class="built_in">shell</span>  echo "Makefile Path     : $(<span class="built_in">realpath</span> $(<span class="built_in">lastword</span> <span class="variable">$(MAKEFILE_LIST)</span>)</span>)<span class="string">" &gt;&gt; /root/my-test.log &amp;&amp; \</span></span><br><span class="line"><span class="string">                       echo "</span>Parameter Name    : $(1)<span class="string">" &gt;&gt; /root/my-test.log &amp;&amp; \</span></span><br><span class="line"><span class="string">                       echo "</span>Parameter Value   : $(2)<span class="string">" &gt;&gt; /root/my-test.log &amp;&amp; \</span></span><br><span class="line"><span class="string">                       echo "</span>==============================<span class="string">" &gt;&gt; /root/my-test.log)</span></span><br><span class="line"><span class="string">$(call log_to_file, "</span>VAR_NAME<span class="string">", "</span><span class="variable">$(VAR_NAME)</span><span class="string">")</span></span><br></pre></td></tr></table></figure><p>在 <code>~/.bashrc</code> 中添加如下代码，可以在任何地方通过<code>viewlog</code> 快速查看日志：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> viewlog=<span class="string">"cat /root/my-test.log"</span></span><br></pre></td></tr></table></figure><h2 id="重新编译-optee">重新编译 OPTEE</h2><p>在 <code>optee/build</code> 中：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make  FORCE_UNSAFE_CONFIGURE=1 -j`<span class="built_in">nproc</span>`</span><br></pre></td></tr></table></figure><h2 id="手动编译-cata">手动编译 CA/TA</h2><h3 id="optee_client">optee_client</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root/optee/optee_client</span><br><span class="line"><span class="built_in">rm</span> -rf build</span><br><span class="line">make clean</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> TA_DEV_KIT_DIR=/root/optee/build/../optee_os/out/arm/export-ta_arm64 </span><br><span class="line"><span class="built_in">export</span> CROSS_COMPILE=<span class="string">"/usr/bin/ccache /root/optee/build/../toolchains/aarch64/bin/aarch64-linux-gnu-"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>先手动编译 <code>optee_client</code> ，为了得到<code>libteec.so</code></p><h3 id="ta">TA</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> TA_DEV_KIT_DIR=/root/optee/build/../optee_os/out/arm/export-ta_arm64 </span><br><span class="line"><span class="built_in">export</span> CROSS_COMPILE=<span class="string">"/usr/bin/ccache /root/optee/build/../toolchains/aarch64/bin/aarch64-linux-gnu-"</span></span><br><span class="line">make run</span><br></pre></td></tr></table></figure><h3 id="ca">CA</h3><p>修改 <code>optee/optee_examples</code> 中的<code>CMakeList.txt</code>：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">3.2</span>)</span><br><span class="line"><span class="keyword">project</span> (optee_examples C)</span><br><span class="line"></span><br><span class="line"><span class="comment"># https://cmake.org/Wiki/CMake_Useful_Variables</span></span><br><span class="line"><span class="keyword">set</span> (CMAKE_TOOLCHAIN_FILE CMakeToolchain.txt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加如下两行，改成对应的路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(/root/optee/optee_client/libteec/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(/root/optee/optee_client/out/libteec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(GNUInstallDirs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_compile_options</span> (-Wall)</span><br><span class="line"><span class="comment">#add_compile_options (</span></span><br><span class="line"><span class="comment">#       -Wall -Wbad-function-cast -Wcast-align</span></span><br><span class="line"><span class="comment">#       -Werror-implicit-function-declaration -Wextra</span></span><br><span class="line"><span class="comment">#       -Wfloat-equal -Wformat-nonliteral -Wformat-security</span></span><br><span class="line"><span class="comment">#       -Wformat=2 -Winit-self -Wmissing-declarations</span></span><br><span class="line"><span class="comment">#       -Wmissing-format-attribute -Wmissing-include-dirs</span></span><br><span class="line"><span class="comment">#       -Wmissing-noreturn -Wmissing-prototypes -Wnested-externs</span></span><br><span class="line"><span class="comment">#       -Wpointer-arith -Wshadow -Wstrict-prototypes</span></span><br><span class="line"><span class="comment">#       -Wswitch-default -Wunsafe-loop-optimizations</span></span><br><span class="line"><span class="comment">#       -Wwrite-strings -Werror -fPIC</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">find_program</span>(CCACHE_FOUND ccache)</span><br><span class="line"><span class="keyword">if</span>(CCACHE_FOUND)</span><br><span class="line">        <span class="keyword">set_property</span>(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ccache)</span><br><span class="line">        <span class="keyword">set_property</span>(GLOBAL PROPERTY RULE_LAUNCH_LINK ccache)</span><br><span class="line"><span class="keyword">endif</span>(CCACHE_FOUND)</span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>(GLOB dirs *)</span><br><span class="line"><span class="keyword">foreach</span>(dir <span class="variable">${dirs}</span>)</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">EXISTS</span> <span class="variable">${dir}</span>/CMakeLists.txt)</span><br><span class="line">                <span class="keyword">add_subdirectory</span>(<span class="variable">${dir}</span>)</span><br><span class="line">        <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure><p>然后进行编译，最终得到 <code>optee_examples</code> 中所有的 CA：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake -DCMAKE_C_COMPILER=<span class="string">"/root/optee/build/../toolchains/aarch64/bin/aarch64-linux-gnu-gcc"</span> ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure><h1 id="编译-watz-的-cata">编译 WATZ 的 CA/TA</h1><h2 id="移植-optee_os">移植 optee_os</h2><p>由于 WATZ 基于老版本的 optee_os 进行了修改，想在最新的 optee_os中编译运行 CA/TA 需要修改部分代码。</p><p>在 <code>/optee/optee_os/lib/libutee/include/pta_system.h</code>中添加：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * UNOFFICIAL API EXTENSION by WaTZ</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Change the protection of mapped memory pages</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTA_SYSTEM_MPROTECT20</span></span><br></pre></td></tr></table></figure><p>在<code>/optee/optee_os/lib/libutee/include/tee_internal_api_extensions.h</code>中添加：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * UNOFFICIAL API EXTENSION by WaTZ</span></span><br><span class="line"><span class="comment"> * tee_mprotect() - Change the protection of mapped memory pages</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TEE_Result <span class="title function_">tee_mprotect</span><span class="params">(<span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">uint32_t</span> prot)</span>;</span><br></pre></td></tr></table></figure><p>在 <code>/optee/optee_os/lib/libutee/tee_system_pta.c</code>中添加：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TEE_Result <span class="title function_">tee_mprotect</span><span class="params">(<span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">uint32_t</span> prot)</span></span><br><span class="line">{</span><br><span class="line">TEE_Result res = TEE_SUCCESS;</span><br><span class="line"><span class="type">uint32_t</span> param_types = TEE_PARAM_TYPES(TEE_PARAM_TYPE_VALUE_INPUT,</span><br><span class="line">       TEE_PARAM_TYPE_VALUE_INPUT,</span><br><span class="line">       TEE_PARAM_TYPE_NONE,</span><br><span class="line">       TEE_PARAM_TYPE_NONE);</span><br><span class="line">TEE_Param params[TEE_NUM_PARAMS] = { };</span><br><span class="line"></span><br><span class="line">params[<span class="number">0</span>].value.a = len;</span><br><span class="line">params[<span class="number">0</span>].value.b = prot;</span><br><span class="line">reg_pair_from_64((<span class="type">vaddr_t</span>)buf, &amp;params[<span class="number">1</span>].value.a, &amp;params[<span class="number">1</span>].value.b);</span><br><span class="line"></span><br><span class="line">res = invoke_system_pta(PTA_SYSTEM_MPROTECT, param_types, params);</span><br><span class="line"><span class="keyword">if</span> (res)</span><br><span class="line">EMSG(<span class="string">"Invoke PTA_SYSTEM_MPROTECT: buf %p, len %#zx, prot %u"</span>, buf, len, prot);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>之后增加系统调用：</p><p>在 <code>core/pta/system.c</code> 中添加：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> TEE_Result <span class="title function_">system_mprotect</span><span class="params">(<span class="keyword">struct</span> user_mode_ctx *uctx, <span class="type">uint32_t</span> param_types,</span></span><br><span class="line"><span class="params">       TEE_Param params[TEE_NUM_PARAMS])</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> exp_pt = TEE_PARAM_TYPES(TEE_PARAM_TYPE_VALUE_INPUT,</span><br><span class="line">  TEE_PARAM_TYPE_VALUE_INPUT,</span><br><span class="line">  TEE_PARAM_TYPE_NONE,</span><br><span class="line">  TEE_PARAM_TYPE_NONE);</span><br><span class="line">TEE_Result res = TEE_SUCCESS;</span><br><span class="line"><span class="type">uint32_t</span> vm_flags = <span class="number">0</span>;</span><br><span class="line"><span class="type">vaddr_t</span> end_va = <span class="number">0</span>;</span><br><span class="line"><span class="type">vaddr_t</span> va = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> sz = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint32_t</span> prot = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (exp_pt != param_types)</span><br><span class="line"><span class="keyword">return</span> TEE_ERROR_BAD_PARAMETERS;</span><br><span class="line"></span><br><span class="line">va = reg_pair_to_64(params[<span class="number">1</span>].value.a, params[<span class="number">1</span>].value.b);</span><br><span class="line">sz = ROUNDUP(params[<span class="number">0</span>].value.a, SMALL_PAGE_SIZE);</span><br><span class="line">prot = params[<span class="number">0</span>].value.b;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The vm_get_flags() and vm_unmap() are supposed to detect or</span></span><br><span class="line"><span class="comment"> * handle overflow directly or indirectly. However, this function</span></span><br><span class="line"><span class="comment"> * an API function so an extra guard here is in order. If nothing</span></span><br><span class="line"><span class="comment"> * else to make it easier to review the code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (ADD_OVERFLOW(va, sz, &amp;end_va))</span><br><span class="line"><span class="keyword">return</span> TEE_ERROR_BAD_PARAMETERS;</span><br><span class="line"></span><br><span class="line">res = vm_get_flags(uctx, va, sz, &amp;vm_flags);</span><br><span class="line"><span class="keyword">if</span> (res)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"><span class="keyword">if</span> (vm_flags &amp; VM_FLAG_PERMANENT)</span><br><span class="line"><span class="keyword">return</span> TEE_ERROR_ACCESS_DENIED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> vm_set_prot(uctx, va, sz, prot);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在 <code>core/pta/system.c</code> 的<code>TEE_Result invoke_command()</code> 函数中添加新增的枚举：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> PTA_SYSTEM_MPROTECT:</span><br><span class="line"><span class="keyword">return</span> system_mprotect(uctx, param_types, params);</span><br></pre></td></tr></table></figure><p>在 <code>utee_defines.h</code> 中 修改<code>HW_UNIQUE_KEY_LENGTH</code> :</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HW_UNIQUE_KEY_LENGTH     (32)</span></span><br></pre></td></tr></table></figure><p>在 <code>trach.h</code> 中修改 <code>MAX_PRINT_SIZE</code> :</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_PRINT_SIZE      512</span></span><br></pre></td></tr></table></figure><h2 id="编译-libvmlib.a">编译 libvmlib.a</h2><p>这是 wamr 的静态库文件。wamr 的<code>/unine-watz/runtime/product-mini/platforms</code>中提供了各个平台的编译代码。编译任何平台的 wamr 之前都需要先得到<code>libvmlib.a</code> 。</p><p>WATZ 新增了 <code>linux-truxtzone</code> 目录，里面提供了一个<code>CMakeList.txt</code> 。（此外还有论文中描述的两个组件<code>verifier</code> 和 <code>attester</code>，但是此时用不到这两个组件）</p><p>修改 <code>CMakeList.txt</code> ，增加：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include_directories(/root/unine-watz/optee_os/lib/libutils/ext/include)</span><br><span class="line">include_directories(/root/unine-watz/optee_os/lib/libutee/include)</span><br></pre></td></tr></table></figure><p>其中 <code>/root/unine-watz</code> 改为你的 WATZ 路径。</p><p>然后执行代码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>即可在 <code>build</code> 目录下得到 <code>libvmlib.a</code>。</p><h2 id="移植-cata">移植 CA/TA</h2><p>在 <code>/optee/optee_examples</code> 中新建 <code>optee_wamr</code>目录，将<code>/unine-watz/runtime/product-mini/platforms/linux-trustzone/vedliot_attester</code>中的代码移植过来，并删除了远程验证的部分代码。</p><p>修改的内容较多，移植后的代码在我的 git 仓库中可以找到。</p><p>为了即开即用，我将 wamr 中的部分文件和 <code>libvmlib.a</code>直接打包了进来。</p><p>另外，如果你直接修改我提供的代码中的 <code>/ta/core</code>中的内容，但是重新编译后却没有应用更改，很可能是因为这部分代码被直接打包进了<code>libvmlib.a</code> ，请参考上一步，修改<code>/unine-watz/runtime</code> 中的代码并重新并覆盖<code>/ta/build/libvmlib.a</code> 。</p><h2 id="调试运行-wamr">调试运行 wamr</h2><h3 id="重新编译">1. 重新编译</h3><p>清除之前编译的缓存：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make clean</span><br></pre></td></tr></table></figure><p>或只删除 optee_examples 的缓存：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf /root/optee/out-br/build/optee_examples*</span><br></pre></td></tr></table></figure><p>重新编译：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root/optee/build</span><br><span class="line">make FORCE_UNSAFE_CONFIGURE=1 run -j`<span class="built_in">nproc</span>`</span><br></pre></td></tr></table></figure><p>启动 qemu 后，在 Normal World 中的 <code>/usr/bin</code>目录中可以找到 <code>optee_wamr</code> 。</p><p><img src="/graduation-project/05/image-20241027205828402.png" alt="image-20241027205828402" style="zoom:50%;"></p><h3 id="上传-wasm-文件">2. 上传 wasm 文件</h3><h4 id="方法一使用-scp">方法一：使用 scp</h4><p>要使用 scp 上传一个 wasm 文件到 Normal World 中，但是 optee 中的linux 系统没有安装 openssh 。</p><p>所以先在修改 build 生成的根文件系统 <code>rootfs.cpio.gz</code>。</p><p><strong>理论上</strong>，在 <code>buildroot</code> 目录中执行<code>make menuconfig</code> ，在菜单中找到并选择以下选项：</p><ul><li><strong>Target packages</strong> &gt; <strong>Networkingapplications</strong> &gt; <strong>openssh</strong></li><li>勾选 <code>openssh</code> 以包含 SSH 服务。</li><li>保存到 <code>.config</code></li></ul><p>然后重新编译即可。</p><p><strong>但是不行！</strong>重新编译运行后，Normal World 中还是没有openssh。</p><p>检查 <code>build/common.mk</code> 中的 <code>buildroot</code> ：</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># All BR2_* variables from the makefile or the environment are appended to</span></span><br><span class="line"><span class="comment"># ../out-br/extra.conf. All values are quoted "..." except y and n.   </span></span><br><span class="line">double-quote = <span class="string">"#"</span> <span class="comment"># This really sets the variable to " and avoids upsetting vim's syntax highlighting</span></span><br><span class="line">streq = <span class="variable">$(<span class="built_in">and</span> $(<span class="built_in">findstring</span> $(1)</span>,$(2)),<span class="variable">$(<span class="built_in">findstring</span> $(2)</span>,$(1)))</span><br><span class="line">y-or-n = <span class="variable">$(<span class="built_in">or</span> $(<span class="built_in">call</span> streq,y,$(1)</span>),<span class="variable">$(<span class="built_in">call</span> streq,n,$(1)</span>))</span><br><span class="line">append-var_ = echo '$(1)=$(3)'$($(1))'$(3)' &gt;&gt;$(2);</span><br><span class="line">append-var = <span class="variable">$(<span class="built_in">call</span> append-var_,$(1)</span>,$(2),<span class="variable">$(<span class="built_in">if</span> $(<span class="built_in">call</span> y-<span class="built_in">or</span>-n,$($(1)</span>)),,$(double-quote)))</span><br><span class="line">append-br2-vars = <span class="variable">$(<span class="built_in">foreach</span> var,$(<span class="built_in">filter</span> BR2_%,$(.VARIABLES)</span>),<span class="variable">$(<span class="built_in">call</span> append-var,<span class="variable">$(var)</span>,$(1)</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifneq</span> (y,<span class="variable">$(BR2_PER_PACKAGE_DIRECTORIES)</span>)</span><br><span class="line">br-make-flags := -j1</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: buildroot</span></span><br><span class="line"></span><br><span class="line"><span class="section">buildroot: optee-os</span></span><br><span class="line">        @mkdir -p ../out-br</span><br><span class="line">        @rm -f ../out-br/build/optee_*/.stamp_*</span><br><span class="line">        @rm -f ../out-br/extra.conf</span><br><span class="line">        @<span class="variable">$(<span class="built_in">call</span> append-br2-vars,../out-br/extra.conf)</span></span><br><span class="line">        @(cd .. &amp;&amp; <span class="variable">$(PYTHON3)</span> build/br-ext/scripts/make_def_config.py \</span><br><span class="line">                --br buildroot --out out-br --br-ext build/br-ext \</span><br><span class="line">                --top-dir <span class="string">"<span class="variable">$(ROOT)</span>"</span> \</span><br><span class="line">                --br-defconfig build/br-ext/configs/optee_<span class="variable">$(BUILDROOT_ARCH)</span> \</span><br><span class="line">                --br-defconfig build/br-ext/configs/optee_generic \</span><br><span class="line">                <span class="variable">$(<span class="built_in">addprefix</span> --br-defconfig build/br-ext/configs/, \</span></span><br><span class="line"><span class="variable">                            <span class="variable">$(BUILDROOT_TOOLCHAIN)</span>)</span> \</span><br><span class="line">                <span class="variable">$(DEFCONFIG_GDBSERVER)</span> \</span><br><span class="line">                <span class="variable">$(DEFCONFIG_XEN)</span> \</span><br><span class="line">                <span class="variable">$(DEFCONFIG_TSS)</span> \</span><br><span class="line">                <span class="variable">$(DEFCONFIG_TPM_MODULE)</span> \</span><br><span class="line">                <span class="variable">$(DEFCONFIG_FTPM)</span> \</span><br><span class="line">                --br-defconfig out-br/extra.conf \</span><br><span class="line">                --make-cmd <span class="variable">$(MAKE)</span>)</span><br><span class="line">        @<span class="variable">$(MAKE)</span> $(br-make-flags) -C ../out-br all</span><br></pre></td></tr></table></figure><p>所以最终使用的配置文件是脚本另外生成的。添加扩展的包，需要在编译的时候添加环境变量：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> BR2_PACKAGE_OPENSSH=y</span><br><span class="line"><span class="built_in">export</span> BR2_PACKAGE_OPENSSH_CLIENT=y</span><br><span class="line"><span class="built_in">export</span> BR2_PACKAGE_OPENSSH_SERVER=y</span><br><span class="line"><span class="built_in">export</span> BR2_PACKAGE_OPENSSH_KEY_UTILS=y</span><br><span class="line"><span class="built_in">export</span> BR2_PACKAGE_OPENSSH_SANDBOX=y</span><br></pre></td></tr></table></figure><p>然后重新 make 即可。</p><blockquote><p>另外，我曾使用一个临时的方法解决了这个问题：<code>/out-br/.config</code>，再重新编译。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /optee/out-br</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><ul><li><strong>Target packages</strong> &gt; <strong>Networkingapplications</strong> &gt; <strong>openssh</strong></li><li>勾选 <code>openssh</code> 以包含 SSH 服务。</li><li>保存到 <code>.config</code></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /optee/out-br</span><br><span class="line">make all</span><br></pre></td></tr></table></figure><p>如果需要添加其他的包，用 make menuconfig 编辑后保存一个.config，在这个 .config 里搜索对应的包名。</p></blockquote><p>回到 <code>build</code> 目录，添加参数 <code>GDBSERVER=y</code> 启动qemu：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make GDBSERVER=y run-only</span><br></pre></td></tr></table></figure><p>会增加 <code>hostfwd=tcp::12345-:12345</code>，将宿主机的<code>12345</code> 端口映射到 QEMU 虚拟机（Normal World）的<code>12345</code> 端口。</p><figure><img src="/graduation-project/05/image-20241027214514125.png" alt="image-20241027214514125"><figcaption aria-hidden="true">image-20241027214514125</figcaption></figure><p>输入 <code>c</code> 启动 OPTEE。</p><p>在 Normal World 中，修改 ssh 端口号和允许Root用户密码登录：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">'s/^#Port .*/Port 12345/'</span> /etc/ssh/sshd_config</span><br><span class="line">sed -i <span class="string">'s/^#PasswordAuthentication .*/PasswordAuthentication yes/'</span> /etc/ssh/sshd_config</span><br><span class="line">sed -i <span class="string">'s/^#PermitRootLogin .*/PermitRootLogin yes/'</span> /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>修改 root 用户密码，密码要记住之后需要用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">passwd root</span><br></pre></td></tr></table></figure><p>重新启用 ssh ：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/sbin/sshd</span><br></pre></td></tr></table></figure><p>之后回到宿主机，使用如下指令上传文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -P 12345 /path/to/local/file root@localhost:/path/to/remote/directory</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -P 12345 /root/WebAssembly/hello.wasm root@localhost:/root/hello.wasm</span><br></pre></td></tr></table></figure><p>之后即可上传文件：</p><figure><img src="/graduation-project/05/image-20241028001128522.png" alt="image-20241028001128522"><figcaption aria-hidden="true">image-20241028001128522</figcaption></figure><p><img src="/graduation-project/05/image-20241028001149784.png" alt="image-20241028001149784" style="zoom:50%;"></p><h4 id="方法二qemu-共享文件夹较方便">方法二：qemu共享文件夹(较方便)</h4><p><code>QEMU_VIRTFS</code> 允许将主机上的一个目录作为虚拟文件系统（9p文件系统）挂载到 QEMU 的 Normal World。</p><p><strong>配置步骤：</strong></p><ol type="1"><li><p><strong>启用 <code>QEMU_VIRTFS</code></strong>：</p><ul><li>设置 <code>QEMU_VIRTFS_ENABLE</code> 为<code>y</code>，并指定要共享的宿主机目录路径，例如项目根目录。</li></ul><p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> QEMU_VIRTFS_ENABLE=y</span><br><span class="line"><span class="built_in">export</span> QEMU_VIRTFS_HOST_DIR=/path/to/your/project</span><br></pre></td></tr></table></figure></p></li><li><p><strong>自动挂载（可选）</strong>：</p><ul><li>如果希望 QEMU 在启动时自动挂载此目录，可以启用<code>QEMU_VIRTFS_AUTOMOUNT</code>：</li></ul><p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> QEMU_VIRTFS_AUTOMOUNT=y</span><br></pre></td></tr></table></figure></p><p>文件已经自动挂载在 <code>/mnt/host</code> 中了。</p></li><li><p><strong>启动 QEMU</strong>：</p><ul><li>启动 QEMU 时确保包含这些环境变量，通常可以通过<code>make QEMU_VIRTFS_ENABLE=y run</code> 启动。</li></ul></li><li><p><strong>手动挂载（如果未自动挂载）</strong>：</p><ul><li>如果未启用自动挂载，进入 QEMU 的 Normal World后，可以手动挂载该目录：</li></ul><p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /mnt/host</span><br><span class="line">mount -t 9p -o trans=virtio host /mnt/host</span><br></pre></td></tr></table></figure></p><ul><li><code>host</code> 是主机目录在 QEMU 内的标签名称，挂载点为<code>/mnt/host</code>。</li></ul></li></ol><p>结果：</p><p><img src="/graduation-project/05/image-20241028214310619.png" alt="image-20241028214310619" style="zoom:50%;"></p><p><img src="/graduation-project/05/image-20241028214222599.png" alt="image-20241028214222599" style="zoom:50%;"></p><p><strong>注意：</strong>这共享文件夹是<strong>实时共享</strong>的。也就是删除<code>/mnt/host</code> 中的文件，也会删除宿主机中的！</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> QEMU_VIRTFS_ENABLE=y</span><br><span class="line"><span class="built_in">export</span> QEMU_VIRTFS_HOST_DIR=/root/WebAssembly</span><br><span class="line"><span class="built_in">export</span> QEMU_VIRTFS_AUTOMOUNT=y</span><br><span class="line">make QEMU_VIRTFS_AUTOMOUNT=y run-only</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /mnt/host</span><br><span class="line">mount -t 9p -o trans=virtio host /mnt/host</span><br></pre></td></tr></table></figure><h3 id="准备-wasm-文件">3. 准备 wasm 文件</h3><p>默认情况下，WATZ 只支持运行 aot 格式的文件。如果希望支持 JIT 和interpret ，需要修改 <code>/unine-watz/runtime/core</code>中的部分配置，并重新编译 <code>libvmlib.a</code> 。（修改我项目中<code>ta/core/</code> 中的文件是没有用的）</p><p>这部分留给下一节博客。目标是慢慢试错，通过阅读源码解决问题，最终运行一个wasm 程序。</p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;单独编译 OPTEE 的 CA/TA 的方法。&lt;/li&gt;
&lt;li&gt;移植 WATZ 到现在的 OPTEE 中。&lt;/li&gt;
&lt;li&gt;测试 WATZ 。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://cishoon.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="毕设" scheme="http://cishoon.top/tags/%E6%AF%95%E8%AE%BE/"/>
    
    <category term="op-tee" scheme="http://cishoon.top/tags/op-tee/"/>
    
    <category term="TrustZone" scheme="http://cishoon.top/tags/TrustZone/"/>
    
  </entry>
  
  <entry>
    <title>TrustZone 与 OP-TEE 技术详解</title>
    <link href="http://cishoon.top/blockchain/OP-TEE/"/>
    <id>http://cishoon.top/blockchain/OP-TEE/</id>
    <published>2024-10-07T16:00:00.000Z</published>
    <updated>2024-10-25T04:29:25.405Z</updated>
    
    <content type="html"><![CDATA[<p>《手机安全和可信应用开发指南：TrustZone与OP-TEE技术详解(网络空间安全技术丛书)》阅读笔记。</p><span id="more"></span><h1 id="可信执行环境">1 可信执行环境</h1><p>TrustZone实现了一个<strong>芯片级</strong>的安全扩展组件，去验证CPU发送的数据访问请求的<strong>非安全状态读写信号位（Non-secure bit，NSbit）</strong>，0表示该请求是安全的，1表示该请求是非安全的。</p><p>当非安全请求试图访问安全数据时，该请求会被认为是非法的。</p><p>TEE 是一套完整的解决方案，包括：</p><ul><li><p><strong>正常世界状态的客户端应用</strong></p><p>OP-TEE 中的 host 部分；Client Application（CA）</p></li><li><p><strong>安全世界状态的可信应用</strong></p><p>OP-TEE 中的 ta 部分；Trusted Application（TA）</p></li><li><p><strong>可信硬件驱动</strong>（Secure Driver）</p></li><li><p><strong>可信内核系统</strong>（TEE OS）</p></li></ul><h1 id="arm-的-trustzone-技术">2 Arm 的 TrustZone 技术</h1><p>在缓存、内存管理单元、总线等资源上增加了安全位。实现了外部资源和内存资源的硬件隔离。这些硬件隔离包括中断隔离、片上RAM和ROM的隔离、片外RAM和ROM的隔离、外围设备的硬件隔离、外部RAM和ROM的隔离等。</p><p>这部分内容过于硬件，看不懂，暂时跳过。</p><h1 id="arm-可信固件">3 ARM 可信固件</h1><p>ARM 可信任固件（ARM TrustedFirmware，ATF）是由ARM官方提供的底层固件，该固件统一了ARM底层接口标准，如电源状态控制接口（Power Status Control Interface，PSCI）、安全启动需求（Trusted BoardBootRequirements，TBBR）、安全世界状态（SWS）与正常世界状态（NWS）切换的安全监控模式调用（securemonitorcall，smc）操作等。ATF旨在将ARM底层的操作统一使代码能够重用和便于移植。</p><p>ATF的源代码共分为bl1、bl2、bl31、bl32、bl33部分。</p><p>其中bl1、bl2、bl31部分属于固定的固件。</p><p>bl32和bl33分别用于加载TEE OS和REE侧的镜像。</p><p>第六章将有详细讲解。</p><h1 id="op-tee-运行环境搭建">4 OP-TEE 运行环境搭建</h1><p>略。见我的 <span class="exturl" data-url="aHR0cHM6Ly9jaXNob29uLmdpdGh1Yi5pby9ncmFkdWF0aW9uLXByb2plY3QvMDEv">毕设01<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9jaXNob29uLmdpdGh1Yi5pby9ncmFkdWF0aW9uLXByb2plY3QvMDIv">毕设02<i class="fa fa-external-link-alt"></i></span>。</p><h1 id="qemu运行op-tee的启动过程">5 QEMU运行OP-TEE的启动过程</h1><p>由第四章得知，在 <code>build</code> 目录执行<code>make run-only</code> 即可在 QEMU 中启动 OP-TEE。</p><p>这个过程主要加载 <code>bios.bin</code> 文件，并从该镜像中分离Linux内核镜像和 OP-TEE 镜像以及 rootfs 镜像。并将rootfs作为根文件系统挂载到Linux 系统中。</p><h1 id="安全引导功能及atf的启动过程">6 安全引导功能及ATF的启动过程</h1><p>安全引导通过电子签名保证系统中重要镜像文件的完整性。OP-TEE 的BootLoader 镜像文件、TEE 镜像文件、Linux内核镜像文件等等都使用了安全引导功能。</p><p>一个直观的感受是，当前大多数 ARM芯片的系统，如果用户非法刷入其他厂商的 ROM 后手机无法正常启动。</p><p>实现方法是在芯片出厂时，就在 ChipRom固化了一部分代码。RSA公钥或哈希值会在出厂之前写入到<code>OTP/efuse</code> 中，只有 ChipRom 和 TEE可以读取其中的内容且无法修改。</p><p>ARMv7的安全引导过程：</p><figure><img src="/blockchain/OP-TEE/image-20241008144836831.png" alt="image-20241008144836831"><figcaption aria-hidden="true">image-20241008144836831</figcaption></figure><p>ARMv8的安全引导过程：</p><figure><img src="/blockchain/OP-TEE/image-20241008145013315.png" alt="image-20241008145013315"><figcaption aria-hidden="true">image-20241008145013315</figcaption></figure><p>完全没看懂……</p><h1 id="ree-侧的上层软件">7 REE 侧的上层软件</h1><p>文中说：“REE 侧的上层软件包括 <code>libteec</code> 库和<code>tee_supplicant</code> 。”</p><p>这里的上层软件，指的不是用户编写的程序或操作系统的软件，<strong>上层</strong>指的是提供的库。</p><p><code>libteec</code> 库提供 CA 程序运行时的基本接口。</p><p><code>tee_supplicant</code> 处理来自 TEE 侧的 RPC 请求。</p><figure><img src="/blockchain/OP-TEE/image-20241015195330454.png" alt="image-20241015195330454"><figcaption aria-hidden="true">image-20241015195330454</figcaption></figure><h2 id="libteec">7.1 libteec</h2><h3 id="内置接口">7.1.1 内置接口</h3><p>提供了总共 10 个 API 接口。</p><h4 id="teec_initializecontext">TEEC_InitializeContext</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TEEC_Result <span class="title function_">TEEC_InitializeContext</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, TEEC_Context *ctx)</span></span><br></pre></td></tr></table></figure><p><code>TEEC_InitializeContext</code> 是 OP-TEE中的一个函数，用于初始化与 TEE (Trusted Execution Environment)通信的上下文 (Context)。这是 TEE 客户端与 TEE系统之间建立通信的第一步。它为后续的安全操作（如打开会话、调用信任应用程序等）创建一个上下文环境。</p><p><code>name</code>（<code>const char \*name</code>）：</p><ul><li>这是一个指向字符串的指针，通常表示 TEE的名称。在大多数情况下，该参数可以传入 <code>NULL</code>，表示使用默认的TEE 实现（通常是 OP-TEE）。</li><li>如果你有多个 TEE 实现，或者特定的 TEE配置，你可以传递一个特定的名称来标识你想使用的 TEE。</li></ul><p><code>ctx</code>（<code>TEEC_Context \*ctx</code>）：</p><ul><li>这是一个指向 <code>TEEC_Context</code>结构体的指针，函数通过这个指针返回一个已初始化的上下文对象。这个上下文对象将用于后续的TEE 操作，如打开会话 (<code>TEEC_OpenSession</code>) 和执行命令(<code>TEEC_InvokeCommand</code>)。</li><li>调用这个函数时，必须为 <code>ctx</code>提供一个有效的指针，函数会将上下文的初始化结果存储在这个结构体中。</li></ul><p>返回值：</p><ul><li>函数返回类型是 <code>TEEC_Result</code>，它表示操作的结果。如果返回<code>TEEC_SUCCESS</code>，说明上下文初始化成功；否则返回一个错误代码，表示初始化失败。</li></ul><h4 id="teec_finalizecontext">TEEC_FinalizeContext</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TEEC_FinalizeContext</span><span class="params">(TEEC_Context *ctx)</span></span><br></pre></td></tr></table></figure><p>释放一个已经被初始化的类型为TEEC_Context的变量，关闭CA与TEE之间的连接。</p><h4 id="teec_opensession">TEEC_OpenSession</h4><p><code>TEEC_OpenSession</code> 函数用于在客户端应用程序（位于 NormalWorld）和 TEE 中的信任应用程序（位于 SecureWorld）之间建立会话。会话建立后，客户端可以通过会话与 TA进行命令传递和数据交换。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TEEC_Result <span class="title function_">TEEC_OpenSession</span><span class="params">(TEEC_Context *ctx,</span></span><br><span class="line"><span class="params">                             TEEC_Session *session,</span></span><br><span class="line"><span class="params">                             <span class="type">const</span> TEEC_UUID *destination,</span></span><br><span class="line"><span class="params">                             <span class="type">uint32_t</span> connectionMethod,</span></span><br><span class="line"><span class="params">                             <span class="type">const</span> <span class="type">void</span> *connectionData,</span></span><br><span class="line"><span class="params">                             TEEC_Operation *operation,</span></span><br><span class="line"><span class="params">                             <span class="type">uint32_t</span> *returnOrigin)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数解释</strong>：</p><ol type="1"><li><p><strong><code>ctx</code>（<code>TEEC_Context \*ctx</code>）：</strong></p><ul><li>这是一个指向已初始化的 <code>TEEC_Context</code>结构体的指针，它用于指定会话的上下文环境。这个上下文必须通过之前调用的<code>TEEC_InitializeContext</code> 函数初始化。</li><li>它代表了客户端与 TEE的通信通道，所有后续的操作都是基于这个上下文进行的。</li></ul></li><li><p><strong><code>session</code>（<code>TEEC_Session \*session</code>）：</strong></p><ul><li>这是一个指向 <code>TEEC_Session</code>结构体的指针，函数通过这个指针返回一个已打开的会话对象。后续客户端与 TA的通信将基于这个会话进行。</li><li>调用 <code>TEEC_OpenSession</code>后，成功建立的会话会被存储在这个结构体中，后续的命令调用等操作将依赖这个会话对象。</li></ul></li><li><p><strong><code>destination</code>（<code>const TEEC_UUID \*destination</code>）：</strong></p><ul><li>这是一个指向 <code>TEEC_UUID</code>结构体的指针，表示目标信任应用程序（TA）的唯一标识符。每个 TA都有一个唯一的 UUID，用于标识它。</li><li>客户端通过 UUID 告诉 TEE 需要连接的具体 TA。</li></ul></li><li><p><strong><code>connectionMethod</code>（<code>uint32_t connectionMethod</code>）：</strong></p><ul><li>该参数用于指定会话的连接方法。在 OP-TEE 中，通常使用的连接方法是<code>TEEC_LOGIN_PUBLIC</code>，表示不需要额外的身份验证信息即可连接到TA。</li><li>其他可能的连接方法包括基于用户身份或组身份的验证方法，如<code>TEEC_LOGIN_USER</code> 和 <code>TEEC_LOGIN_GROUP</code>。</li></ul></li><li><p><strong><code>connectionData</code>（<code>const void \*connectionData</code>）：</strong></p><ul><li>这是与 <code>connectionMethod</code>相关的数据指针。在大多数情况下，当使用 <code>TEEC_LOGIN_PUBLIC</code>时，这个参数可以设置为 <code>NULL</code>，因为不需要额外的数据。</li><li>如果使用特定的连接方法，这里可能需要传递额外的身份验证数据。</li></ul></li><li><p><strong><code>operation</code>（<code>TEEC_Operation \*operation</code>）：</strong></p><ul><li>这是一个指向 <code>TEEC_Operation</code>结构体的指针，表示需要在打开会话时传递的操作数据。如果不需要传递任何操作，可以将其设置为<code>NULL</code>。</li><li>这个结构体包含客户端与 TA之间的参数和共享内存，用于传递数据或命令。</li></ul></li><li><p><strong><code>returnOrigin</code>（<code>uint32_t \*returnOrigin</code>）：</strong></p><ul><li><p>这是一个用于返回错误来源的指针。当会话建立失败时，</p><p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">returnOrigin</span><br></pre></td></tr></table></figure></p><p>会指示错误是发生在客户端、TEE 系统还是 TA 内部。常见的返回值有：</p><ul><li><code>TEEC_ORIGIN_API</code>：表示错误来自 API 调用本身。</li><li><code>TEEC_ORIGIN_COMMS</code>：表示错误发生在与 TEE 的通信层。</li><li><code>TEEC_ORIGIN_TEE</code>：表示错误来自 TEE 系统。</li><li><code>TEEC_ORIGIN_TRUSTED_APP</code>：表示错误来自 TA。</li></ul></li></ul></li></ol><p><strong>返回值</strong>：</p><ul><li><p>函数返回类型为</p><p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TEEC_Result</span><br></pre></td></tr></table></figure></p><p>它表示操作的结果。</p><ul><li>如果返回 <code>TEEC_SUCCESS</code>，表示会话成功打开。</li><li>否则返回错误代码，表示会话建立失败。</li></ul></li></ul><h4 id="teec_closesession">TEEC_CloseSession</h4><p>关闭一个 session</p><h4 id="teec_invokecommand">TEEC_InvokeCommand</h4><p>用于在客户端与信任应用程序 (Trusted Application, TA)之间执行命令的函数。通过这个函数，客户端可以请求 TA执行特定的安全操作或服务，并交换数据。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TEEC_Result <span class="title function_">TEEC_InvokeCommand</span><span class="params">(TEEC_Session *session,</span></span><br><span class="line"><span class="params">                               <span class="type">uint32_t</span> commandID,</span></span><br><span class="line"><span class="params">                               TEEC_Operation *operation,</span></span><br><span class="line"><span class="params">                               <span class="type">uint32_t</span> *returnOrigin)</span>;</span><br></pre></td></tr></table></figure><p>参数解释：</p><p><code>commandID</code>（<code>uint32_t commandID</code>）：</p><ul><li>表示客户端请求 TA 执行的具体命令的标识符。每个 TA都可以定义一组命令，每个命令有一个唯一的<code>commandID</code>，用于区分不同的操作。</li></ul><p><code>operation</code>（<code>TEEC_Operation \*operation</code>）：</p><ul><li>这是一个指向 <code>TEEC_Operation</code>结构体的指针，表示本次命令执行时传递的参数或数据。如果没有参数要传递，可以将其设置为<code>NULL</code>。</li><li><code>TEEC_Operation</code> 是客户端与 TA之间传递数据、参数和共享内存的机制。这个结构体包含四个参数槽（<code>paramTypes</code>和<code>params[]</code>），每个槽都可以存储不同类型的数据（如值、内存引用等）。</li></ul><p>结构体中包含的四个参数槽类型可以是以下几种类型：</p><ul><li><code>TEEC_NONE</code>：表示没有参数。</li><li><code>TEEC_VALUE_INPUT</code>：表示输入类型的简单值参数。</li><li><code>TEEC_VALUE_OUTPUT</code>：表示输出类型的简单值参数。</li><li><code>TEEC_VALUE_INOUT</code>：表示输入和输出类型的简单值参数。</li><li><code>TEEC_MEMREF_TEMP_INPUT</code>：表示传递临时输入的内存引用。</li><li><code>TEEC_MEMREF_TEMP_OUTPUT</code>：表示接收临时输出的内存引用。</li><li><code>TEEC_MEMREF_WHOLE</code>：表示整个共享内存块。</li><li><code>TEEC_MEMREF_PARTIAL_INPUT/OUTPUT</code>：表示部分输入或输出的共享内存。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    TEEC_Session *session,  <span class="comment">// 启用该操作的会话</span></span><br><span class="line">    <span class="type">uint32_t</span> started;       <span class="comment">// 指示操作是否已启动（通常由内部使用）</span></span><br><span class="line">    <span class="type">uint32_t</span> paramTypes;    <span class="comment">// 参数类型，用来定义 params 中的每个参数的类型</span></span><br><span class="line">    TEEC_Parameter params[<span class="number">4</span>]; <span class="comment">// 参数数组，最多可以传递4个参数</span></span><br><span class="line">    TEEC_SharedMemory *memRefs; <span class="comment">// 可选，用于传递共享内存（如果有）</span></span><br><span class="line">} TEEC_Operation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">        <span class="type">uint32_t</span> a;</span><br><span class="line">        <span class="type">uint32_t</span> b;</span><br><span class="line">    } value;  <span class="comment">// 简单值，a 和 b 分别表示两个 32 位的整数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">        <span class="type">void</span> *buffer;</span><br><span class="line">        <span class="type">size_t</span> size;</span><br><span class="line">    } tmpref;  <span class="comment">// 临时内存引用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">        TEEC_SharedMemory *parent;</span><br><span class="line">        <span class="type">size_t</span> size;</span><br><span class="line">        <span class="type">size_t</span> offset;</span><br><span class="line">    } memref;  <span class="comment">// 共享内存引用</span></span><br><span class="line">} TEEC_Parameter;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TEEC_Result res;</span><br><span class="line">TEEC_Session session;</span><br><span class="line">TEEC_Operation op;</span><br><span class="line"><span class="type">uint32_t</span> returnOrigin;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设已经通过 TEEC_OpenSession 成功打开了 session</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置需要传递的参数</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;op, <span class="number">0</span>, <span class="keyword">sizeof</span>(op));</span><br><span class="line">op.paramTypes = TEEC_PARAM_TYPES(TEEC_VALUE_INPUT, TEEC_NONE, TEEC_NONE, TEEC_NONE);</span><br><span class="line">op.params[<span class="number">0</span>].value.a = <span class="number">42</span>;  <span class="comment">// 传递参数值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用命令，commandID 为 0x1234</span></span><br><span class="line">res = TEEC_InvokeCommand(&amp;session, <span class="number">0x1234</span>, &amp;op, &amp;returnOrigin);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (res != TEEC_SUCCESS) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Command failed, error: 0x%x, origin: 0x%x\n"</span>, res, returnOrigin);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h5 id="如果参数大于4个">如果参数大于4个？</h5><p>可以使用共享内存，传递一整块内存区域；或将参数打包成结构体。</p><h4 id="teec_requestcancellation">TEEC_RequestCancellation</h4><p><code>TEEC_RequestCancellation</code>函数用于请求取消客户端已发起的某个异步操作。并不是所有操作都支持取消，这取决于具体的信任应用程序(Trusted Application, TA)以及操作是否支持中途取消。调用这个函数不会立即终止操作，而是请求 TEE停止当前命令的执行。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TEEC_RequestCancellation</span><span class="params">(TEEC_Operation *operation)</span>;</span><br></pre></td></tr></table></figure><h4 id="teec_registersharememory">TEEC_RegisterShareMemory</h4><p>用于在客户端和 TEE（Trusted ExecutionEnvironment）之间注册一块共享内存。共享内存区域用于在客户端和信任应用程序（TrustedApplication,TA）之间传递数据。通过这个函数，客户端可以将其自身的内存区域注册为共享内存，以便在安全世界和普通世界之间进行数据交换。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TEEC_Result <span class="title function_">TEEC_RegisterSharedMemory</span><span class="params">(TEEC_Context *ctx,</span></span><br><span class="line"><span class="params">                                      TEEC_SharedMemory *sharedMem)</span>;</span><br></pre></td></tr></table></figure><p><code>TEEC_SharedMemory</code> 结构体的主要字段：</p><ul><li><code>void \*buffer</code>：指向客户端内存区域的指针，表示需要注册为共享内存的内存块。</li><li><code>size_t size</code>：表示内存块的大小（字节数）。</li><li><code>uint32_t flags</code>：用于标识共享内存的使用方式，常见的值有：<ul><li><code>TEEC_MEM_INPUT</code>：表示共享内存是输入内存，客户端将数据传递给TEE。</li><li><code>TEEC_MEM_OUTPUT</code>：表示共享内存是输出内存，TEE将数据传递给客户端。</li><li><code>TEEC_MEM_INPUT | TEEC_MEM_OUTPUT</code>：表示共享内存既可以作为输入，也可以作为输出。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TEEC_SharedMemory sharedMem;</span><br><span class="line">TEEC_Context ctx;</span><br><span class="line">TEEC_Result res;</span><br><span class="line"><span class="type">void</span> *buffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 TEE 上下文</span></span><br><span class="line">res = TEEC_InitializeContext(<span class="literal">NULL</span>, &amp;ctx);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配客户端的内存区域</span></span><br><span class="line">buffer = <span class="built_in">malloc</span>(<span class="number">1024</span>); <span class="comment">// 分配1KB的内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置共享内存参数</span></span><br><span class="line">sharedMem.buffer = buffer;</span><br><span class="line">sharedMem.size = <span class="number">1024</span>;</span><br><span class="line">sharedMem.flags = TEEC_MEM_INPUT; <span class="comment">// 该共享内存用于传递输入数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册共享内存</span></span><br><span class="line">res = TEEC_RegisterSharedMemory(&amp;ctx, &amp;sharedMem);</span><br><span class="line"><span class="keyword">if</span> (res != TEEC_SUCCESS) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Shared memory registration failed, error code: 0x%x\n"</span>, res);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行其他操作，比如使用 TEEC_InvokeCommand 传递该共享内存...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成后，释放共享内存</span></span><br><span class="line">TEEC_ReleaseSharedMemory(&amp;sharedMem);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放分配的内存</span></span><br><span class="line"><span class="built_in">free</span>(buffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终关闭 TEE 上下文</span></span><br><span class="line">TEEC_FinalizeContext(&amp;ctx);</span><br></pre></td></tr></table></figure><h4 id="teec_registersharememoryfiledescriptor">TEEC_RegisterShareMemoryFileDescriptor</h4><p>用于通过文件描述符将内存区域注册为共享内存，从而在客户端和TEE（Trusted Execution Environment）之间进行数据传递。与<code>TEEC_RegisterSharedMemory</code>函数不同的是，<code>TEEC_RegisterSharedMemoryFileDescriptor</code>允许客户端通过文件描述符直接引用内存，这对于内存映射文件或设备共享内存区域非常有用。</p><h4 id="teec_allocatesharedmemory">TEEC_AllocateSharedMemory</h4><p>用于在客户端与 TEE（Trusted ExecutionEnvironment）之间分配一块共享内存。与<code>TEEC_RegisterSharedMemory</code>不同，<code>TEEC_AllocateSharedMemory</code> 由 TEE客户端库直接为客户端分配内存区域，而不是由客户端自己预先分配并注册。这在需要动态分配内存时非常有用。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TEEC_Result res;</span><br><span class="line">TEEC_Context ctx;</span><br><span class="line">TEEC_SharedMemory sharedMem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 TEE 上下文</span></span><br><span class="line">res = TEEC_InitializeContext(<span class="literal">NULL</span>, &amp;ctx);</span><br><span class="line"><span class="keyword">if</span> (res != TEEC_SUCCESS) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Failed to initialize context: 0x%x\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置共享内存的大小和标志</span></span><br><span class="line">sharedMem.size = <span class="number">4096</span>;  <span class="comment">// 分配 4KB 内存</span></span><br><span class="line">sharedMem.flags = TEEC_MEM_INPUT | TEEC_MEM_OUTPUT;  <span class="comment">// 该共享内存用于双向传递数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配共享内存</span></span><br><span class="line">res = TEEC_AllocateSharedMemory(&amp;ctx, &amp;sharedMem);</span><br><span class="line"><span class="keyword">if</span> (res != TEEC_SUCCESS) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Failed to allocate shared memory: 0x%x\n"</span>, res);</span><br><span class="line">    TEEC_FinalizeContext(&amp;ctx);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在可以使用 sharedMem.buffer 指向的内存区域</span></span><br><span class="line"><span class="comment">// 执行其他操作，如通过 TEEC_InvokeCommand 传递数据...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成后释放共享内存</span></span><br><span class="line">TEEC_ReleaseSharedMemory(&amp;sharedMem);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终关闭 TEE 上下文</span></span><br><span class="line">TEEC_FinalizeContext(&amp;ctx);</span><br></pre></td></tr></table></figure><h5 id="对比-register-和-allocate">对比 Register 和 Allocate</h5><ul><li><p><strong>Register</strong>：将一块已经分配好了的内存空间，<strong>注册</strong>为共享内存。例如在CA 中有一个动态分配空间（即使用 <code>malloc</code>）的数组，可以直接将这个数组注册为共享内存，供 TA 使用。</p><ul><li><p>当有些内存空间已经通过其他方式分配了，（例如与设备共享的内存、通过DMA 机制获取的内存块等），就可以直接通过注册共享内存让 TA访问这部分内存空间。</p></li><li><p>当执行 Release时，只会取消内存空间的共享，需要后续进行手动释放。</p></li><li><p>总结：将已有的空间共享给 TA，所以叫注册。</p></li></ul></li><li><p><strong>Allocate</strong>：不需要已分配的内存空间，这个函数里包含了创建空间的过程。</p><ul><li>一个简化的共享内存管理。我只是想共享一块内存，这个内存并没有其他含义。</li><li>当执行 Release 时，会自动释放内存空间。（更简便）</li></ul></li></ul><h4 id="teec_releasesharedmemory">TEEC_ReleaseSharedMemory</h4><p>释放共享内存空间。</p><h4 id="总结">总结</h4><ul><li><p>初始化、释放 <em>Context</em></p></li><li><p>打开、关闭 <em>Session</em></p></li><li><p>执行、终止 <em>Command</em></p></li><li><p>注册、分配、释放 <em>共享内存</em></p><ul><li>注册额外有一个共享文件</li></ul></li></ul><h3 id="调用-libteec-的流程">7.1.2 调用 libteec 的流程</h3><figure><img src="/blockchain/OP-TEE/image-20241015211908095.png" alt="image-20241015211908095"><figcaption aria-hidden="true">image-20241015211908095</figcaption></figure><h2 id="tee_supplicant">7.2 tee_supplicant</h2><blockquote><p><code>tee_supplicant</code> 是 OP-TEE中的一个用户态进程，用于在普通世界（Normal World）和安全世界（SecureWorld）之间提供辅助功能。它负责处理 TEE中某些操作中需要普通世界支持的请求。简而言之，<code>tee_supplicant</code>是普通世界中的辅助守护进程，为 TEE提供支持，特别是文件系统和共享内存等功能。</p><h3 id="主要功能和作用">主要功能和作用：</h3><p>在 OP-TEE 体系中，<code>tee_supplicant</code>的主要任务是处理由安全世界发出的某些特定类型的请求，例如： 1.<strong>文件系统访问</strong>：TA（TrustedApplication，信任应用程序）可能需要访问文件系统，而安全世界是隔离的，不能直接操作普通世界的文件系统。因此，TA需要通过 <code>tee_supplicant</code> 来进行文件 I/O 操作。 2.<strong>共享内存分配</strong>：在某些场景下，安全世界可能需要更多的共享内存区域，而这些内存需要通过普通世界进行分配和管理，<code>tee_supplicant</code>也负责这类请求。 3.<strong>加密算法支持</strong>：有些信任应用程序需要依赖普通世界中提供的加密支持，比如OpenSSL 之类的库，<code>tee_supplicant</code> 充当桥梁来调用这些服务。4. <strong>启动和管理 TEE 功能</strong>：<code>tee_supplicant</code>在系统启动时运行，确保 TEE 相关资源和服务准备就绪。</p><h3 id="tee_supplicant-的架构图">tee_supplicant 的架构图：</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">+-------------------+      +----------------------+      +---------------------+</span><br><span class="line">|   Secure World    |      |  Normal World        |      |  Linux Filesystem   |</span><br><span class="line">|                   |      |                      |      |                     |</span><br><span class="line">| +--------------+  |      |  +----------------+  |      |  +---------------+  |</span><br><span class="line">| |  Trusted     |  |&lt;----&gt;|  | tee_supplicant |  |&lt;----&gt;|  | Files and Data|  |</span><br><span class="line">| |  Application |  |      |  +----------------+  |      |  +---------------+  |</span><br><span class="line">| +--------------+  |      |                      |      |                     |</span><br><span class="line">|                   |      |                      |      |                     |</span><br><span class="line">+-------------------+      +----------------------+      +---------------------+</span><br></pre></td></tr></table></figure></blockquote><p>即，当 TA 需要用到普通世界中的数据、接口等功能时，TEE 就向<code>tee_supplicant</code> 发送请求 (tee 乞求) 。然后由普通世界的<code>tee_supplicant</code>处理请求，执行类似获取数据、访问文件、调用函数等操作。</p><figure><img src="/blockchain/OP-TEE/image-20241015212813158.png" alt="image-20241015212813158"><figcaption aria-hidden="true">image-20241015212813158</figcaption></figure><p>TA 能向 <code>tee_supplicant</code> 发送的请求有：</p><ul><li>从文件系统中读取TA的镜像保存在共享内存中<br></li><li>对文件系统中的节点进行读/写/打开/关闭/移除等操作<br></li><li>执行RPMB（EMMC中的RPMB分区）相关操作<br></li><li>分配共享内存<br></li><li>释放共享内存<br></li><li>处理gprof请求<br></li><li>执行网络socket请求</li></ul><h1 id="ree-侧的-op-tee-驱动">8 REE 侧的 OP-TEE 驱动</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;《手机安全和可信应用开发指南：TrustZone与OP-TEE技术详解
(网络空间安全技术丛书)》阅读笔记。&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://cishoon.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="TrustZone" scheme="http://cishoon.top/tags/TrustZone/"/>
    
    <category term="OP-TEE" scheme="http://cishoon.top/tags/OP-TEE/"/>
    
  </entry>
  
  <entry>
    <title>毕设04 - 阶段性总结，明确题目</title>
    <link href="http://cishoon.top/graduation-project/04/"/>
    <id>http://cishoon.top/graduation-project/04/</id>
    <published>2024-10-06T16:00:00.000Z</published>
    <updated>2024-10-29T12:36:29.473Z</updated>
    
    <content type="html"><![CDATA[<p>看完了 《WebAssembly原理与核心技术》，重新审视一下原来的目标。</p><span id="more"></span><p>原来的目标是：把 Wasm 移植到 TSC-VEE 中。</p><p>TSC-VEE 是将 evmone 这个高性能的 evm 实现，用 C 语言重构后，编译成 TA移植到 TEE 上。本质上就是 evmone，加上论文中提到的三个优化方案。</p><h1 id="总结">总结</h1><p>目前进度：</p><ol type="1"><li><p>配了虚拟机的环境，可以在本地虚拟机里运行可信执行环境（OP-TEE）和可信执行程序</p></li><li><p>看了、跑了 TSC-VEE 的源码 ；</p><ul><li><p>问题1：github 上开源的源码有问题（两个文件夹的内容重复，没有 TA的实现）</p><p>已经向作者发邮件，获得了最新的代码</p></li><li><p>问题2：代码的实现中，只包含了<u>混合粒度字节码分析</u>一个优化，内存管理、指令预取的优化没有在代码中体现</p><p>计划再向作者发邮件询问</p></li></ul></li><li><p>分析我需要做的事：</p><ol type="1"><li><p>要在 TEE 中执行 Wasm 程序：</p><ol type="1"><li>学习了 Wasm，阅读《WebAssembly原理与核心技术》，学习 Wasm运行时虚拟机的实现。</li><li>有没有现成的 Wasm 运行时，可以嵌入到 TEE 中？有。Wamr，轻量级的 Wasm运行时。</li><li>有没有嵌入到 TEE 中的实例？有。TWINE。（另有 WATZ）</li></ol></li><li><p>把智能合约编译成 Wasm 程序：</p><ol type="1"><li><p>有现成 evm2wasm 项目，可以把 evm 字节码转换成 wasm字节码。（但是这个项目已经归档，不能保证效果，还没实验）</p></li><li><p>如果不局限于<strong>以太坊</strong>智能合约？可以使用原生就是WebAssembly虚拟机的区块链平台做实验？Polkadot</p><blockquote><p><strong>Polkadot</strong></p><ul><li><strong>智能合约语言</strong>：Ink! (Rust-based),Solidity（通过EVM兼容链）</li><li><strong>虚拟机</strong>：Wasm（WebAssembly）虚拟机</li><li>Polkadot提供了一种基于WebAssembly的智能合约环境，可以支持多种编程语言，也支持通过特定平行链与EVM兼容。</li></ul></blockquote></li><li></li></ol></li><li><p>优化这个 Wasm 智能合约的执行过程：</p><ol type="1"><li><p>gas 计算？如何实现这个？一个指令的 gas 消耗是 以太坊官方规定的，每一个版本的 evm 都有他们自己的 gas消耗。我现在修改了智能合约的指令集，如何评估每个指令的gas消耗？还是说我就不用管gas 消耗？</p></li><li><p>针对 TEE 的特性进行优化。（内存小，读指令），参考 TSC-VEE</p><p>是不是能加入内存管理的功能，即时释放内存，使得在 TEE中能够运行更多智能合约</p><p>是不是能指令预取，增加 TEE 中读取指令的速度</p><p>......</p></li></ol></li></ol></li><li><p>此外还找了一篇论文（有些还没详细看，因为看了一点发现太多基础知识不懂，先去学OP-TEE 的基础架构）：</p><ol type="1"><li><p>在 TrustZone 上执行 Fabric 的智能合约：TZ4Fabric: Executing SmartContracts with ARM TrustZone</p></li><li><p>在 TrustZone 上执行 WebAssembly 运行时，并实现远程认证：WATZ: ATrusted WebAssembly Runtime Environment with Remote Attestation forTrustZone</p></li><li><p>在 TEE 上执行 Wasm 运行时（TEE 是 Intel SGX）：TWINE: An EmbeddedTrusted Runtime for WebAssembly</p></li><li><p>用于检测 Wasm 智能合约中的漏洞：WASAI: uncovering vulnerabilitiesin Wasm smart contracts</p></li></ol></li></ol><p>总结：提供了一个能够在 TEE 上运行以 Wasm 实现的智能合约的框架。</p><p>优点：</p><ul><li>安全（TrustZone）</li><li>可移植性、易迁移性、<strong>接近</strong>原生的速度（Wasm）</li><li>性能优化（TSC-VEE）</li></ul><p>相关项目：</p><ul><li>TEE 上运行 Wasm</li><li>Wasm 智能合约</li><li>TEE 上运行智能合约</li><li>对 TEE 上的智能合约进行优化</li></ul><p><del>我做的：在 Tee 上 运行 Wasm 实现的智能合约，并优化</del></p><p>如果我要自己实现把 Wamr 迁移到 TrustZone OP-TEE 的 TEE上的话，最关键还是得学 OP-TEE 的架构</p><p>又看了看论文（WATZ 和 TWINE），发现……作用有限……</p><p>论文里只写个大概轮廓，代码细节几乎找不见，直接看源码也一头雾水，怎么跑起来的这是……</p><hr><p>要有一个看得见的东西，</p><p>数字身份</p><p>Intel SGX，</p><p>基于可信执行环境的区块链数字身份</p><p>题目：基于 TrustZone 的元宇宙分布式数字身份系统研究与实现</p><p>研究内容：</p><ul><li>TrustZone<ul><li>软件：OP-TEE</li><li>硬件：Raspberry Pi 3B+</li></ul></li><li>分布式数字身份<ul><li>区块链平台</li><li>智能合约</li><li>元宇宙数字身份（W3C-DID）</li></ul></li><li>WebAssembly<ul><li>在 TrustZone 中运行 WebAssembly 实现的智能合约</li></ul></li></ul><p>应用场景：</p><p>元宇宙作为背景，电影院作为应用场景，TrustZone 引入安全</p><h3 id="研究方向">研究方向</h3><p>本课题的研究方向集中在基于可信执行环境（Trusted ExecutionEnvironment，TEE）和区块链技术的分布式数字身份系统设计与实现。随着元宇宙技术的迅速发展，用户在虚拟空间中的身份管理和认证问题日益凸显。现有的数字身份管理系统大多依赖于中心化的认证模式，容易面临数据泄露和隐私侵害等问题。分布式数字身份（DecentralizedIdentity，DID）作为一种去中心化的身份管理方案，能够在不依赖第三方机构的情况下，实现用户身份的自主认证与控制。TrustZone技术提供了隔离的安全环境，通过与分布式数字身份相结合，可以为元宇宙用户提供更安全、可信的身份管理机制。</p><p>本研究方向结合可信计算、区块链、智能合约与 WebAssembly等前沿技术，旨在探索如何在 TrustZone 架构中实现基于 WebAssembly的智能合约执行环境，并为分布式数字身份系统提供解决方案。该研究有望为元宇宙用户身份管理提供新的技术方案，推动去中心化身份认证在元宇宙中的应用落地。</p><h3 id="课题简介">课题简介</h3><p>随着元宇宙的迅猛发展，用户在虚拟世界中的身份管理和隐私保护问题成为亟待解决的挑战。传统的身份认证系统大多依赖于中心化服务器，存在单点故障风险，且用户的隐私数据易被不当获取和滥用。为了解决这一问题，分布式数字身份（DecentralizedIdentity，DID）系统应运而生，它利用区块链的去中心化特性，实现了用户对自己身份信息的自主控制。然而，如何在保证身份安全性和隐私保护的同时，提升元宇宙中的身份管理和认证效率，是当前面临的一大挑战。</p><p>本课题将基于 ARM TrustZone 可信执行环境（Trusted ExecutionEnvironment，TEE）设计并实现一个适用于元宇宙的分布式数字身份系统。具体而言，本研究将利用一个可信执行环境框架（如OP-TEE）在 Raspberry Pi 3B+或华为鲲鹏开发板等硬件平台上搭建安全环境，并在该环境中运行基于WebAssembly 的智能合约，实现数字身份的创建、认证和验证过程。TrustZone提供的隔离环境能够确保用户身份数据的安全性，同时通过区块链平台实现身份信息的去中心化存储和验证，从而防止未经授权的访问与篡改。WebAssembly作为智能合约的执行环境，运行在 TrustZone 的安全世界中。通过将WebAssembly与智能合约结合，在保证执行效率的同时，提升灵活性与可移植性。此外，课题将引入W3C提出的去中心化身份标准（W3C-DID），确保用户在元宇宙中的身份符合国际标准，具备兼容性和扩展性。</p><p>本课题的预期成果包括一个在 TrustZone中运行的分布式数字身份原型系统。该系统将展示如何在可信执行环境中保障数字身份的安全性，并通过区块链实现去中心化管理，为元宇宙中的身份认证提供了一种全新的安全方案。此外，课题还将实现一个基于分布式数字身份的应用场景原型，例如一个基于分布式数字身份的虚拟电影院系统，用户可以通过其去中心化的数字身份进行购票、进行身份验证等操作。该应用场景将进一步验证本课题系统的实际可用性和拓展性。此研究不仅具备学术价值，还将在未来的元宇宙应用场景中具有广泛的应用前景。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;看完了 《WebAssembly原理与核心技术》，重新审视一下原来的目标。&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://cishoon.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="毕设" scheme="http://cishoon.top/tags/%E6%AF%95%E8%AE%BE/"/>
    
    <category term="op-tee" scheme="http://cishoon.top/tags/op-tee/"/>
    
    <category term="TrustZone" scheme="http://cishoon.top/tags/TrustZone/"/>
    
    <category term="QEMU" scheme="http://cishoon.top/tags/QEMU/"/>
    
    <category term="TSC-VEE" scheme="http://cishoon.top/tags/TSC-VEE/"/>
    
  </entry>
  
  <entry>
    <title>WASM 学习</title>
    <link href="http://cishoon.top/blockchain/WASM/"/>
    <id>http://cishoon.top/blockchain/WASM/</id>
    <published>2024-10-03T16:00:00.000Z</published>
    <updated>2024-10-08T05:31:09.597Z</updated>
    
    <content type="html"><![CDATA[<p>我的 <span class="exturl" data-url="aHR0cHM6Ly9jaXNob29uLmdpdGh1Yi5pby9ncmFkdWF0aW9uLXByb2plY3QvMDMv">毕设03<i class="fa fa-external-link-alt"></i></span>帖子已经写了一个 Wasm 的简述，但是那篇文章还是聚焦于 Wasm 在 Web中的使用。</p><p>实际上，我更加关注的点应该在于，Wasm如何应用在区块链、嵌入式系统里。</p><span id="more"></span><p>Wasm更大的优势，并不是在于它的速度。如果纯粹为了比速度，那为什么不用原生的C/C++/Rust ，他们也编译成二进制文件，直接运行，多快。</p><p>Wasm 应该对比的就不是 Js （虽然他是为了解决 Js的性能问题而诞生的）。</p><blockquote><p>“如果 <code>WebAssembly（Wasm）</code>在几年前出现，<code>Docker</code>可能就不会出现了。因为它是一项非常强大的跨平台技术，可以让我们使用不同的编程语言来编写跨平台应用程序。<code>Docker</code>的原始动力之一就是提供一个跨平台部署和应用的方法。” --<code>Solomon Hykes</code>。</p><p>如果 <code>Wasm</code> 早在几年前问世，就可能成为一种替代<code>Docker</code>的技术，让跨平台部署和应用程序更加容易实现，运行更加流畅。</p><p>https://developer.aliyun.com/article/1261397</p></blockquote><h1 id="wasm-的优势">Wasm 的优势</h1><ul><li><p>跨平台性好</p><p>因为 Wasm是低级字节码格式，它可以在任何操作系统和编程语言上运行。因此，Wasm可以被看作是一种跨平台的计算单元，可以消除由于平台、语言和工具的差异而引起的一些问题。</p></li><li><p>安全性</p><p>Wasm 外有一个额外的虚拟层，不能直接操作系统 API 。</p></li><li><p>资源占用少</p><p><code>Wasm</code>是一种非常轻量级的技术，它的内存占用量和运行时开销都非常小。在 Web上，意味着更快的加载速度；在嵌入式中，意味着可以在更边缘的芯片上运行。</p></li><li><p>执行效率高</p><p>Wasm使用基于栈的虚拟机，可以避免一些性能问题，它更接近于原生代码，这使得执行效率相对而言可以更高。</p></li></ul><p>wasm的高性能，只是相对于js而言的。和原生的c程序、c++、rust程序相比，wasm并不一定有更高的性能。但是wasm的优势在于他的可移植性，沙箱化带来的安全性等。</p><h1 id="概念辨析">概念辨析</h1><h2 id="wasi">WASI</h2><p>2020年，WASI（WebAssembly System Interface）正式发布。这是一种标准化接口规范，旨在提供与操作系统无关的底层 API。</p><p>讲的太好了：https://zhuanlan.zhihu.com/p/61423010</p><p>传统的可移植性：一份代码，通过设置不同的编译目标，得到可以在不同平台上运行的可执行文件。</p><p>WASI的可移植性：一份代码，编译出一个WASM字节码，送给各个不通平台上的WASM运行时环境。</p><figure><img src="/blockchain/WASM/image-20241005010128951.png" alt="image-20241005010128951"><figcaption aria-hidden="true">image-20241005010128951</figcaption></figure><figure><img src="/blockchain/WASM/image-20241005010111769.png" alt="image-20241005010111769"><figcaption aria-hidden="true">image-20241005010111769</figcaption></figure><p>WASI 的目标是让 WebAssembly能够真正成为一种普适的、跨平台的二进制格式，不仅限于浏览器应用，而是在服务器端、嵌入式系统、甚至操作系统内核中都能发挥作用。</p><p>我觉得WASI有点像Java虚拟机的感觉。对java来说，就是只用编译一个jar包，在各个平台上都可以运行。</p><p>最主要的区别在于，JVM 提供了更复杂庞大的功能（例如垃圾回收），而 WASI更轻量，只解决 WASM 无法和系统交互的问题。</p><h2 id="wat-webassembly-text-format">WAT (WebAssembly Text Format)</h2><p>Wasm 的文本表现形式。Wasm是二进制文件，不便于阅读。可以转换成方便阅读的 WAT。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(module</span><br><span class="line">  (func $addTwo (param $x i32) (result i32)</span><br><span class="line">    get_local $x</span><br><span class="line">    i32.const 2</span><br><span class="line">    i32.add))</span><br></pre></td></tr></table></figure><p>有点像机器码和汇编代码的关系。</p><h1 id="wamr">WAMR</h1><p>一个 Wasm 运行时的轻量化实现，适合集成到嵌入式设备。</p><h1 id="wasm-的工作原理">WASM 的工作原理</h1><p>《WebAssembly原理与核心技术》</p><h1 id="参考资料">参考资料</h1><p>https://www.infoq.cn/article/72uz19s34UoK236YZaYM</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我的 &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9jaXNob29uLmdpdGh1Yi5pby9ncmFkdWF0aW9uLXByb2plY3QvMDMv&quot;&gt;毕设03&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;
帖子已经写了一个 Wasm 的简述，但是那篇文章还是聚焦于 Wasm 在 Web
中的使用。&lt;/p&gt;
&lt;p&gt;实际上，我更加关注的点应该在于，Wasm
如何应用在区块链、嵌入式系统里。&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://cishoon.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="WebAssembly" scheme="http://cishoon.top/tags/WebAssembly/"/>
    
    <category term="WASM" scheme="http://cishoon.top/tags/WASM/"/>
    
  </entry>
  
  <entry>
    <title>毕设03 - WebAssembly（WASM）简述</title>
    <link href="http://cishoon.top/graduation-project/03/"/>
    <id>http://cishoon.top/graduation-project/03/</id>
    <published>2024-09-30T16:00:00.000Z</published>
    <updated>2024-10-04T16:30:46.393Z</updated>
    
    <content type="html"><![CDATA[<p>TSC-VEE 的 github 仓库中，没有提供 TA 的实现。</p><p>他的README里说，<code>tsc-vee</code> 这个目录里的就是 TA，但是里面完全不是 TA 的结构，找不到 <code>ta</code> <code>host</code>，甚至没有 <code>UUID</code> 。按照 README提供的运行方法，也无法编译运行。</p><p>而且，<code>on REE</code> 和 <code>tsc-vee</code>两个目录里的内容完全一致。想必是上传的时候传错文件了。</p><p>所以今天来看 WASM。一个是为毕设准备，同时也是为组里另一个项目准备。</p><blockquote><p>已经发邮件给一作和导师了，老师回复非常迅速，学长立刻附上了<code>tsc-vee</code>的关键代码！！非常感谢老师和学长对科研小白的包容！！再次感谢！！</p></blockquote><span id="more"></span><h1 id="webassemblywasm简述">1 WebAssembly（WASM）简述</h1><blockquote><p>参考内容：https://www.cnblogs.com/detectiveHLH/p/9928915.html</p></blockquote><h2 id="诞生目的">1.1 诞生目的</h2><p>解决 Js 的性能瓶颈。</p><figure><img src="/graduation-project/03/image-20241001220144976.png" alt="image-20241001220144976"><figcaption aria-hidden="true">image-20241001220144976</figcaption></figure><p>Js 代码执行流程：</p><ol type="1"><li>载入源码</li><li>解析成 AST （抽象语法树）</li><li>编译成字节码</li><li>翻译成机器码</li></ol><p>其中使用到了 JIT (Just in Time)来检测热点代码，加入缓存以优化翻译次数。</p><p>但是，由于 Js的动态变量类型，同一个函数中的变量类型不确定，导致翻译出的机器码也不确定。引擎的优化就失去了作用。</p><p>为了解决这个问题，出现了 <code>asm.js</code> 。作为一个 Js的严格子集，所有 <code>asm.js</code> 的代码都是合法的 Js代码，但是是通过一些诡异的手段，限制函数里面的变量值类型确定。例如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">asmJs</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="string">'use asm'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> myInt = <span class="number">0</span> | <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> myDouble = +<span class="number">1.1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><code>0 | 0</code> 一定是 int ，<code>+1.1</code> 一定是 double。</p><p>但是这还有一些问题：</p><ul><li>写起来非常不优雅，太难看了</li><li>只解决了 JIT 部分的加速，然而最慢的部分是 Js代码的语法解析和字节码编译。</li></ul><p>于是，提出了 WebAssembly</p><h2 id="wasm-的优势">1.2 WASM 的优势</h2><p>WASM 是编译器编译之后的中间代码，也就是可以直接从上面的<em>第4步-翻译成机器码</em> 开始执行。</p><p>WASM编译得到的代码体积小，速度快，强制的强静态类型，有沙盒化的执行环境。可以直接由C/C++/Rust 编译得到。</p><p>简言之：</p><ul><li><strong>执行效率</strong>：Web程序里可以直接调用由 C/C++/Rust编写的函数，这大大提高了Web项目的执行效率。测试表明，基本上可以优化至原速度的2 倍，最高甚至可以达到 6 倍。</li><li><strong>移植性</strong>：一些原先由 C/C++/Rust编写、有高性能需求的项目，例如 Unity、Unreal 游戏引擎、谷歌地球等，可以直接将原来的项目编译成 WASM，移植到 Web 上。</li></ul><h2 id="如何使用-wasm">1.3 如何使用 WASM</h2><p>开发工具：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Fzc2VtYmx5U2NyaXB0L2Fzc2VtYmx5c2NyaXB0">AssemblyScript<i class="fa fa-external-link-alt"></i></span>。支持直接将TypeScript 编译成 WebAssembly。</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tyaXBrZW4vZW1zY3JpcHRlbg==">Emscripten<i class="fa fa-external-link-alt"></i></span>。可以将C/C++/Rust 等高级语言编译成 WebAssembly</li></ul><p>流程：</p><ol type="1"><li><p>编写 C/C++/Rust 的原生函数</p><p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> {</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li><li><p>编译成 wasm</p><p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">emcc test.c -Os -s WASM=1 -s SIDE_MODULE=1 -o test.wasm</span><br></pre></td></tr></table></figure></p></li><li><p>在 Node 中调用</p><p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> src = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(fs.<span class="title function_">readFileSync</span>(<span class="string">'./test.wasm'</span>));</span><br><span class="line"><span class="keyword">const</span> env = {</span><br><span class="line"><span class="attr">memoryBase</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">tableBase</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">memory</span>: <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Memory</span>({</span><br><span class="line"><span class="attr">initial</span>: <span class="number">256</span></span><br><span class="line">}),</span><br><span class="line"><span class="attr">table</span>: <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Table</span>({</span><br><span class="line"><span class="attr">initial</span>: <span class="number">2</span>,</span><br><span class="line"><span class="attr">element</span>: <span class="string">'anyfunc'</span></span><br><span class="line">}),</span><br><span class="line"><span class="attr">abort</span>: <span class="function">() =&gt;</span> {<span class="keyword">throw</span> <span class="string">'abort'</span>;}</span><br><span class="line">}</span><br><span class="line"><span class="title class_">WebAssembly</span>.<span class="title function_">instantiate</span>(src, {<span class="attr">env</span>: env})</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> {</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">instance</span>.<span class="property">exports</span>.<span class="title function_">_add</span>(<span class="number">20</span>, <span class="number">89</span>));</span><br><span class="line">})</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e));</span><br></pre></td></tr></table></figure></p></li></ol><h1 id="附录">附录</h1><h2 id="node.js-与-v8">Node.js 与 V8</h2><p>Node.js 和 V8 之间的关系密切，Node.js 是一个基于 V8引擎构建的服务器端 JavaScript 运行时环境。</p><h3 id="v8-引擎">1. <strong>V8 引擎：</strong></h3><ul><li><strong>V8</strong> 是由 Google 开发的开源 JavaScript引擎，它主要用于 Chrome 浏览器中解释和执行 JavaScript 代码。V8 将JavaScript 编译为机器代码，从而提高了 JavaScript 的执行速度。</li><li>Node.js 使用 V8 作为其底层 JavaScript 引擎，这使得 Node.js能够在服务器端执行 JavaScript 代码，而不仅仅是在浏览器中使用。</li></ul><h3 id="node.js">2. <strong>Node.js：</strong></h3><ul><li><strong>Node.js</strong> 是一个开源、跨平台的运行时环境，它基于 V8引擎构建，旨在让开发者能够在服务器端使用 JavaScript编写高效的网络应用程序。Node.js提供了许多用于文件系统、网络、进程等操作的库，使得开发者无需依赖浏览器的API。</li><li>Node.js 的架构不仅仅是 JavaScript，它还包含了一些原生 C++代码，来提供底层系统操作能力，如文件操作、网络请求等。</li></ul><p>V8 引擎现在已经支持了 WebAssembly。</p><h2 id="其他资料">其他资料</h2><p>非常入门的博客：https://xie.infoq.cn/article/0bb5ff2fa5d5d9db492c88a4c</p><p>WebAssembly原理与核心技术：https://book.douban.com/subject/35233448/</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;TSC-VEE 的 github 仓库中，没有提供 TA 的实现。&lt;/p&gt;
&lt;p&gt;他的README里说，&lt;code&gt;tsc-vee&lt;/code&gt; 这个目录里的就是 TA
，但是里面完全不是 TA 的结构，找不到 &lt;code&gt;ta&lt;/code&gt; &lt;code&gt;host&lt;/code&gt;
，甚至没有 &lt;code&gt;UUID&lt;/code&gt; 。按照 README
提供的运行方法，也无法编译运行。&lt;/p&gt;
&lt;p&gt;而且，&lt;code&gt;on REE&lt;/code&gt; 和 &lt;code&gt;tsc-vee&lt;/code&gt;
两个目录里的内容完全一致。想必是上传的时候传错文件了。&lt;/p&gt;
&lt;p&gt;所以今天来看 WASM
。一个是为毕设准备，同时也是为组里另一个项目准备。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;已经发邮件给一作和导师了，老师回复非常迅速，学长立刻附上了
&lt;code&gt;tsc-vee&lt;/code&gt;
的关键代码！！非常感谢老师和学长对科研小白的包容！！再次感谢！！&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://cishoon.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="毕设" scheme="http://cishoon.top/tags/%E6%AF%95%E8%AE%BE/"/>
    
    <category term="WASM" scheme="http://cishoon.top/tags/WASM/"/>
    
  </entry>
  
  <entry>
    <title>毕设02 - OP-TEE，Hello World</title>
    <link href="http://cishoon.top/graduation-project/02/"/>
    <id>http://cishoon.top/graduation-project/02/</id>
    <published>2024-09-27T16:00:00.000Z</published>
    <updated>2024-10-26T07:39:04.692Z</updated>
    
    <content type="html"><![CDATA[<p>昨天配了一天环境，今天先解决昨天遗留的问题：</p><ul><li>dbus-launch gnome-terminal 是什么指令？</li><li>optee 怎么启动？</li></ul><span id="more"></span><h1 id="dbus-launch-gnome-terminal">1 dbus-launch gnome-terminal</h1><ol type="1"><li><p><code>dbus-launch</code>: <code>dbus-launch</code> 是一个用于启动D-Bus 会话总线的命令。D-Bus 是 Linux系统中进程间通信（IPC）的系统，它允许不同的应用程序彼此之间进行通信。使用<code>dbus-launch</code> 可以确保应用程序运行在一个有 D-Bus支持的环境中，特别是在图形用户界面中。如果你的桌面会话中 D-Bus没有正确启动，某些需要 D-Bus 通信的程序可能无法正常工作。</p></li><li><p><code>gnome-terminal</code>: 这是启动 GNOME 终端的命令，GNOME终端是 Linux 上 GNOME 桌面环境中的默认终端模拟器。</p></li></ol><p>结合起来，<code>dbus-launch gnome-terminal</code> 的作用是： -启动一个带有 D-Bus 会话总线支持的 GNOME 终端。换句话说，它确保 GNOME终端启动时可以正常使用 D-Bus 的功能。</p><p>通常情况下，D-Bus 会在桌面环境启动时自动启动，因此用户不需要手动运行<code>dbus-launch</code>。但在某些特殊情况下，例如在没有图形会话或远程会话中，<code>dbus-launch</code>可以用来手动启动一个 D-Bus 实例以支持某些应用程序的运行。</p><h1 id="启动optee">2 启动optee</h1><p>注意，optee同时只能启动一次，可能是因为会监听相同的端口。</p><h2 id="直接在虚拟机中操作">2.1 直接在虚拟机中操作</h2><ol type="1"><li>打开控制台，输入<code>dbus-launch gnome-terminal</code>，会打开一个新的控制台</li><li>在新的控制台里，进入 <code>/root/optee/build</code> （你的<code>optee</code> 安装路径），执行 <code>make run-only</code><code>make run</code> 会执行所有编译和检查，比较慢；安装成功后直接执行<code>make run-only</code> 更快。</li></ol><h2 id="通过ssh连接远程操作">2.2 通过ssh连接远程操作</h2><p>我使用的是mac。</p><h3 id="方法一xquartz">方法一：XQuartz</h3><ol type="1"><li><p>安装 XQuartz，在官网下载最新版直接安装。</p></li><li><p>启动 XQuartz，在偏好里设置”允许从网络客户端连接“</p><p><img src="/graduation-project/02/image-20240928105303669.png" alt="image-20240928105303669" style="zoom:50%;"></p></li><li><p>在终端输入 <code>dbus-launch gnome-terminal</code>，会在 XQuartz里打开一个控制台：</p><p><img src="/graduation-project/02/image-20240928110041269.png" alt="image-20240928110041269" style="zoom: 33%;"></p><blockquote><p>使用 <code>dbus-launch</code>还可以启动很多东西，甚至是浏览器，<del>虽然会很卡</del>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> XAUTHORITY=<span class="variable">$HOME</span>/.Xauthority <span class="comment"># 如果报错设置这个环境变量</span></span><br><span class="line">dbus-launch firefox</span><br></pre></td></tr></table></figure><figure><img src="/graduation-project/02/image-20240928110909695.png" alt="image-20240928110909695"><figcaption aria-hidden="true">image-20240928110909695</figcaption></figure></blockquote></li><li><p>在这个控制台里，进入 <code>/root/optee/build</code> （你的<code>optee</code> 安装路径），执行 <code>make run-only</code></p><p><img src="/graduation-project/02/image-20240928113548477.png" alt="image-20240928113548477" style="zoom: 33%;"></p></li><li><p>(第三步好像可以)</p></li></ol><h3 id="方法二tmux推荐">方法二：tmux（推荐）</h3><ol type="1"><li><p>安装 <code>tmux</code></p><p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install tmux</span><br></pre></td></tr></table></figure></p></li><li><p>启动 <code>tmux</code></p></li><li><p>进入 <code>/root/optee/build</code> （你的 <code>optee</code>安装路径），执行 <code>make run-only</code></p><p><img src="/graduation-project/02/image-20240928114747520.png" alt="image-20240928114747520" style="zoom: 33%;"></p></li><li><p>使用 <code>tmux</code>的命令切换窗口，查看安全世界和普通世界。例如<code>ctrl + b, w</code></p><p><img src="/graduation-project/02/image-20240928114851423.png" alt="image-20240928114851423" style="zoom:33%;"></p></li></ol><blockquote><p>Tmux 使用教程：https://www.ruanyifeng.com/blog/2019/10/tmux.html</p></blockquote><p>方法二不需要传输图形界面，会流畅很多，而且最通用。</p><h1 id="运行测试">3 运行测试</h1><p>在 QEMU Monitor 界面输入 <code>'c'</code>并按下回车来继续执行虚拟机。</p><p>此时进入 Normal World 终端，会发现虚拟机已经开始执行：</p><figure><img src="/graduation-project/02/image-20240928151826867.png" alt="image-20240928151826867"><figcaption aria-hidden="true">image-20240928151826867</figcaption></figure><h2 id="buildroot">3.1 Buildroot</h2><p>系统输出这段话：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Welcome to Buildroot,type root or test to login</span><br><span class="line">buildroot login:</span><br></pre></td></tr></table></figure><ul><li><p><strong>什么是 Buildroot？</strong></p><p>*Buildroot** 是一个构建嵌入式 Linux系统的工具，用于生成小型且高度定制化的 Linux操作系统。它通常被用于嵌入式设备，如路由器、IoT 设备等。</p><p>在 OP-TEE 的虚拟机环境中，Buildroot 被用来创建 Normal World 的 Linux环境。这个环境足够轻量级，用于执行测试、运行基本应用，并和 OP-TEE 的Secure World 交互。</p></li><li><p><strong><code>root</code> 和 <code>test</code>的区别</strong></p><p>在登录提示下，系统提供了两个账户选项：</p><ul><li><p><strong>root</strong>：这是系统的超级用户（管理员）。使用<code>root</code>登录后，你拥有对系统的完全控制权限，可以执行所有操作，包括安装软件、修改系统配置、启动或关闭服务等。一般来说，默认的登录密码可能为空，或者会在相关的文档中提到。</p></li><li><p><strong>test</strong>：这是一个普通用户账户，用于测试目的。使用<code>test</code>登录后，你可能只能执行一些受限的操作，比如运行特定的应用程序或脚本，但没有修改系统配置或执行管理员任务的权限。</p></li></ul></li></ul><h2 id="xtest">3.2 xtest</h2><p><code>xtest</code> 是 OP-TEE 提供的一个测试工具，用于验证 OP-TEE系统和其功能是否正确工作。它是 OP-TEE 项目的一部分，能够在 OP-TEE SecureWorld 和 Normal World 之间执行一系列的集成测试。这些测试涵盖了许多OP-TEE的核心功能，包括加密操作、密钥管理、身份认证、文件系统操作、以及与普通世界的交互。</p><p>以 root 身份登录，运行 <code>xtest</code>。</p><p>没有任何报错。</p><h2 id="运行hello-world">3.3 运行hello world</h2><p>直接运行 <code>optee_example_hello_world</code> 。这个程序在<code>make run</code> 的时候就写入操作系统了。</p><p>编译得到的 CA 在 <code>/usr/bin</code> ，TA 在<code>/lib/optee_armtz</code> 中。</p><h1 id="ta文件结构">4 TA文件结构</h1><blockquote><p>参考博客：https://kickstartembedded.com/2022/11/13/op-tee-part-4-writing-your-first-trusted-application</p></blockquote><p><code>optee_example</code> 中提供了一个 <code>hello_world</code>文件夹 ，结构如下：</p><p><img src="/graduation-project/02/image-20240930212609062.png" alt="image-20240930212609062" style="zoom:50%;"></p><p>可以被清晰的分为三个部分：</p><ol type="1"><li>主机部分：<code>host/</code> 文件夹</li><li>可信部分：<code>ta/</code> 文件夹</li><li>高层构建 Helper</li></ol><h2 id="主机部分">3.1 主机部分</h2><p>主机部分是运行在 <strong>Normal World</strong>中的代码。构建过程的一个输出是 <code>libteec.so</code>文件，它必须与主机部分链接。主机部分的整体流程大致如下所示。</p><p><img src="/graduation-project/02/image-20240930213254910.png" alt="image-20240930213254910" style="zoom:50%;"></p><h2 id="可信部分">3.2 可信部分</h2><p>可信部分是在 <strong>Secure World</strong>中运行的代码。可信部分的总体结构如下所示。注意，各种函数实际上是主机部分启动的事件的回调函数，例如上下文初始化和结束，会话打开和关闭等。</p><p><img src="/graduation-project/02/image-20240930213634738.png" alt="image-20240930213634738" style="zoom:50%;"></p><p>注意到主机部分的函数前缀是 <code>TEEC_</code>，可信部分前缀是<code>TA_</code>。</p><h2 id="高层构建助手">3.3 高层构建助手</h2><p>构建助手是 <code>Makefiles</code> 和与 <code>cmake</code>相关的文件，它们将帮助我们正确构建 TA。</p><p>Linaro提供的示例最好的特性之一是，用户可以简单地将自己的示例应用程序添加到这个repo中，如果文件夹结构保持正确，您的应用程序将被构建为默认示例!</p><p>一定要探索构建助手文件，亲自查看实现!</p><h1 id="修改hello-world">5 修改Hello World</h1><p>我们将基于 Linaro 提供的 <code>hello_world</code>应用程序编写一个修改版本。更重要的是，我们将使其完全与提供的示例分离，而不是直接修改源代码。这将帮助我们更好地理解哪些组件是重要的。</p><h2 id="主机部分修改">5.1 主机部分修改</h2><ol type="1"><li><strong>修改 <code>host/Makefile</code> 文件</strong>：<ul><li>修改 <code>Makefile</code> 文件中的 <code>BINARY</code>变量的值。将其命名为 <code>optee_example_ke_hello_world</code> 。</li></ul></li><li><strong>修改 <code>host/main.c</code> 和<code>ta/include/ke_hello_world_ta.h</code> 文件</strong>：<ul><li>将名为 <code>hello_world_ta.h</code> 的包含文件名更改为<code>ke_hello_world_ta.h</code> 。这意味着你需要在代码中找到所有引用<code>hello_world_ta.h</code> 的地方，并将其更改为<code>ke_hello_world_ta.h</code> 。</li><li>将 <code>UUID</code> 变量的值更改为<code>TA_KE_HELLO_WORLD_UUID</code> 。这意味着你需要在<code>ta/include/ke_hello_world_ta.h</code> 中定义一个新的宏<code>TA_KE_HELLO_WORLD_UUID</code>，这个宏将代表新应用的唯一标识符。</li><li>在 <code>TEEC_InvokeCommand(...)</code> 函数调用中，将命令值更改为<code>TA_KE_HELLO_WORLD_INC_VALUE</code> 。</li></ul></li></ol><h2 id="可信部分修改">5.2 可信部分修改</h2><ol type="1"><li><strong>ta/Android.mk</strong> - 将 <code>local_module</code>变量的值替换为从可信网站生成的新版本4 UUID。</li><li><strong>ta/user_ta_header_defines.h</strong> - 将包含的文件更改为<code>ke_hello_world_ta.h</code>。</li><li><strong>ta/user_ta_header_defines.h</strong> - 将名为<code>TA_UUID</code> 的宏的值更改为<code>TA_KE_HELLO_WORLD_UUID</code>。</li><li><strong>ta/user_ta_header_defines.h</strong> - 在<code>TA_CURRENT_TA_EXT_PROPERTIES</code> 宏中，将<code>hello_world</code> 的所有出现更改为<code>ke_hello_world</code>。</li><li><strong>ta/sub.mk</strong> - 将 <code>srcs-y</code>变量中的文件替换为 <code>ke_hello_world_ta.c</code>。</li><li><strong>ta/Makefile</strong> - 将我们在 <code>ta/Android.mk</code>中粘贴的版本4 UUID粘贴到 <code>BINARY</code> 变量的值中。</li><li><strong>ta/ke_hello_world_ta.c</strong> - 将<code>hello_world_ta.c</code> 重命名为<code>ke_hello_world_ta.c</code>，并在其中将包含的文件名称更改为<code>ke_hello_world_ta.h</code>。</li><li><strong>ta/ke_hello_world_ta.c</strong> - 在名为<code>TA_InvokeCommandEntryPoint(...)</code>的函数中，更改开关案例以反映带有 <code>KE_HELLO_WORLD_*</code> 而不是<code>HELLO_WORLD_*</code> 的宏。</li><li><strong>ta/include/ke_hello_world_ta.h</strong> - 将<code>hello_world_ta.h</code> 重命名为<code>ke_hello_world_ta.h</code>，并在其中将定义的宏更改为<code>TA_KE_HELLO_WORLD_UUID</code>。同时，将此宏的值更改为我们上面使用的版本4UUID。</li><li><strong>ta/include/ke_hello_world_ta.h</strong> -将函数ID宏的值更改为使用 <code>KE_HELLO_WORLD_*</code> 而不是<code>HELLO_WORLD_*</code>。</li></ol><h2 id="高层构建助手修改">5.3 高层构建助手修改</h2><ul><li><strong>CMakeLists.txt</strong> -需要将CMake项目的名称更改为<code>optee_example_ke_hello_world</code>。</li><li><strong>Android.mk</strong> -需要将<code>LOCAL_MODULE</code>变量的值更改为<code>optee_example_ke_hello_world</code>。</li></ul><h2 id="修改总结">5.4 修改总结</h2><ul><li>生成UUID（直接使用 Linux 命令 <code>uuidgen</code>）替换所有原来的UUID</li><li>把所有 <code>hello_world</code> 改成<code>ke_hello_world</code></li></ul><h2 id="编译">5.5 编译</h2><p>直接回到 <code>build</code> 目录，运行 <code>make run</code>。</p><p>就会自动把刚刚的 Hello World 编译到 OP-TEE 里。</p><p>如何单独编译一个TA，之后再看……明天开始阅读 TSC-VEE</p><p>看到 TSC-VEE 的文档里，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For QEMU v8:</span><br><span class="line"></span><br><span class="line">Place the trust applications(TAs) in the optee-examples/ folder</span><br><span class="line">Execute make run in the build folder</span><br><span class="line">Run the TA.</span><br></pre></td></tr></table></figure><p>说明就是这么运行的2333</p><h1 id="附录">附录</h1><h2 id="交叉编译">交叉编译</h2><p>与交叉编译相对的改变是本地编译。</p><p>本地编译就是编译出的代码只能在我本地运行，交叉编译就是在一个平台上生成可以在另一个平台运行的代码。</p><p>本文提到的所有交叉编译，就是在Linux中编译可以在嵌入式环境中运行的可执行文件。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;昨天配了一天环境，今天先解决昨天遗留的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dbus-launch gnome-terminal 是什么指令？&lt;/li&gt;
&lt;li&gt;optee 怎么启动？&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://cishoon.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="毕设" scheme="http://cishoon.top/tags/%E6%AF%95%E8%AE%BE/"/>
    
    <category term="op-tee" scheme="http://cishoon.top/tags/op-tee/"/>
    
    <category term="TrustZone" scheme="http://cishoon.top/tags/TrustZone/"/>
    
    <category term="QEMU" scheme="http://cishoon.top/tags/QEMU/"/>
    
  </entry>
  
  <entry>
    <title>毕设01 - 安装QEMU和OP-TEE环境</title>
    <link href="http://cishoon.top/graduation-project/01/"/>
    <id>http://cishoon.top/graduation-project/01/</id>
    <published>2024-09-26T16:00:00.000Z</published>
    <updated>2024-11-16T07:44:54.951Z</updated>
    
    <content type="html"><![CDATA[<p>前置任务，安装ubuntu22.04虚拟机，以及必要的环境。</p><p>官方文档提供了教程：https://optee.readthedocs.io/en/latest/building/devices/qemu.html#qemu-v8</p><span id="more"></span><p><strong>注意不要有中文路径！！</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> optee</span><br><span class="line">$ <span class="built_in">cd</span> optee</span><br><span class="line">$ repo init -u https://github.com/OP-TEE/manifest.git -m qemu_v8.xml</span><br><span class="line">$ repo <span class="built_in">sync</span></span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ make toolchains</span><br><span class="line">$ make run </span><br></pre></td></tr></table></figure><p>但是 <code>repo</code> 会连接不上服务器，改成清华源。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo init -u https://github.com/OP-TEE/manifest.git -m qemu_v8.xml --repo-url=https://mirrors.tuna.tsinghua.edu.cn/git/git-repo</span><br></pre></td></tr></table></figure><p>下载速度太慢，在 <code>~/.bashrc</code> 配置一下代理</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=192.168.3.56:10809</span><br><span class="line"><span class="built_in">export</span> https_proxy=192.168.3.56:10809</span><br><span class="line"><span class="built_in">export</span> ftp_proxy=192.168.3.56:10808</span><br><span class="line"><span class="built_in">export</span> socks_proxy=192.168.3.56:10808</span><br><span class="line"><span class="built_in">export</span> no_proxy=<span class="string">"localhost,127.0.0.1"</span></span><br></pre></td></tr></table></figure><p>发现 ping 不通谷歌，是因为 ping 走的是 ICMP 协议，不走代理。用 curl来检查。</p><p>如果发现 <code>apt</code> 用不了了，输入：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> -n ftp_proxy </span><br><span class="line"><span class="built_in">export</span> -n http_proxy</span><br><span class="line"><span class="built_in">export</span> -n https_proxy </span><br><span class="line"><span class="built_in">export</span> -n socks_proxy</span><br></pre></td></tr></table></figure><p>git 配置：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy http://192.168.3.56:21882</span><br></pre></td></tr></table></figure><p>docker 配置：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /etc/systemd/system/docker.service.d</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch /etc/systemd/system/docker.service.d/http-proxy.conf</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/systemd/system/docker.service.d/http-proxy.conf</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment="HTTP_PROXY=http://192.168.3.56:21882"</span><br><span class="line">Environment="HTTPS_PROXY=http://192.168.3.56:21882"</span><br><span class="line">Environment="NO_PROXY=localhost,127.0.0.1,.example.com"</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>中间遇到报错，看缺什么包就安什么包。</p><p>记录几个不好解决的：</p><p>提示需要设置参数 <code>FORCE_UNSAFE_CONFIGURE=1</code></p><p>修改指令为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make run FORCE_UNSAFE_CONFIGURE=1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">configure: error: winscard.h is required for pcsc</span><br></pre></td></tr></table></figure><p>需要先安装必要的包，然后手动设置：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> C_INCLUDE_PATH=/usr/include/PCSC:<span class="variable">$C_INCLUDE_PATH</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  File "/home/cishoon/桌面/optee/out-br/build/host-python3-3.11.8/./setup.py", line 1450, in detect_ctypes</span><br><span class="line">    print('Header file {} does not exist'.format(ffi_h))</span><br><span class="line">UnicodeEncodeError: 'utf-8' codec can't encode character '\udce6' in position 27: surrogates not allowed</span><br></pre></td></tr></table></figure><p>是因为ubuntu系统是中文的，我的路径放在桌面上，桌面是中文文件夹。不能在有中文文件夹路径里安装。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*** WARNING: renaming "_ctypes" since importing it failed: /home/cishoon/桌面/optee/out-br/build/host-python3-3.11.8/build/lib.linux-x86_64-3.11/_ctypes.cpython-311-x86_64-linux-gnu.so: undefined symbol: ffilibffi_type_void</span><br><span class="line"></span><br><span class="line">The necessary bits to build these optional modules were not found:</span><br><span class="line">_bz2                 _curses              _curses_panel     </span><br><span class="line">_dbm                 _gdbm                _lzma             </span><br><span class="line">_tkinter             nis                  readline          </span><br><span class="line">Compiling '/home/cishoon/桌面/optee/out-br/per-package/host-python3/host/lib/python3.11/warnings.py'...</span><br><span class="line">Compiling '/home/cishoon/桌面/optee/out-br/per-package/host-python3/host/lib/python3.11/wave.py'...</span><br><span class="line">To find the necessary bits, look in setup.py in detect_modules() for the module's name.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The following modules found by detect_modules() in setup.py have not</span><br><span class="line">been built, they are *disabled* by configure:</span><br><span class="line">_ctypes_test         _sqlite3             _testbuffer       </span><br><span class="line">_testcapi            _testclinic          _testimportmultiple</span><br><span class="line">_testinternalcapi    _testmultiphase      _xxtestfuzz       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Following modules built successfully but were removed because they could not be imported:</span><br><span class="line">_ctypes           </span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">File "/home/cishoon/桌面/optee/out-br/per-package/host-python-setuptools/host/lib/python3.11/site-packages/wheel/bdist_wheel.py", line 28, in &lt;module&gt;</span><br><span class="line">    from .macosx_libfile import calculate_macosx_platform_tag</span><br><span class="line">  File "/home/cishoon/桌面/optee/out-br/per-package/host-python-setuptools/host/lib/python3.11/site-packages/wheel/macosx_libfile.py", line 43, in &lt;module&gt;</span><br><span class="line">    import ctypes</span><br><span class="line">  File "/home/cishoon/桌面/optee/out-br/per-package/host-python-setuptools/host/lib/python3.11/ctypes/__init__.py", line 8, in &lt;module&gt;</span><br><span class="line">    from _ctypes import Union, Structure, Array</span><br><span class="line">ModuleNotFoundError: No module named '_ctypes'</span><br></pre></td></tr></table></figure><p>没有 <code>_ctypes</code> 包，原因是编译 <code>python</code>时没有找到 <code>libffi</code>，但是已经安装了 <code>libffi</code></p><p>是因为路径没有指定正确。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@cishoon-virtual-machine:out-br]# find /usr -name ffi.h</span><br><span class="line">/usr/include/x86_64-linux-gnu/ffi.h</span><br><span class="line">[root@cishoon-virtual-machine:out-br]# find /usr -name libffi.so</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libffi.so</span><br></pre></td></tr></table></figure><p>安装结束后报错：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* QEMU is now waiting to start the execution</span><br><span class="line">* Start execution with either a 'c' followed by &lt;enter&gt; in the QEMU console or</span><br><span class="line">* attach a debugger and continue from there.</span><br><span class="line">*</span><br><span class="line">* To run OP-TEE tests, use the xtest command in the 'Normal World' terminal</span><br><span class="line">* Enter 'xtest -h' for help.</span><br><span class="line"></span><br><span class="line"># 选项“-x”已弃用并可能在 gnome-terminal 的后续版本中移除。</span><br><span class="line"># 选项“-x”已弃用并可能在 gnome-terminal 的后续版本中移除。</span><br><span class="line"># 使用“-- ”以结束选项并将要执行的命令行追加至其后。</span><br><span class="line"># 使用“-- ”以结束选项并将要执行的命令行追加至其后。</span><br><span class="line"># 无法处理参数：无法打开显示：</span><br><span class="line"># 无法处理参数：无法打开显示：</span><br></pre></td></tr></table></figure><p>https://blog.csdn.net/Frinklin_wang/article/details/135404352</p><p>直接在虚拟机里执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dbus-launch gnome-terminal</span><br></pre></td></tr></table></figure><p>会创建一个新的终端窗口。</p><p>然后再在新窗口里执行 make run，完成后就会进入 QEMU 并自动打开secureworld和normal world</p><figure><img src="/graduation-project/01/image-20240928011246367.png" alt="image-20240928011246367"><figcaption aria-hidden="true">image-20240928011246367</figcaption></figure><p>明天先了解一下 dbus-launch gnome-terminal这些指令是啥意思，然后看看能不能ssh远程连接使用。</p><p>具体启动optee的流程看下一篇博客。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前置任务，安装ubuntu22.04虚拟机，以及必要的环境。&lt;/p&gt;
&lt;p&gt;官方文档提供了教程：https://optee.readthedocs.io/en/latest/building/devices/qemu.html#qemu-v8&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://cishoon.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="毕设" scheme="http://cishoon.top/tags/%E6%AF%95%E8%AE%BE/"/>
    
    <category term="op-tee" scheme="http://cishoon.top/tags/op-tee/"/>
    
    <category term="TrustZone" scheme="http://cishoon.top/tags/TrustZone/"/>
    
    <category term="QEMU" scheme="http://cishoon.top/tags/QEMU/"/>
    
  </entry>
  
  <entry>
    <title>Hyperledger Fabric 源码精读（3）</title>
    <link href="http://cishoon.top/fabric/fabric%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AF%BB%20(3)/"/>
    <id>http://cishoon.top/fabric/fabric%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AF%BB%20(3)/</id>
    <published>2024-09-15T16:00:00.000Z</published>
    <updated>2024-09-27T04:21:18.183Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>开坑，学习 Fabric 的源码。</p></li><li><p>思路是根据 <code>fabric-sample</code> 的<code>test-network</code>中的脚本，一行行分析。遇到里面使用的指令，看源码如何实现。</p></li><li><p>下面内容非常混乱，写的毫无逻辑，之后有空重新整理一遍。</p></li><li><p>一口气写完太长了，typora里会卡，分章节发。</p></li><li><p>学习笔记，不保证内容正确性。</p></li><li><p>因为台风改签明天了……再看一点</p></li></ul><span id="more"></span><h1 id="peer-node-start">3 peer node start</h1><p>有一个参数：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--peer-chaincodedev   start peer <span class="keyword">in</span> chaincode development mode</span><br></pre></td></tr></table></figure><p>最终执行的是 <code>internal/peer/node/start.go</code> 中的<code>serve()</code> 函数。非常长，挑重点的详细记录：</p><ol type="1"><li><p><code>viper</code> 获取所有参数，输出所有环境变量</p></li><li><p>检查 MSP 类型，仅支持 <code>FABRIC</code> 模式</p></li><li><p><code>grpc.EnableTracing = true</code>（效果类似于，每次发送请求都会在控制台输出请求信息）</p></li><li><p>获取核心配置</p></li><li><p>创建平台注册凭证</p></li><li><p>启动操作系统</p></li><li><p>观察者模式，监听 <code>opsSystem.Provider</code></p></li><li><p>配置链码安装路径、存储器和解码器</p></li><li><p>解析 <code>peerHost</code> 和 <code>listenAddress</code>（这两个地址有区别吗？？）</p><blockquote><p>发现一个之前没搞清楚的概念，主机地址和监听地址其实是不同的，只不过大多数开发场景中，<code>peerHost</code>和 <code>listenAddr</code>可能会指向相同的主机地址，但它们的上下文和作用略有不同：一个是用于解析配置和标识网络位置，另一个是用于节点启动时的监听配置。</p><p>主机地址一般是 IP 地址或域名，例如，<code>192.168.1.10</code> 或<code>example.com</code> 都是主机地址。</p><p>监听地址可以是 IP 地址或通配符，比如 <code>0.0.0.0</code> 和<code>192.168.1.10</code> 都是监听地址。</p><p>存在很多主机地址和监听地址不同的情况：</p><p>单网卡多IP，一台电脑有多个IP地址（网卡有多个网络接口），但是只监听一个IP；使用通配符或者localhost监听。</p></blockquote></li><li><p>配置一堆服务端配置</p></li><li><p>创建 <code>peer</code> 实例</p></li><li><p>获取本地 MSP ，从 MSP 中获取身份</p></li><li><p>根据身份，创建 <code>MembershipInfoProvider</code>，用来判断一个节点是否连接到一个组织。</p></li><li><p>创建政策检查器和管理器</p></li><li><p>启动 <code>aclProvider</code> (ACL 是什么？)</p><blockquote><p>ACL 是 Access Control List（访问控制列表），和计网中的概念相同。</p></blockquote></li><li><p>创建 <code>lifecycleValidatorCommitter</code>，用于链码生命周期管理。</p></li><li><p>配置 <code>ccprovider</code></p></li><li></li></ol>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;开坑，学习 Fabric 的源码。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;思路是根据 &lt;code&gt;fabric-sample&lt;/code&gt; 的
&lt;code&gt;test-network&lt;/code&gt;
中的脚本，一行行分析。遇到里面使用的指令，看源码如何实现。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下面内容非常混乱，写的毫无逻辑，之后有空重新整理一遍。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一口气写完太长了，typora里会卡，分章节发。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;学习笔记，不保证内容正确性。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;因为台风改签明天了……再看一点&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://cishoon.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="区块链" scheme="http://cishoon.top/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="go" scheme="http://cishoon.top/tags/go/"/>
    
    <category term="fabric" scheme="http://cishoon.top/tags/fabric/"/>
    
    <category term="超级账本" scheme="http://cishoon.top/tags/%E8%B6%85%E7%BA%A7%E8%B4%A6%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Hyperledger Fabric 源码精读（2）</title>
    <link href="http://cishoon.top/fabric/fabric%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AF%BB%20(2)/"/>
    <id>http://cishoon.top/fabric/fabric%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AF%BB%20(2)/</id>
    <published>2024-09-13T16:00:00.000Z</published>
    <updated>2024-09-15T09:04:06.516Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>开坑，学习 Fabric 的源码。</p></li><li><p>思路是根据 <code>fabric-sample</code> 的<code>test-network</code>中的脚本，一行行分析。遇到里面使用的指令，看源码如何实现。</p></li><li><p>下面内容非常混乱，写的毫无逻辑，之后有空重新整理一遍。</p></li><li><p>一口气写完太长了，typora里会卡，分章节发。</p></li><li><p>学习笔记，不保证内容正确性。</p></li></ul><span id="more"></span><h1 id="createchannel">2 createChannel</h1><p><code>network.sh</code> 的注释里明确说明，这个函数干了两件事：</p><ol type="1"><li>join the peers of org1 and org2：加入两个组织的对等节点</li><li>update the <strong>anchor peers</strong> for eachorganization：更新每个组织的锚定节点</li></ol><p>我完善一下：</p><ol type="1"><li>创建创世区块</li><li>利用创世区块创建通道</li><li>加入对等节点</li><li>更新锚定节点</li></ol><h2 id="创建创世区块">2.1 创建创世区块</h2><p>test-network 的脚本固定由第一个组织进行创世区块的创建。</p><p>创建创世区块的核心语句是：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">configtxgen -profile ChannelUsingRaft -outputBlock ./channel-artifacts/${CHANNEL_NAME}.block -channelID $CHANNEL_NAME</span><br></pre></td></tr></table></figure><p>接下来看看configtxgen</p><h3 id="configtxgen">2.1.1 configtxgen</h3><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-channelID string</code></td><td>指定在配置交易中使用的通道ID。</td></tr><tr><td><code>-configPath string</code></td><td>指定包含要使用配置的路径。</td></tr><tr><td><code>-inspectBlock string</code></td><td>打印指定路径区块中包含的配置。</td></tr><tr><td><code>-outputBlock string</code></td><td>指定写入创世区块的路径。</td></tr><tr><td><code>-profile string</code></td><td>指定 <code>configtx.yaml</code> 中用于生成的配置文件。</td></tr></tbody></table><p>这个工具的输出主要受 <code>configtx.yaml</code> 文件内容的控制。</p><p>默认情况下，<code>configtxgen</code> 工具会依次尝试从<code>$FABRIC_CFG_PATH</code> 环境变量指定的路径，当前路径和<code>/etc/hyperledger/fabric</code> 路径下查找<code>configtx.yam</code> 配置文件并读入，作为默认的配置。或者使用参数的<code>-configPath</code> 定义。环境变量中以<code>CONFIGTX_</code>前缀开头的变量也会被作为配置项。</p><p>很多功能都被启用了，好像唯一的功能就是创建创世区块？</p><p>在源码中，创建创世区块的核心代码都是由 <code>protoutil</code>这个包实现的。</p><h3 id="protoutil">2.1.2 protoutil</h3><p><code>protoutil</code> 是 Hyperledger Fabric中的一个实用工具，用于处理和操作协议缓冲区（protobuf）格式的数据。HyperledgerFabric 使用协议缓冲区（Protobuf）作为其内部数据结构的主要序列化格式，而<code>protoutil</code>提供了一组工具和函数来简化这些数据的创建、解析、和转换过程。</p><p>具体来说，<code>protoutil</code> 可能包括以下功能：</p><ul><li>序列化和反序列化 Protobuf 消息。</li><li>生成交易提案和区块。</li><li>解析和检验区块数据结构。</li><li>操作链码提案、响应和其他相关的 Protobuf 消息。</li></ul><p>这些功能对于开发和维护 Fabric 网络至关重要，因为它们简化了与 Fabric内部数据结构的交互。</p><p>什么是协作缓冲区 Protobuf ？https://protobuf.com.cn/overview/</p><p>简言之就是类似 Json 但比 Json更紧凑轻量的数据格式。一个区块，无非就是一个键值对，里面存的数据不同而已。</p><table><colgroup><col style="width: 25%"><col style="width: 23%"><col style="width: 50%"></colgroup><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>Header</code></td><td><code>*cb.BlockHeader</code></td><td>Contains metadata about the block itself.</td></tr><tr><td><code>Header.Number</code></td><td><code>uint64</code></td><td>The sequence number of the block.</td></tr><tr><td><code>Header.PreviousHash</code></td><td><code>[]byte</code></td><td>The hash of the previous block.</td></tr><tr><td><code>Header.DataHash</code></td><td><code>[]byte</code></td><td>The hash of the block's data.</td></tr><tr><td><code>Data</code></td><td><code>*cb.BlockData</code></td><td>Contains the actual data of the block.</td></tr><tr><td><code>Metadata</code></td><td><code>*cb.BlockMetadata</code></td><td>Contains metadata for the block.</td></tr><tr><td><code>Metadata.Metadata</code></td><td><code>[][]byte</code></td><td>Array of metadata entries.</td></tr></tbody></table><p>创世区块具体的值如下：</p><ul><li><code>Header.Number</code>：<code>0</code>，因为这是创世区块。</li><li><code>Header.PreviousHash</code>：<code>nil</code>，因为这是创世区块，没有前一个区块。</li><li><code>Header.DataHash</code>：由<code>protoutil.ComputeBlockDataHash(block.Data)</code>计算得出。</li><li><code>Data</code>：包含一个<code>cb.Envelope</code>，其<code>Payload</code>为<code>cb.Payload</code>，<code>Data</code>为<code>cb.ConfigEnvelope</code>。</li><li><code>Metadata.Metadata</code>：包含两个条目：<ul><li><code>cb.BlockMetadataIndex_LAST_CONFIG</code>：包含<code>cb.LastConfig{Index: 0}</code>。</li><li><code>cb.BlockMetadataIndex_SIGNATURES</code>：包含<code>cb.OrdererBlockMetadata{LastConfig: &amp;cb.LastConfig{Index: 0}}</code>。</li></ul></li></ul><p>然后把这个东西写入一个文件中<code>./channel-artifacts/${CHANNEL_NAME}.block</code>就完成了创世区块的创建。</p><h2 id="创建通道">2.2 创建通道</h2><p>循环执行以下脚本：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">. scripts/orderer.sh <span class="variable">${CHANNEL_NAME}</span>&gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><blockquote><p><code>.</code> 命令是 <code>source</code> 命令的简写形式，用于在当前shell 环境中执行一个脚本文件。这意味着文件中的所有命令都会在当前 shell中运行，而不会创建新的子 shell。这与直接执行脚本文件（如<code>./script.sh</code>）不同，后者会创建一个新的子 shell来运行脚本中的命令。</p></blockquote><p>orderer.sh:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">osnadmin channel <span class="built_in">join</span> </span><br><span class="line">--channelID <span class="variable">${channel_name}</span> </span><br><span class="line">--config-block ./channel-artifacts/<span class="variable">${channel_name}</span>.block </span><br><span class="line">-o localhost:7053 </span><br><span class="line">--ca-file <span class="string">"<span class="variable">$ORDERER_CA</span>"</span> </span><br><span class="line">--client-cert <span class="string">"<span class="variable">$ORDERER_ADMIN_TLS_SIGN_CERT</span>"</span> </span><br><span class="line">--client-key <span class="string">"<span class="variable">$ORDERER_ADMIN_TLS_PRIVATE_KEY</span>"</span> </span><br><span class="line">&gt;&gt; log.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>突然出现了一个新工具：<code>osnadmin</code></p><h3 id="osnadmin-channel">2.2.1 osnadmin channel</h3><p>OSN 是 Ordering Service Node 的缩写。osnadmin channel命令允许管理员在排序节点上执行与通道相关的操作，例如<strong>加入通道</strong>、<strong>列出排序节点已加入的通道</strong>以及<strong>移除通道</strong>。必须启用通道参与API，并且在每个排序节点的orderer.yaml 中配置Admin端点。</p><p><code>osnadmin channel join</code> 干的事，就是向<code>https://localhost:7053/participation/v1/channels</code>发送了一个HTTP POST请求，请求体是上一步生成的创世区块。</p><p>顺便的，<code>osnadmin channel list</code> 就是向<code>https://localhost:7053/participation/v1/channels/${channel-id}</code>发送 HTTP GET 请求，如果不携带特定的 <code>channel-id</code>就是返回所有通道。</p><p><code>osnadmin channel remove</code> 干的事，就是向<code>https://localhost:7053/participation/v1/channels</code>发送了一个HTTP DELETE请求。</p><p>这里也表明了，<code>orderer</code>启动的服务里应该有很多接口可调用。</p><h2 id="对等节点加入通道">2.3 对等节点加入通道</h2><p>在排序节点上创建好了通道，接下来就是让对等节点加入通道。</p><p>同样是循环执行脚本：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">peer channel <span class="built_in">join</span> -b <span class="variable">$BLOCKFILE</span> &gt;&amp;log.txt</span><br></pre></td></tr></table></figure><p>其中<code>BLOCKFILE="./channel-artifacts/${CHANNEL_NAME}.block"</code>，就是刚刚产生的创世区块。</p><p>这里的 <code>peer channel</code> 好像就是<code>osnadmin channel</code> 的 <code>peer</code> 版。</p><h3 id="peer-channel-join">2.3.1 peer channel join</h3><ul><li><p><strong>ChannelCmdFactory</strong></p><p>其中用到了一个工厂模式，<code>InitCmdFactory</code>，<code>peer channel</code>会根据不同的指令需求（是否需要背书、是否需要广播给对等节点、是否需要广播给排序节点）打包客户端。</p><p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ChannelCmdFactory holds the clients used by ChannelCmdFactory</span></span><br><span class="line"><span class="keyword">type</span> ChannelCmdFactory <span class="keyword">struct</span> {</span><br><span class="line">EndorserClient   pb.EndorserClient</span><br><span class="line">Signer           msp.SigningIdentity</span><br><span class="line">BroadcastClient  common.BroadcastClient</span><br><span class="line">DeliverClient    deliverClientIntf</span><br><span class="line">BroadcastFactory BroadcastClientFactory</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p><p>执行 join 只需要背书，不需要广播给对等节点和排序节点。</p></li><li><p><strong>getJoinCCSpec</strong></p><p>听函数名字和链码有关，获取了一个链码的Spec，但是到目前为止我还没有创建过链码？先来看看源码：</p><p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getJoinCCSpec</span><span class="params">()</span></span> (*pb.ChaincodeSpec, <span class="type">error</span>) {</span><br><span class="line"><span class="keyword">if</span> genesisBlockPath == common.UndefinedParamValue {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"Must supply genesis block file"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">gb, err := os.ReadFile(genesisBlockPath)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, GBFileNotFoundErr(err.Error())</span><br><span class="line">}</span><br><span class="line"><span class="comment">// Build the spec</span></span><br><span class="line">input := &amp;pb.ChaincodeInput{Args: [][]<span class="type">byte</span>{[]<span class="type">byte</span>(cscc.JoinChain), gb}}</span><br><span class="line"></span><br><span class="line">spec := &amp;pb.ChaincodeSpec{</span><br><span class="line">Type:        pb.ChaincodeSpec_Type(pb.ChaincodeSpec_Type_value[<span class="string">"GOLANG"</span>]),</span><br><span class="line">ChaincodeId: &amp;pb.ChaincodeID{Name: <span class="string">"cscc"</span>},</span><br><span class="line">Input:       input,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> spec, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></p><p>返回一个 ChaincodeSpec 结构体指针，类型指定为 GOLAN 语言，链码ID为<strong>cscc</strong>，并且还设置了这个链码的输入参数：<code>JoinChain: 创世区块字节码</code></p><p><strong>cscc</strong>，其实是一个内置的系统链码 (SystemChaincode)，全称为 <strong>Configuration System Chaincode</strong>。</p><p>系统链码是由 Hyperledger Fabric平台内置的特殊链码，负责处理一些核心功能。开发者不需要自己编写或部署这些系统链码，它们在Fabric 网络启动时自动部署，并在整个网络中使用。</p><p>JoinChain 这个函数用于将一个新的节点加入到现有的通道中。当调用<code>cscc.JoinChain</code>时，节点会使用给定的创世区块来加入指定的通道。</p></li><li><p><strong>executeJoin(cf <em>ChannelCmdFactory, spec</em>pb.ChaincodeSpec)</strong></p><p>最后，将上面两个函数得到的结果（工厂和spec），放到一起执行。</p><p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">executeJoin</span><span class="params">(cf *ChannelCmdFactory, spec *pb.ChaincodeSpec)</span></span> (err <span class="type">error</span>) {</span><br><span class="line"><span class="comment">// Build the ChaincodeInvocationSpec message</span></span><br><span class="line">invocation := &amp;pb.ChaincodeInvocationSpec{ChaincodeSpec: spec}</span><br><span class="line">creator, err := cf.Signer.Serialize()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据序列化的身份（signer）和链码调用规范（invocation）创建提案</span></span><br><span class="line"><span class="keyword">var</span> prop *pb.Proposal</span><br><span class="line">prop, _, err = protoutil.CreateProposalFromCIS(pcommon.HeaderType_CONFIG, <span class="string">""</span>, invocation, creator)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据提案和签名者创建签名的提案</span></span><br><span class="line"><span class="keyword">var</span> signedProp *pb.SignedProposal</span><br><span class="line">signedProp, err = protoutil.GetSignedProposal(prop, cf.Signer)</span><br><span class="line"></span><br><span class="line"><span class="comment">// EndorserClient 是背书服务的客户端 API。</span></span><br><span class="line"><span class="comment">// ProcessProposal 用于处理提案。</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> proposalResp *pb.ProposalResponse</span><br><span class="line">proposalResp, err = cf.EndorserClient.ProcessProposal(context.Background(), signedProp)</span><br><span class="line"></span><br><span class="line">logger.Info(<span class="string">"Successfully submitted proposal to join channel"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></p><p>还是很清晰的，前两步准备好了请求客户端和要发送的数据，这一步签了名之后，直接调用<code>EndorserClient.ProcessProposal(context.Background(), signedProp)</code>来执行提议。</p><p>封装的很深，执行的逻辑还藏在这个函数里。这个函数奇妙，有一个<code>context</code> 参数，上下文在这里是怎么用的？</p></li><li><p><code>EndorserClient.ProcessProposal</code></p><blockquote><p>// For semantics around ctx use and closing/ending streaming RPCs,please refer tohttps://godoc.org/google.golang.org/grpc#ClientConn.NewStream.</p></blockquote><p>这个是一个接口，这里使用的实现是 <code>perr.pb.go</code>中的实现，具体代码如下：</p><p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> endorserClient <span class="keyword">struct</span> {</span><br><span class="line">cc *grpc.ClientConn</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *endorserClient)</span></span> ProcessProposal(</span><br><span class="line">        ctx context.Context, in *SignedProposal, </span><br><span class="line">        opts ...grpc.CallOption</span><br><span class="line">    ) (*ProposalResponse, <span class="type">error</span>) </span><br><span class="line">{</span><br><span class="line">out := <span class="built_in">new</span>(ProposalResponse)</span><br><span class="line">err := c.cc.Invoke(ctx, <span class="string">"/protos.Endorser/ProcessProposal"</span>, in, out, opts...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> out, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></p><p><code>c.cc</code> 就是结构体中定义的 <code>cc *grpc.ClientConn</code>一个普通的客户端连接。</p><p>主要方法和属性</p><ul><li><code>Invoke</code>：用于调用 RPC 方法。</li><li><code>NewStream</code>：用于创建流式 RPC 调用。</li><li><code>Target</code>：返回连接的目标地址。</li><li><code>Close</code>：关闭连接并清理相关资源。</li><li><code>State</code>：返回连接的当前状态（例如，<code>Ready</code>、<code>Connecting</code>、<code>Idle</code>等）。</li><li><code>WaitForStateChange</code>：等待连接状态发生变化。</li></ul><p>这里传了一个 <code>context.Context</code>参数，目的是允许给用户提供控制权，用户可以通过 ctx 对这个grpc goroutine进行取消、超时等操作。但是这段代码里没有在上层进行其他控制，所以直接传了一个<code>context.Background()</code> 进去。</p><p>关于 gRPC 和 context 的详细内容见文末的附录。</p></li></ul><h3 id="viper">2.3.2 viper</h3><p>但是我还有个疑问，<code>peer channel join</code>的参数或者环境变量是在哪里设置的？之前的 <code>osnadmin</code>直接在参数里设置全了，而 <code>peer</code> 却没有任何参数设置。</p><p>其实是 <code>network.sh</code> 设置了这个参数：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FABRIC_CFG_PATH=$PWD/../config/</span><br></pre></td></tr></table></figure><p>在该文件夹里有一个 <code>core.yaml</code>里面定义了所有配置，里面写死了：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">peer:</span></span><br><span class="line"><span class="attr">address:</span></span><br><span class="line"><span class="string">localhost:7051</span></span><br></pre></td></tr></table></figure><p>另外，<code>setGlobals</code>函数设置了全局变量，用于切换两个组织的配置：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$USING_ORG</span> -eq 1 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">export</span> CORE_PEER_LOCALMSPID=Org1MSP</span><br><span class="line">  <span class="built_in">export</span> CORE_PEER_TLS_ROOTCERT_FILE=<span class="variable">$PEER0_ORG1_CA</span></span><br><span class="line">  <span class="built_in">export</span> CORE_PEER_MSPCONFIGPATH=...org1...</span><br><span class="line">  <span class="built_in">export</span> CORE_PEER_ADDRESS=localhost:7051</span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$USING_ORG</span> -eq 2 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">export</span> CORE_PEER_LOCALMSPID=Org2MSP</span><br><span class="line">  <span class="built_in">export</span> CORE_PEER_TLS_ROOTCERT_FILE=<span class="variable">$PEER0_ORG2_CA</span></span><br><span class="line">  <span class="built_in">export</span> =...org2...</span><br><span class="line">  <span class="built_in">export</span> CORE_PEER_ADDRESS=localhost:9051</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>前三个变量来区别组织1和组织2的证书、MSP，最后一个变量区分节点的监听地址。</p><p>（test-network中一个组织只有一个节点。实际上，同一个组织下会有多个节点，他们的前三个变量相同，最后一个参数不同）</p><p>这里我很奇怪，怎么又是环境变量，又是配置文件，他们的命名方式都不一样，甚至环境变量还多了一个前缀<code>CORE</code> 这怎么关联上的？</p><p>fabric 用了一个 go 的开源库 <code>viper</code>，其功能就是很方便的从配置文件中读取值，也能使用环境变量去覆盖配置文件里的值。他会自动解析环境变量，并把变量名小写、将下划线替换。并且源码中还有：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">viper.SetEnvPrefix(<span class="string">"CORE"</span>)</span><br></pre></td></tr></table></figure><p>显而易见，是设置了环境变量的前缀为 CORE 。这就是 fabric进行配置读取的方式。</p><h3 id="总结复盘">2.3.3 总结复盘</h3><p>至此，<code>peer channel join -b 创世区块.block</code>执行完毕。再次复盘提出问题：</p><p>具体来说，这个过程调用了一个系统内置的链码函数<code>cscc.JoinChain</code>，节点会使用给定的创世区块来加入指定的通道。</p><blockquote><p><strong>问题1：</strong>新的通道是通过创世区块来标识的吗？如果这个通道已经有好多个区块了，新的节点想加入进来，也是通过创世区块来加入吗？如果是，我这个例子都在本地，创世区块就存在本地，其他新节点想加入的时候，怎么获得创世区块？</p><p><strong>通道与创世区块的关系</strong>：</p><ul><li><strong>创世区块</strong>是通道的第一个区块，它包含了通道的初始配置和一些重要的元数据。每个通道都有一个唯一的创世区块，通道的标识在区块链中是通过区块链上的区块来维护的，其中创世区块是至关重要的第一块。</li><li>当一个新节点要加入到一个已有的通道时，即使这个通道已经包含了很多区块，新节点仍然是通过创世区块来加入的。这是因为创世区块包含了通道的初始配置和结构信息，节点需要这些信息来了解通道的基本设置。</li></ul><p><strong>获取创世区块</strong>：</p><ul><li>在生产环境中，新节点通常无法直接从本地获得创世区块，而是通过其他方式获取：<ol type="1"><li><strong>通过已经加入通道的节点</strong>：新节点可以从已经是通道成员的节点那里请求创世区块。这通常通过<code>peer channel fetch</code>命令来实现，该命令可以从通道的区块链上获取创世区块或其他指定的区块。</li><li><strong>从区块存储库中提取</strong>：在某些情况下，创世区块可能会被存储在一个共享的存储库或文件系统中，节点可以从中获取。</li><li><strong>通过网络传输</strong>：创世区块也可以通过安全的网络传输从其他节点或管理系统中获取。</li></ol></li></ul><p><strong>加入现有通道</strong>：</p><ul><li><p>当新节点使用创世区块加入现有的通道时，它首先会同步到当前通道的最新状态（即下载并验证通道中的所有区块，直到最新的区块）。这样，新节点便可以与通道中的其他节点保持一致。</p><p>这里提到新节点会同步通道的最新状态，这部分代码在 peer内部执行。也就是 gRPC 发送请求后，docker 容器里的 peer 执行。</p></li></ul></blockquote><p>调用链码的方式是给背书节点发送 gRPC 请求。</p><p><strong>问题2：</strong>通过阅读源码，我发现这里的背书节点，就是要加入的节点。这是为什么？背书节点的作用是什么？有没有其他使用背书节点的例子？</p><blockquote><p><strong>背书节点的角色</strong>：</p><ul><li>在 Hyperledger Fabric 中，<strong>背书节点（Endorser Peer）</strong>是负责模拟和验证交易的节点。每个参与者节点都可以配置为背书节点，背书节点根据链码的逻辑模拟交易，并生成背书（endorsement），背书包含节点对交易的认可。</li><li><strong>为什么背书节点就是要加入的节点</strong>：<ul><li>当一个节点想要加入一个通道时，它需要运行一个系统链码（如<code>cscc</code>）来执行这个操作。在这种情况下，节点实际上是在请求自己作为背书节点来执行这个操作。这是因为加入通道的过程需要在本节点上进行一些检查和操作（例如验证创世区块、更新节点的通道状态等），这些操作都需要由本节点背书和认可。</li></ul></li><li><strong>背书节点的其他使用例子</strong>：<ul><li><strong>交易提案的背书</strong>：在通常的交易流程中，客户端将交易提案发送给多个背书节点。这些节点分别模拟交易并生成背书响应。客户端收集足够的背书后，将交易提交给排序服务（Orderer）。</li><li><strong>链码的安装与实例化</strong>：当一个链码被安装或实例化时，背书节点也会参与其中，模拟链码的执行并生成相应的状态更新或响应。</li></ul></li></ul><p><strong>总结</strong>：</p><ul><li>背书节点在 Fabric中不仅用于加入通道的操作，还用于各种交易和链码操作中，是确保区块链数据一致性和安全性的关键组件。</li><li>在你提到的场景中，背书节点执行的 <code>cscc.JoinChain</code>操作是为了确保节点正确加入通道，确保它能够获取到通道的配置并同步到最新状态。</li></ul></blockquote><p>同时 <code>peer</code>会自动获取配置文件和环境变量。具体让哪个组织、哪个节点加入通道，都是在配置文件和环境变量中设置的。</p><h2 id="设置锚定节点">2.4 设置锚定节点</h2><p>什么是锚定节点？锚定节点的作用是什么？</p><h3 id="获取通道配置">2.4.1 获取通道配置</h3><h4 id="peer-channel-fetch-config">2.4.1.1 peer channel fetchconfig</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">peer channel fetch config </span><br><span class="line"><span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/config_block.pb </span><br><span class="line">-o localhost:7050 </span><br><span class="line">--ordererTLSHostnameOverride orderer.example.com </span><br><span class="line">-c <span class="variable">$CHANNEL</span> --tls --cafile <span class="string">"<span class="variable">$ORDERER_CA</span>"</span></span><br></pre></td></tr></table></figure><p><code>peer channel fetch</code>用于获取一个特定的区块，并把它写入文件。后面可跟参数</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;newest|oldest|config|(number)</span><br></pre></td></tr></table></figure><p>除了 <code>config</code> 都好理解。看看源码</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> args[<span class="number">0</span>] {</span><br><span class="line"><span class="keyword">case</span> <span class="string">"oldest"</span>:</span><br><span class="line">block, err = cf.DeliverClient.GetOldestBlock()</span><br><span class="line"><span class="keyword">case</span> <span class="string">"newest"</span>:</span><br><span class="line">block, err = cf.DeliverClient.GetNewestBlock()</span><br><span class="line"><span class="keyword">case</span> <span class="string">"config"</span>:</span><br><span class="line">iBlock, err2 := cf.DeliverClient.GetNewestBlock()</span><br><span class="line"><span class="keyword">if</span> err2 != <span class="literal">nil</span> { <span class="keyword">return</span> err2 }</span><br><span class="line">    </span><br><span class="line">lc, err2 := protoutil.GetLastConfigIndexFromBlock(iBlock)</span><br><span class="line"><span class="keyword">if</span> err2 != <span class="literal">nil</span> { <span class="keyword">return</span> err2 }</span><br><span class="line">    </span><br><span class="line">logger.Infof(<span class="string">"Retrieving last config block: %d"</span>, lc)</span><br><span class="line">block, err = cf.DeliverClient.GetSpecifiedBlock(lc)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">num, err2 := strconv.Atoi(args[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">if</span> err2 != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"fetch target illegal: %s"</span>, args[<span class="number">0</span>])</span><br><span class="line">}</span><br><span class="line">block, err = cf.DeliverClient.GetSpecifiedBlock(<span class="type">uint64</span>(num))</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>即最新的块里存放了一项数据，记录最近的 config存放在第几个区块里。</p><p>再具体一点，<code>InitCmdFactory</code> 根据有没有设置<code>-o</code> 决定需要 <code>peerDeliver</code> 还是<code>ordererDeliver</code>。</p><p><code>peerDeliver</code> 还是 <code>ordererDeliver</code>唯一的区别在于，<code>peer</code> 创建的 <code>CommonClient</code> 的<code>keepalive</code> 选项为 <code>true</code>。</p><blockquote><p><code>keepalive</code>是一种网络层的机制，用于在没有数据流动时通过发送定期的 "心跳"消息来保持连接的活跃状态。</p><p><strong>Peer 节点和 Orderer 节点的通信差异</strong></p><ol type="1"><li><strong>Peer 节点的通信需求</strong>：<ul><li><strong>实时性和持久连接</strong>：Peer 节点之间或客户端与 Peer节点之间的通信往往涉及长时间的实时交互，如链码执行、状态查询、区块广播等。这些操作可能需要持久的连接，尤其是在监听区块事件或等待交易结果时，连接可能会长时间处于空闲状态。</li><li><strong>保持连接稳定</strong>：为了避免在这些操作期间连接断开，<code>keepalive</code>选项被启用，以确保连接的稳定性，即使在长时间的空闲期内也能保持连接活跃。</li></ul></li><li><strong>Orderer 节点的通信需求</strong>：<ul><li><strong>批量性和间歇通信</strong>：Orderer节点的主要职责是排序交易并将它们打包成区块。客户端与 Orderer节点的通信通常是间歇性的，如提交交易或请求区块。由于这种通信通常不是长时间持续的，连接建立和断开的频率较高，因此不太需要持续的<code>keepalive</code>。</li><li><strong>较短的通信生命周期</strong>：与 Peer节点的长时间通信不同，Orderer节点的通信一般是短暂且快速的，通常在完成一次性请求后即关闭连接，因此<code>keepalive</code> 的需求不大。</li></ul></li></ol></blockquote><p>与 <code>EndorserClient</code> 不同的是，<code>peer</code> 和<code>orderer</code> 使用的是 <code>AtomicBroadcast_DeliverClient</code>原子的广播。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *atomicBroadcastBroadcastClient)</span></span> Send(m *common.Envelope) <span class="type">error</span> {</span><br><span class="line"><span class="keyword">return</span> x.ClientStream.SendMsg(m)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *atomicBroadcastBroadcastClient)</span></span> Recv() (*BroadcastResponse, <span class="type">error</span>) {</span><br><span class="line">m := <span class="built_in">new</span>(BroadcastResponse)</span><br><span class="line"><span class="keyword">if</span> err := x.ClientStream.RecvMsg(m); err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> m, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>其中 <code>ClientStream</code> 是 <code>gRPC</code> 的内置对象。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DeliverClient)</span></span> GetOldestBlock() (*cb.Block, <span class="type">error</span>) {</span><br><span class="line">err := d.seekOldest()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.WithMessage(err, <span class="string">"error getting oldest block"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> d.readBlock()</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>先发送请求，再读取返回值。go 中使用 gRPC 的请求和返回不用像 Js那样特意写异步函数。</p><p>至此，读取了该通道的配置区块并写入 <code>config_block.pb</code>本地保存。</p><h4 id="configtxlator">2.4.1.2 configtxlator</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">configtxlator proto_decode </span><br><span class="line">--input <span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/config_block.pb </span><br><span class="line">--<span class="built_in">type</span> common.Block </span><br><span class="line">--output <span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/config_block.json</span><br></pre></td></tr></table></figure><p>这个函数功能很明显，将区块中的数据转为 JSON格式。不分析这个工具的源码了，大体上就是用 proto 读取，保存成 json。</p><h4 id="jq">2.4.1.3 jq</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jq .data.data[0].payload.data.config</span><br><span class="line">    <span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/config_block.json &gt;<span class="string">"<span class="variable">${OUTPUT}</span>"</span></span><br></pre></td></tr></table></figure><p><code>jq</code> 是一个用于处理 JSON 数据的命令行工具，它可以方便地从JSON 文件中提取数据、进行过滤和格式化。</p><p>这段 Bash 代码执行了以下操作：</p><ol type="1"><li>使用 <code>jq</code> 从 <code>config_block.json</code>文件中提取通道配置块（<code>.data.data[0].payload.data.config</code>字段）。</li><li>提取到的数据被写入到由环境变量 <code>OUTPUT</code>指定的文件中。</li></ol><h3 id="修改通道配置">2.4.2 修改通道配置</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">jq '.channel_group.groups.Application.groups.'$<span class="punctuation">{</span>CORE_PEER_LOCALMSPID<span class="punctuation">}</span>'.values += <span class="punctuation">{</span><span class="attr">"AnchorPeers"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"mod_policy"</span><span class="punctuation">:</span> <span class="string">"Admins"</span><span class="punctuation">,</span><span class="attr">"value"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"anchor_peers"</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">{</span><span class="attr">"host"</span><span class="punctuation">:</span> <span class="string">"'$HOST'"</span><span class="punctuation">,</span><span class="attr">"port"</span><span class="punctuation">:</span> '$PORT'<span class="punctuation">}</span><span class="punctuation">]</span><span class="punctuation">}</span><span class="punctuation">,</span><span class="attr">"version"</span><span class="punctuation">:</span> <span class="string">"0"</span><span class="punctuation">}</span><span class="punctuation">}</span>' $<span class="punctuation">{</span>TEST_NETWORK_HOME<span class="punctuation">}</span>/channel-artifacts/$<span class="punctuation">{</span>CORE_PEER_LOCALMSPID<span class="punctuation">}</span>config.json &gt; $<span class="punctuation">{</span>TEST_NETWORK_HOME<span class="punctuation">}</span>/channel-artifacts/$<span class="punctuation">{</span>CORE_PEER_LOCALMSPID<span class="punctuation">}</span>modified_config.json</span><br></pre></td></tr></table></figure><p>这段代码使用 <code>jq</code> 修改了 Hyperledger Fabric网络中与某个组织（由 <code>CORE_PEER_LOCALMSPID</code>环境变量指定）相关的通道配置。具体操作是：</p><ol type="1"><li><strong>定位组织的配置部分</strong>：<ul><li>通过 <code>jq</code> 表达式<code>'.channel_group.groups.Application.groups.'${CORE_PEER_LOCALMSPID}'.values'</code>定位到通道配置 JSON 文件中，特定组织的配置部分。</li></ul></li><li><strong>添加或更新锚节点配置</strong>：<ul><li>在定位到的组织配置部分中，使用 <code>+=</code> 操作符向<code>values</code> 字段中添加或更新一个名为 <code>AnchorPeers</code>的配置项。这个配置项包含锚节点的信息，包括<code>mod_policy</code>、<code>value</code> 和<code>version</code>。</li><li><code>value</code> 字段中嵌套了 <code>anchor_peers</code> 信息，其中<code>host</code> 和 <code>port</code> 的值分别从环境变量<code>HOST</code> 和 <code>PORT</code>中获取，代表了锚节点的主机和端口。</li></ul></li><li><strong>保存修改后的配置</strong>：<ul><li>将修改后的 JSON 数据保存到一个新的文件中，该文件路径由<code>TEST_NETWORK_HOME</code> 和 <code>CORE_PEER_LOCALMSPID</code>环境变量指定，表示该组织的修改后的通道配置。</li></ul></li></ol><h3 id="创建配置更新">2.4.3 创建配置更新</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">createConfigUpdate <span class="variable">${CHANNEL_NAME}</span> <span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/<span class="variable">${CORE_PEER_LOCALMSPID}</span>config.json <span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/<span class="variable">${CORE_PEER_LOCALMSPID}</span>modified_config.json <span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/<span class="variable">${CORE_PEER_LOCALMSPID}</span>anchors.tx</span><br></pre></td></tr></table></figure><p><code>createConfigUpdate</code>函数的总体作用是生成一个配置更新交易（configuration updatetransaction）。这个过程涉及将原始和修改后的通道配置转换为二进制格式，计算出两者之间的差异，并将这个差异打包为一个可以提交的交易。</p><p>其具体实现如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">configtxlator proto_encode --input <span class="string">"<span class="variable">${ORIGINAL}</span>"</span> --<span class="built_in">type</span> common.Config --output <span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/original_config.pb</span><br><span class="line"></span><br><span class="line">configtxlator proto_encode --input <span class="string">"<span class="variable">${MODIFIED}</span>"</span> --<span class="built_in">type</span> common.Config --output <span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/modified_config.pb</span><br><span class="line"></span><br><span class="line">configtxlator compute_update --channel_id <span class="string">"<span class="variable">${CHANNEL}</span>"</span> --original <span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/original_config.pb --updated <span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/modified_config.pb --output <span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/config_update.pb</span><br><span class="line"></span><br><span class="line">configtxlator proto_decode --input <span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/config_update.pb --<span class="built_in">type</span> common.ConfigUpdate --output <span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/config_update.json</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'{"payload":{"header":{"channel_header":{"channel_id":"'</span><span class="variable">$CHANNEL</span><span class="string">'", "type":2}},"data":{"config_update":'</span>$(<span class="built_in">cat</span> <span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/config_update.json)<span class="string">'}}}'</span> | jq . &gt; <span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/config_update_in_envelope.json</span><br><span class="line"></span><br><span class="line">configtxlator proto_encode --input <span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/config_update_in_envelope.json --<span class="built_in">type</span> common.Envelope --output <span class="string">"<span class="variable">${OUTPUT}</span>"</span>  </span><br></pre></td></tr></table></figure><ol type="1"><li><strong>编码原始配置文件为二进制格式</strong>：<ul><li><strong>目的</strong>：将原始的 JSON 格式配置文件(<code>${ORIGINAL}</code>) 编码为 <code>protobuf</code> 格式的二进制文件<code>original_config.pb</code>。<code>protobuf</code> 是 HyperledgerFabric 用于内部数据表示的格式。</li></ul></li><li><strong>编码修改后的配置文件为二进制格式</strong>：<ul><li><strong>目的</strong>：将修改后的 JSON 格式配置文件(<code>${MODIFIED}</code>) 编码为 <code>protobuf</code> 格式的二进制文件<code>modified_config.pb</code>。</li></ul></li><li><strong>计算配置更新的差异</strong>：<ul><li><strong>目的</strong>：比较原始配置和修改后的配置，计算出两者之间的差异，并生成一个表示这些差异的配置更新文件<code>config_update.pb</code>。这个文件以 <code>protobuf</code>格式保存，包含了需要应用的配置更改。</li></ul></li><li><strong>解码配置更新为 JSON 格式</strong>：<ul><li><strong>目的</strong>：将 <code>protobuf</code> 格式的配置更新文件<code>config_update.pb</code> 解码回 JSON 格式的文件<code>config_update.json</code>，方便后续处理或查看。</li></ul></li><li><strong>创建包含配置更新的信封（Envelope）</strong>：<ul><li><strong>目的</strong>：将配置更新嵌入到一个 <code>Envelope</code>中，添加必要的元数据（如 <code>channel_id</code>和类型）。这是为了将配置更新打包成一个完整的交易，可以提交到区块链网络中。</li></ul></li><li><strong>编码带信封的配置更新为二进制格式</strong>：<ul><li><strong>目的</strong>：将包含信封的配置更新（<code>config_update_in_envelope.json</code>）再次编码为<code>protobuf</code> 格式的二进制文件，生成最终可以提交的配置更新交易<code>anchors.tx</code>。</li></ul></li></ol><h3 id="peer-channel-update">2.4.4 peer channel update</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">peer channel update </span><br><span class="line">-o localhost:7050 </span><br><span class="line">--ordererTLSHostnameOverride orderer.example.com </span><br><span class="line">-c <span class="variable">$CHANNEL_NAME</span> </span><br><span class="line">-f <span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/<span class="variable">${CORE_PEER_LOCALMSPID}</span>anchors.tx </span><br><span class="line">--tls --cafile <span class="string">"<span class="variable">$ORDERER_CA</span>"</span> &gt;&amp;log.txt</span><br></pre></td></tr></table></figure><p>已经很明白这段代码的目的了。看看具体实现有没有特别的地方。</p><p>工厂什么都不需要：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">InitCmdFactory(EndorserNotRequired, PeerDeliverNotRequired, OrdererNotRequired)</span><br></pre></td></tr></table></figure><p>官方文档说，Use the orderer at ip address<code>orderer.example.com:7050</code> to send the configurationtransaction to all peers in the channel to update their copy of thechannel configuration.</p><p>即这段代码是指定一个排序节点向通道内的所有对等节点广播，修改他们的配置。</p><p>要记住什么操作室部署好的节点服务做的，什么是调用的指令做的。广播的操作是orderer 服务内部做的，<code>peer channel update</code>只负责向排序节点发送一个 gRPC。</p><h2 id="问题">问题</h2><h3 id="锚节点的作用">锚节点的作用</h3><ol type="1"><li><strong>跨组织的区块传播</strong>：<ul><li>锚节点是用于在不同组织之间进行区块传播的关键节点。当一个新的区块被Orderer节点生成并分发时，它首先会发送给每个组织的锚节点。然后，锚节点负责将这些区块传递给本组织内的其他Peer 节点。</li><li>这种机制确保了区块能够在不同组织的节点之间有效传播，保持所有节点的数据同步。</li></ul></li><li><strong>跨组织的服务发现</strong>：<ul><li>锚节点用于跨组织的服务发现。在 Hyperledger Fabric中，当客户端（或其他 Peer节点）需要与其他组织的节点通信时，它们可以通过查询锚节点来获取目标组织内的其他Peer 节点的信息。</li><li>例如，在执行一个跨组织的链码调用时，客户端可能需要发送交易提案到多个组织的Peer 节点。锚节点提供了一个入口，使得客户端能够发现并连接到这些 Peer节点。</li></ul></li><li><strong>优化网络流量</strong>：<ul><li>通过将区块传播的责任集中到少数锚节点，可以减少网络中全网广播带来的流量开销。这种集中化传播可以提高网络的效率和性能，避免不必要的数据冗余和延迟。</li></ul></li></ol><p>有点类似于网关。</p><h3 id="各个client的作用">各个Client的作用</h3><p>在 Hyperledger Fabric 的源码中，<code>ChannelCmdFactory</code>结构体中的几个客户端（<code>EndorserClient</code>、<code>BroadcastClient</code>、<code>DeliverClient</code>）各自承担着不同的角色和职责，它们分别用于与不同类型的Fabric 节点通信。以下是对这些客户端的具体实现及其用途的详细解释：</p><h4 id="endorserclient-pb.endorserclient">1. EndorserClient(<code>pb.EndorserClient</code>)</h4><ul><li><strong>作用</strong>：<code>EndorserClient</code>是用于与背书节点（EndorserPeer）进行通信的客户端。它的主要职责是发送交易提案给背书节点，并接收背书节点返回的背书响应。</li><li><strong>具体实现</strong>：<ul><li><code>EndorserClient</code> 通常实现了 gRPC 接口，负责与 Peer 节点的<code>ProcessProposal</code>方法交互。背书节点会对交易提案进行模拟执行，并返回模拟的结果（包括读取集和写入集），这个过程称为“背书”。</li><li><code>EndorserClient</code> 的具体实现类可能是通过 gRPC框架生成的客户端代码，例如 <code>endorserClient</code>，它封装了与<code>ProcessProposal</code> 的 gRPC 调用。</li></ul></li><li><strong>使用场景</strong>：<ul><li>在客户端提交交易之前，会使用 <code>EndorserClient</code> 向多个 Peer节点请求交易提案的背书。</li></ul></li></ul><h4 id="broadcastclient-common.broadcastclient">2. BroadcastClient(<code>common.BroadcastClient</code>)</h4><ul><li><strong>作用</strong>：<code>BroadcastClient</code> 是用于与 Orderer节点通信的客户端。它的主要职责是将经过背书的交易提交给 Orderer节点，以便将交易排序后打包进区块。</li><li><strong>具体实现</strong>：<ul><li><code>BroadcastClient</code> 也通常通过 gRPC 与 Orderer节点通信。它实现了与 Orderer 节点的 <code>Broadcast</code>方法的交互，负责将交易数据发送给 Orderer，Orderer节点接收到交易后会对其进行排序，并打包到区块中。</li><li>一个常见的实现类可能是 <code>broadcastClientImpl</code>，它封装了与<code>Broadcast</code> 方法的 gRPC 调用。</li></ul></li><li><strong>使用场景</strong>：<ul><li>在交易得到足够的背书之后，客户端会使用 <code>BroadcastClient</code>将交易提交给 Orderer 节点进行排序和区块打包。</li></ul></li></ul><h4 id="deliverclient-deliverclientintf">3. DeliverClient(<code>deliverClientIntf</code>)</h4><ul><li><strong>作用</strong>：<code>DeliverClient</code> 是用于从 Orderer或 Peer节点接收区块和事件的客户端。它的主要职责是监听区块的传递或接收事件通知。</li><li><strong>具体实现</strong>：<ul><li><code>DeliverClient</code> 通过 gRPC 接口与 Orderer 或 Peer节点进行通信，通常会实现 <code>Deliver</code>方法的调用。<code>Deliver</code> 方法允许客户端从 Peer 节点或 Orderer节点获取区块的传递或接收区块的通知。</li><li>实现类可能是 <code>deliverClientImpl</code> 或者其他实现了<code>deliverClientIntf</code> 接口的类，它封装了与 <code>Deliver</code>方法的 gRPC 交互。</li></ul></li><li><strong>使用场景</strong>：<ul><li>当客户端需要获取通道中的最新区块或监听特定事件（如区块提交事件）时，会使用<code>DeliverClient</code> 来实现这一功能。</li></ul></li></ul><h3 id="总结">总结</h3><ul><li><code>EndorserClient</code>：用于与 Peer节点通信，发送交易提案并接收背书响应。</li><li><code>BroadcastClient</code>：用于与 Orderer 节点通信，将交易提交给Orderer 进行排序和区块打包。</li><li><code>DeliverClient</code>：用于接收区块或事件通知，可以从 Orderer或 Peer 节点获取区块信息。</li></ul><h1 id="总结-1">总结</h1><p>至此，已经完成了 test-network 中网络的启动和通道的创建。</p><p>主要分析了如何使用 fabric 提供的工具（如 <code>peer</code><code>osnadmin</code> <code>cryptogen</code> 等）进行构建网络。</p><p>但是网络的启动中留了一个问题：<code>peer node start</code> 和<code>orderer start</code>干了什么。源码中哪里进行了端口的开放，这些节点收到 gRPC请求之后，后续进行了什么操作。</p><p>下一节完成了这部分问题。</p><h1 id="附录">附录</h1><h2 id="grpc-与传统-http-调用的区别">gRPC 与传统 HTTP 调用的区别</h2><p>gRPC 和传统的 HTTP调用虽然都用于客户端与服务器之间的通信，但它们在底层实现、性能、数据格式、传输协议等方面有显著的区别。以下是一些关键的差异：</p><h4 id="通信协议">1. <strong>通信协议</strong></h4><ul><li><strong>gRPC</strong>：基于 HTTP/2 协议，这使得 gRPC具备了流式通信、多路复用、头部压缩、双向流等特性。HTTP/2的多路复用允许多个请求和响应通过单个 TCP 连接同时传输，减少了延迟。</li><li><strong>传统 HTTP</strong>：基于 HTTP/1.1（或HTTP/2，但应用较少），主要通过请求-响应的方式进行通信，每次请求通常会创建一个新的连接（除非使用了持久连接）。</li></ul><h4 id="数据格式">2. <strong>数据格式</strong></h4><ul><li><strong>gRPC</strong>：使用 ProtocolBuffers（protobuf）作为其序列化协议。这是一种高效的二进制格式，体积小、解析速度快，非常适合跨语言通信。</li><li><strong>传统 HTTP</strong>：通常使用 JSON、XML 等文本格式。虽然 JSON可读性好，但在性能和数据大小方面不如 protobuf 高效。</li></ul><h4 id="性能">3. <strong>性能</strong></h4><ul><li><strong>gRPC</strong>：由于使用了 HTTP/2 和 protobuf，gRPC在性能和资源利用率上要优于传统的 HTTP 调用。gRPC提供更低的延迟和更高的吞吐量。</li><li><strong>传统HTTP</strong>：相对较慢，尤其是在处理大规模通信或需要高并发的场景下，性能不如gRPC。</li></ul><h4 id="双向流式通信">4. <strong>双向流式通信</strong></h4><ul><li><strong>gRPC</strong>：支持双向流式通信，这意味着客户端和服务器可以在单个gRPC 调用中同时发送和接收消息。这对实时通信和流式数据处理特别有用。</li><li><strong>传统HTTP</strong>：基于请求-响应模型，通常是一对一的交互方式。虽然可以通过WebSocket 实现双向通信，但这不是 HTTP 协议的原生功能。</li></ul><h4 id="服务定义">5. <strong>服务定义</strong></h4><ul><li><strong>gRPC</strong>：服务接口使用 protobuf文件定义，强类型化，接口可以跨语言调用，且编译器自动生成客户端和服务器代码。</li><li><strong>传统 HTTP</strong>：没有标准化的接口定义方式，通常使用OpenAPI（Swagger）来定义 RESTfulAPI，但客户端和服务器代码需要手动编写。</li></ul><h4 id="适用场景">6. <strong>适用场景</strong></h4><ul><li><strong>gRPC</strong>：非常适合微服务架构、大规模分布式系统、实时通信、跨语言服务调用等场景。</li><li><strong>传统HTTP</strong>：适合需要高可读性、与浏览器交互、简单或公开的 API服务，通常用于 Web 服务和 RESTful API。</li></ul><h4 id="能否使用传统-http-进行相同的调用">7. <strong>能否使用传统 HTTP进行相同的调用？</strong></h4><p>在技术上，你可以使用传统的 HTTP 来实现类似的 RPC调用，但这会带来一些挑战：</p><ul><li>你需要自己定义数据格式（例如 JSON），处理序列化和反序列化。</li><li>缺乏 gRPC提供的许多高级功能，如双向流、自动代码生成、负载均衡、强类型接口等。</li><li>性能和资源利用率可能不如 gRPC 高效。</li></ul><h2 id="go-标准库中的-context-详细讲解">Go 标准库中的<code>context</code> 详细讲解</h2><p><code>context</code> 是 Go 标准库中的一个包，用于在不同的 goroutine之间传递请求范围内的元数据、取消信号和超时信息。<code>context</code>在处理并发操作时特别有用，尤其是在 gRPC、HTTP服务器、数据库操作等场景下。</p><h4 id="基本概念">1. <strong>基本概念</strong></h4><ul><li><strong><code>context.Context</code> 接口</strong>：<ul><li><code>context.Context</code> 是一个接口，它定义了在不同的 goroutine之间传递请求范围内的信息的标准方法。</li><li>它是不可变的，一旦创建，就不能修改，而是通过派生（创建子context）的方式来添加新的信息。</li></ul></li><li><strong>背景上下文</strong>：<ul><li><strong><code>context.Background()</code></strong>：通常作为根context使用，没有携带任何信息，一般在主函数、初始化或者测试时使用。</li><li><strong><code>context.TODO()</code></strong>：占位用的context，当你不确定应该使用什么 context 时，可以使用<code>TODO()</code>。</li></ul></li></ul><h4 id="常用的函数">2. <strong>常用的函数</strong></h4><ul><li><strong><code>context.WithCancel(parent Context) (ctx Context, cancel CancelFunc)</code></strong>：<ul><li>创建一个子 context，并返回一个取消函数 <code>cancel</code>。</li><li>调用 <code>cancel()</code> 时，会向所有使用该 context 的 goroutine发送取消信号。</li></ul></li><li><strong><code>context.WithDeadline(parent Context, d time.Time) (Context, CancelFunc)</code></strong>：<ul><li>创建一个子 context，该 context 会在指定的时间点自动取消。</li><li>同样返回一个 <code>CancelFunc</code>，可以主动取消。</li></ul></li><li><strong><code>context.WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)</code></strong>：<ul><li>与 <code>WithDeadline</code>类似，但这里是指定一个相对的超时时间。</li></ul></li><li><strong><code>context.WithValue(parent Context, key, val interface{}) Context</code></strong>：<ul><li>返回一个子context，携带一个键值对，可以用于传递请求范围内的特定数据（例如用户身份、请求ID 等）。</li><li>注意：<code>WithValue</code> 应该谨慎使用，避免滥用造成混乱。</li></ul></li></ul><h4 id="如何在代码中使用-context">3. <strong>如何在代码中使用<code>context</code></strong></h4><p>使用 <code>context</code>的典型场景包括取消正在进行的操作、设置超时、传递元数据等。以下是一个简单的使用示例：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// 创建一个带有超时的 context</span></span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), <span class="number">5</span>*time.Second)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> doSomething(ctx, ch)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> {</span><br><span class="line">    <span class="keyword">case</span> result := &lt;-ch:</span><br><span class="line">        fmt.Println(<span class="string">"Received result:"</span>, result)</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">        fmt.Println(<span class="string">"Operation timed out:"</span>, ctx.Err())</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">(ctx context.Context, ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">select</span> {</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">10</span> * time.Second): <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        ch &lt;- <span class="number">42</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">        fmt.Println(<span class="string">"Operation cancelled:"</span>, ctx.Err())</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在这个例子中，如果 <code>doSomething</code> 操作超过 5秒没有完成，<code>ctx.Done()</code> 会被触发，导致操作取消。</p><h4 id="context-的使用建议">4. <strong><code>context</code>的使用建议</strong></h4><ul><li><strong>传递上下文</strong>：函数之间传递 context 时，通常将<code>context.Context</code> 作为第一个参数。</li><li><strong>及时取消</strong>：使用<code>WithCancel</code>、<code>WithTimeout</code>、<code>WithDeadline</code>创建的 context 一定要在不需要时调用返回的<code>CancelFunc</code>，否则可能导致资源泄露。</li><li><strong>避免滥用<code>WithValue</code></strong>：<code>WithValue</code>适合传递请求范围内少量的信息，但不应该用它来传递大量数据或者频繁使用。</li></ul><h3 id="总结-2">总结</h3><ul><li><strong>gRPC</strong> 是一个高性能的 RPC框架，适合微服务和高并发场景，与传统 HTTP调用在协议、数据格式、性能和功能上有显著差异。</li><li><strong>Go 的 <code>context</code></strong>用于在并发操作中传递元数据、取消信号和超时控制，是处理并发任务时的重要工具。它有助于管理资源，避免资源泄露或长时间未完成的任务。</li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;开坑，学习 Fabric 的源码。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;思路是根据 &lt;code&gt;fabric-sample&lt;/code&gt; 的
&lt;code&gt;test-network&lt;/code&gt;
中的脚本，一行行分析。遇到里面使用的指令，看源码如何实现。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下面内容非常混乱，写的毫无逻辑，之后有空重新整理一遍。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一口气写完太长了，typora里会卡，分章节发。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;学习笔记，不保证内容正确性。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://cishoon.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="区块链" scheme="http://cishoon.top/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="go" scheme="http://cishoon.top/tags/go/"/>
    
    <category term="fabric" scheme="http://cishoon.top/tags/fabric/"/>
    
    <category term="超级账本" scheme="http://cishoon.top/tags/%E8%B6%85%E7%BA%A7%E8%B4%A6%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Hyperledger Fabric 源码精读（1）</title>
    <link href="http://cishoon.top/fabric/fabric%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AF%BB%20(1)/"/>
    <id>http://cishoon.top/fabric/fabric%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AF%BB%20(1)/</id>
    <published>2024-09-08T16:00:00.000Z</published>
    <updated>2024-09-15T09:02:54.355Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>开坑，学习 Fabric 的源码。</p></li><li><p>思路是根据 <code>fabric-sample</code> 的<code>test-network</code>中的脚本，一行行分析。遇到里面使用的指令，看源码如何实现。</p></li><li><p>下面内容非常混乱，写的毫无逻辑，之后有空重新整理一遍。</p></li><li><p>一口气写完太长了，typora里会卡了，分章节发。</p></li><li><p>学习笔记，不保证内容正确性。</p></li></ul><span id="more"></span><h1 id="文件结构概览">0 文件结构概览</h1><ol type="1"><li><p>ccaas_builder:包含构建链代码即服务（CCaaS）相关命令的代码。</p></li><li><p>ci:包含持续集成（CI）相关的脚本，用于自动化测试和构建过程。</p></li><li><p><strong>cmd</strong>:包含Fabric项目中各种命令行工具的实现代码，如<code>configtxgen</code>、<code>cryptogen</code>、<code>peer</code>等。</p></li><li><p><strong>common</strong>:包含Fabric项目中各模块通用的功能模块，如加密、配置、错误处理等。</p></li><li><p><strong>core</strong>:实现了Fabric的核心功能，如ACL管理、链代码生命周期、提交人、账本管理、策略管理等。</p></li><li><p><strong>discovery</strong>:处理Fabric中的服务发现功能，包括客户端、命令行工具、背书策略等。</p></li><li><p>docs: 文档生成工具及相关资源文件。</p></li><li><p><strong>gossip</strong>:包含实现Fabric中gossip协议的相关代码，用于网络节点间的数据传播与共识。</p></li><li><p>images:包含Fabric各组件的Docker镜像构建文件，如<code>peer</code>、<code>orderer</code>等。</p></li><li><p>integration:包含集成测试相关的代码，用于验证Fabric各组件间的相互作用。</p></li><li><p><strong>internal</strong>:包含Fabric内部使用的一些模块和工具，如配置生成器、加密工具等。</p></li><li><p><strong>msp</strong>:包含成员服务提供者（MSP）相关的代码，用于管理组织的身份和证书。</p></li><li><p><strong>orderer</strong>:包含排序服务节点（Orderer）相关的功能模块，如共识机制实现、样例客户端等。</p></li><li><p>pkg:包含一些通用的包和工具，如状态数据和交易处理相关的代码。</p></li><li><p>protoutil: 包含与Protobuf相关的工具和测试文件。</p></li><li><p>release_notes: 包含项目的发行说明，记录版本更新和变化。</p></li><li><p>sampleconfig:包含一些样例配置文件，如MSP配置，用于演示和测试。</p></li><li><p>scripts: 包含各种脚本文件，用于辅助项目的构建和部署。</p></li><li><p>swagger:用于生成Swagger文档的文件，Swagger用于API文档的生成。</p></li><li><p>tools: 包含一些额外的工具和实用程序。</p></li><li><p>vagrant: 包含用于创建虚拟开发环境的Vagrant配置文件。</p></li><li><p>vendor: 包含Fabric项目依赖的第三方库和包。</p></li></ol><h1 id="networkup">1 networkUp</h1><h2 id="证书生成与msp">1.1 证书生成与MSP</h2><p>启动网络首先会执行证书生成。</p><p>fabric 提供三种证书生成的工具：<code>cryptogen</code><code>cfssl</code> <code>Fabric CA</code>。这里先以<code>cryptogen</code> 为例，后续补充 <code>Fabric CA</code>的实现。</p><h3 id="cryptogen">1.1.1 cryptogen</h3><p><code>cryptogen</code> 是 fabric 提供的一个命令行工具。</p><p>命令帮助：https://hyperledger-fabric.readthedocs.io/zh-cn/latest/commands/cryptogen.html</p><p>它为测试提供了一种预配置网络的工具。通常它<strong>不应使用在生产环境中</strong>。</p><p>networkUp中执行如下指令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cryptogen generate --config=./organizations/cryptogen/crypto-config-org1.yaml --output="organizations"</span><br><span class="line">cryptogen generate --config=./organizations/cryptogen/crypto-config-org2.yaml --output="organizations"</span><br><span class="line">cryptogen generate --config=./organizations/cryptogen/crypto-config-orderer.yaml --output="organizations"</span><br></pre></td></tr></table></figure><p><code>cryptogen generate</code>用于生成秘钥材料。指定两个参数，分别是配置文件和输出目录。</p><p>配置文件结构如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># "OrdererOrgs" - 管理orderer节点的组织定义</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="attr">OrdererOrgs:</span></span><br><span class="line">  <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">  <span class="comment"># Orderer</span></span><br><span class="line">  <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">Name:</span> <span class="string">Orderer</span></span><br><span class="line">    <span class="attr">Domain:</span> <span class="string">example.com</span></span><br><span class="line">    <span class="attr">EnableNodeOUs:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment"># "Specs" - 完整描述请参见下面的PeerOrgs</span></span><br><span class="line">    <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">    <span class="attr">Specs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">Hostname:</span> <span class="string">orderer</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># "PeerOrgs" - 管理peer节点的组织定义</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="attr">PeerOrgs:</span></span><br><span class="line">  <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">  <span class="comment"># Org1</span></span><br><span class="line">  <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">Name:</span> <span class="string">Org1</span></span><br><span class="line">    <span class="attr">Domain:</span> <span class="string">org1.example.com</span></span><br><span class="line">    <span class="attr">EnableNodeOUs:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment"># "CA"</span></span><br><span class="line">    <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment"># 取消注释这个部分以启用这个组织的CA的显式定义。</span></span><br><span class="line">    <span class="comment"># 这个条目是一个Spec。详细信息请参见下面的"Specs"部分。</span></span><br><span class="line">    <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment"># CA:</span></span><br><span class="line">    <span class="comment">#    Hostname: ca # 默认为ca.org1.example.com</span></span><br><span class="line">    <span class="comment">#    Country: US</span></span><br><span class="line">    <span class="comment">#    Province: California</span></span><br><span class="line">    <span class="comment">#    Locality: San Francisco</span></span><br><span class="line">    <span class="comment">#    OrganizationalUnit: Hyperledger Fabric</span></span><br><span class="line">    <span class="comment">#    StreetAddress: org的地址 # 默认为nil</span></span><br><span class="line">    <span class="comment">#    PostalCode: org的邮政编码 # 默认为nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment"># "Specs"</span></span><br><span class="line">    <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment"># 取消注释这个部分以在配置中启用主机的显式定义。</span></span><br><span class="line">    <span class="comment"># 大多数用户会使用下面的Template。</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># Specs是Spec条目的数组。每个Spec条目由两个字段组成：</span></span><br><span class="line">    <span class="comment">#   - Hostname:   (必需) 期望的主机名，不包括域名部分。</span></span><br><span class="line">    <span class="comment">#   - CommonName: (可选) 指定CN的模板或显式覆盖。</span></span><br><span class="line">    <span class="comment">#                 默认情况下，这是一个模板：</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#                              "{{.Hostname}}.{{.Domain}}"</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#                 它的值分别从Spec.Hostname和Org.Domain中获取。</span></span><br><span class="line">    <span class="comment">#   - SANS:       (可选) 指定将在生成的x509中设置的一个或多个主题备用名称。</span></span><br><span class="line">    <span class="comment">#                 接受模板变量{{.Hostname}}, {{.Domain}}, {{.CommonName}}。</span></span><br><span class="line">    <span class="comment">#                 这里提供的IP地址将被正确识别。其他值将被视为DNS名称。</span></span><br><span class="line">    <span class="comment">#                 注意：会为你创建两个隐式条目：</span></span><br><span class="line">    <span class="comment">#                     - {{ .CommonName }}</span></span><br><span class="line">    <span class="comment">#                     - {{ .Hostname }}</span></span><br><span class="line">    <span class="comment">#                 即：SANS里定义的域名也会被指向这个节点，证书会认为这些域名是这个节点的合法别名。</span></span><br><span class="line">    <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment"># Specs:</span></span><br><span class="line">    <span class="comment">#   - Hostname: foo # 默认为"foo.org1.example.com"</span></span><br><span class="line">    <span class="comment">#     CommonName: foo27.org5.example.com # 覆盖基于主机名的上面设置的FQDN</span></span><br><span class="line">    <span class="comment">#     SANS:</span></span><br><span class="line">    <span class="comment">#       - "bar.{{.Domain}}"</span></span><br><span class="line">    <span class="comment">#       - "altfoo.{{.Domain}}"</span></span><br><span class="line">    <span class="comment">#       - "{{.Hostname}}.org6.net"</span></span><br><span class="line">    <span class="comment">#       - 172.16.10.31</span></span><br><span class="line">    <span class="comment">#   - Hostname: bar</span></span><br><span class="line">    <span class="comment">#   - Hostname: baz</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment"># "Template"</span></span><br><span class="line">    <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment"># 允许从模板中顺序生成一个或多个主机。</span></span><br><span class="line">    <span class="comment"># 默认情况下，这看起来像是从0到Count-1的"peer%d"。</span></span><br><span class="line">    <span class="comment"># 你可以覆盖节点数（Count）、起始索引（Start）或用于构建名称的模板（Hostname）。</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># 注意：Template和Specs不是互斥的。你可以定义这两个部分，系统会为你创建聚合的节点。</span></span><br><span class="line">    <span class="comment"># 注意名称冲突</span></span><br><span class="line">    <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">    <span class="attr">Template:</span></span><br><span class="line">      <span class="attr">Count:</span> <span class="number">1</span></span><br><span class="line">      <span class="comment"># Start: 5</span></span><br><span class="line">      <span class="comment"># Hostname: {{.Prefix}}{{.Index}} # 默认</span></span><br><span class="line">      <span class="comment"># SANS:</span></span><br><span class="line">      <span class="comment">#   - "{{.Hostname}}.alt.{{.Domain}}"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment"># "Users"</span></span><br><span class="line">    <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment"># Count: 除Admin外的用户账户数量</span></span><br><span class="line">    <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">    <span class="attr">Users:</span></span><br><span class="line">      <span class="attr">Count:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">  <span class="comment"># Org2: 完整规范请参见"Org1"</span></span><br><span class="line">  <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">Name:</span> <span class="string">Org2</span></span><br><span class="line">    <span class="attr">Domain:</span> <span class="string">org2.example.com</span></span><br><span class="line">    <span class="attr">EnableNodeOUs:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">Template:</span></span><br><span class="line">      <span class="attr">Count:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">Users:</span></span><br><span class="line">      <span class="attr">Count:</span> <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行 <code>cryptogen generate</code> 会遍历创建所有配置文件中定义的<code>Ordered</code> 和 <code>Peer</code>节点的<strong>组织</strong>。注意这里是组织，一个组织里面可以包含很多个节点。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">()</span></span> {</span><br><span class="line">config, err := getConfig() <span class="comment">// 读取配置文件，反序列化成config</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Printf(<span class="string">"Error reading config: %s"</span>, err)</span><br><span class="line">os.Exit(<span class="number">-1</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, orgSpec := <span class="keyword">range</span> config.PeerOrgs {</span><br><span class="line">err = renderOrgSpec(&amp;orgSpec, <span class="string">"peer"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Printf(<span class="string">"Error processing peer configuration: %s"</span>, err)</span><br><span class="line">os.Exit(<span class="number">-1</span>)</span><br><span class="line">}</span><br><span class="line">generatePeerOrg(*outputDir, orgSpec)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, orgSpec := <span class="keyword">range</span> config.OrdererOrgs {</span><br><span class="line">err = renderOrgSpec(&amp;orgSpec, <span class="string">"orderer"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Printf(<span class="string">"Error processing orderer configuration: %s"</span>, err)</span><br><span class="line">os.Exit(<span class="number">-1</span>)</span><br><span class="line">}</span><br><span class="line">generateOrdererOrg(*outputDir, orgSpec)</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><code>renderOrgSpec</code>：处理配置文件中的<code>OrgSpec</code>，完成配置文件中模板的处理。即完整定义一个组织中的所有节点。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">renderOrgSpec</span><span class="params">(orgSpec *OrgSpec, prefix <span class="type">string</span>)</span></span> <span class="type">error</span> {</span><br><span class="line"><span class="comment">// 获取配置文件中定义的公钥算法，默认为ECDSA</span></span><br><span class="line">publickKeyAlg := getPublicKeyAlg(orgSpec.Template.PublicKeyAlgorithm)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先处理Template的配置，自动根据模板生成Specs</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; orgSpec.Template.Count; i++ {</span><br><span class="line">data := HostnameData{</span><br><span class="line">Prefix: prefix,</span><br><span class="line">Index:  i + orgSpec.Template.Start,</span><br><span class="line">Domain: orgSpec.Domain,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成完整的域名</span></span><br><span class="line">hostname, err := parseTemplateWithDefault(orgSpec.Template.Hostname, defaultHostnameTemplate, data)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">spec := NodeSpec{</span><br><span class="line">Hostname:           hostname,</span><br><span class="line">SANS:               orgSpec.Template.SANS,</span><br><span class="line">PublicKeyAlgorithm: publickKeyAlg,</span><br><span class="line">}</span><br><span class="line">orgSpec.Specs = <span class="built_in">append</span>(orgSpec.Specs, spec)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再处理Specs中显式定义的Specs</span></span><br><span class="line"><span class="keyword">for</span> idx, spec := <span class="keyword">range</span> orgSpec.Specs {</span><br><span class="line">err := renderNodeSpec(orgSpec.Domain, &amp;spec)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">orgSpec.Specs[idx] = spec</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样处理CA节点</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(orgSpec.CA.Hostname) == <span class="number">0</span> {</span><br><span class="line">orgSpec.CA.Hostname = <span class="string">"ca"</span></span><br><span class="line">}</span><br><span class="line">err := renderNodeSpec(orgSpec.Domain, &amp;orgSpec.CA)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><code>generatePeerOrg</code> /<code>generateOrderedOrg</code>：Ordered与Peer类似，区别只在于生成的nodeType是PEER还是Ordered</p><ul><li><p><strong>生成Signing证书</strong></p></li><li><p><strong>生成CA证书</strong></p><p>生成证书的通过调用ca.NewCA方法，给定地址、街道等基本信息和加密算法，自动生成私钥和公钥</p><p>证书的版本是X.509</p></li><li><p><strong>生成验证 MSP</strong></p><p><code>GenerateVerifyingMSP</code> 函数负责生成 Hyperledger Fabric中验证 MSP（Membership ServiceProvider）所需的工件。以下是其功能的简要说明：</p><ol type="1"><li><p><strong>创建文件夹结构</strong>： 该函数首先通过<code>createFolderStructure</code> 创建所需的文件夹结构：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := createFolderStructure(baseDir, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure></p></li><li><p><strong>导出 CA 证书</strong>： 它将签名 CA 和 TLS CA证书导出到相应的目录： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err = x509Export(filepath.Join(baseDir, <span class="string">"cacerts"</span>, x509Filename(signCA.Name)), signCA.SignCert)</span><br><span class="line">err = x509Export(filepath.Join(baseDir, <span class="string">"tlscacerts"</span>, x509Filename(tlsCA.Name)), tlsCA.SignCert)</span><br></pre></td></tr></table></figure></p></li><li><p><strong>生成 <code>config.yaml</code></strong>： 如果启用了<code>nodeOUs</code>，则生成 <code>config.yaml</code> 文件：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> nodeOUs {</span><br><span class="line">    exportConfig(baseDir, <span class="string">"cacerts/"</span>+x509Filename(signCA.Name), <span class="literal">true</span>)</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li><li><p><strong>创建管理员证书</strong>： 如果未启用<code>nodeOUs</code>，则为单元测试创建一个临时的管理员证书：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> !nodeOUs {</span><br><span class="line">    ksDir := filepath.Join(baseDir, <span class="string">"keystore"</span>)</span><br><span class="line">    err = os.Mkdir(ksDir, <span class="number">0o755</span>)</span><br><span class="line">    <span class="keyword">defer</span> os.RemoveAll(ksDir)</span><br><span class="line">    priv, err := csp.GeneratePrivateKey(ksDir, keyAlg)</span><br><span class="line">    _, err = signCA.SignCertificate(</span><br><span class="line">        filepath.Join(baseDir, <span class="string">"admincerts"</span>),</span><br><span class="line">        signCA.Name,</span><br><span class="line">        <span class="literal">nil</span>,</span><br><span class="line">        <span class="literal">nil</span>,</span><br><span class="line">        getPublicKey(priv),</span><br><span class="line">        x509.KeyUsageDigitalSignature,</span><br><span class="line">        []x509.ExtKeyUsage{},</span><br><span class="line">    )</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li></ol><p>该函数确保所有必要的 MSP工件都已生成并放置在正确的目录中，从而便于设置 Hyperledger Fabric中的验证 MSP。</p><blockquote><p>MSP 的功能是什么？</p><p>nodeOUs是什么？</p></blockquote></li><li><p><strong>生成所有 PEER 节点</strong></p><p>遍历 <code>orgSpec.Specs</code> ，给每一个节点调用<code>msp.GenerateLocalMSP</code> 生成 MSP</p><p><code>GenerateLocalMSP</code> 函数用于生成本地 MSP（MembershipService Provider）身份和 TLS（Transport LayerSecurity）证书。以下是对该函数的简要解释：</p><ol type="1"><li><p><strong>创建文件夹结构</strong>： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mspDir := filepath.Join(baseDir, <span class="string">"msp"</span>)</span><br><span class="line">tlsDir := filepath.Join(baseDir, <span class="string">"tls"</span>)</span><br><span class="line">err := createFolderStructure(mspDir, <span class="literal">true</span>)</span><br><span class="line">err = os.MkdirAll(tlsDir, <span class="number">0o755</span>)</span><br></pre></td></tr></table></figure> 该部分代码创建MSP 和 TLS 所需的文件夹结构。</p></li><li><p><strong>生成私钥</strong>： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">keystore := filepath.Join(mspDir, <span class="string">"keystore"</span>)</span><br><span class="line">priv, err := csp.GeneratePrivateKey(keystore, keyAlg)</span><br></pre></td></tr></table></figure> 生成 MSP 的私钥并存储在<code>keystore</code> 文件夹中。</p></li><li><p><strong>生成 X509 证书</strong>： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cert, err := signCA.SignCertificate(</span><br><span class="line">    filepath.Join(mspDir, <span class="string">"signcerts"</span>),</span><br><span class="line">    name,</span><br><span class="line">    ous,</span><br><span class="line">    <span class="literal">nil</span>,</span><br><span class="line">    getPublicKey(priv),</span><br><span class="line">    x509.KeyUsageDigitalSignature,</span><br><span class="line">    []x509.ExtKeyUsage{},</span><br><span class="line">)</span><br></pre></td></tr></table></figure> 使用签名 CA 生成X509 证书，并将其存储在 <code>signcerts</code> 文件夹中。</p></li><li><p><strong>导出 CA 证书</strong>： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err = x509Export(</span><br><span class="line">    filepath.Join(mspDir, <span class="string">"cacerts"</span>, x509Filename(signCA.Name)),</span><br><span class="line">    signCA.SignCert,</span><br><span class="line">)</span><br><span class="line">err = x509Export(</span><br><span class="line">    filepath.Join(mspDir, <span class="string">"tlscacerts"</span>, x509Filename(tlsCA.Name)),</span><br><span class="line">    tlsCA.SignCert,</span><br><span class="line">)</span><br></pre></td></tr></table></figure> 将签名 CA 和 TLSCA 的证书分别导出到 <code>cacerts</code> 和 <code>tlscacerts</code>文件夹中。</p></li><li><p><strong>生成 config.yaml</strong>： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> nodeOUs {</span><br><span class="line">    exportConfig(mspDir, filepath.Join(<span class="string">"cacerts"</span>, x509Filename(signCA.Name)), <span class="literal">true</span>)</span><br><span class="line">}</span><br></pre></td></tr></table></figure> 如果启用了节点OU（Organizational Units），则生成 <code>config.yaml</code>配置文件。</p></li><li><p><strong>生成 TLS 证书</strong>： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tlsPrivKey, err := csp.GeneratePrivateKey(tlsDir, keyAlg)</span><br><span class="line">_, err = tlsCA.SignCertificate(</span><br><span class="line">    filepath.Join(tlsDir),</span><br><span class="line">    name,</span><br><span class="line">    <span class="literal">nil</span>,</span><br><span class="line">    sans,</span><br><span class="line">    getPublicKey(tlsPrivKey),</span><br><span class="line">    x509.KeyUsageDigitalSignature|x509.KeyUsageKeyEncipherment,</span><br><span class="line">    []x509.ExtKeyUsage{</span><br><span class="line">        x509.ExtKeyUsageServerAuth,</span><br><span class="line">        x509.ExtKeyUsageClientAuth,</span><br><span class="line">    },</span><br><span class="line">)</span><br></pre></td></tr></table></figure> 生成 TLS私钥和证书，并将其存储在 TLS 文件夹中。</p></li><li><p><strong>重命名 TLS 证书</strong>：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tlsFilePrefix := <span class="string">"server"</span></span><br><span class="line"><span class="keyword">if</span> nodeType == CLIENT || nodeType == ADMIN {</span><br><span class="line">    tlsFilePrefix = <span class="string">"client"</span></span><br><span class="line">}</span><br><span class="line">err = os.Rename(filepath.Join(tlsDir, x509Filename(name)),</span><br><span class="line">    filepath.Join(tlsDir, tlsFilePrefix+<span class="string">".crt"</span>))</span><br></pre></td></tr></table></figure><p>根据节点类型重命名生成的 TLS 证书。</p></li><li><p><strong>导出私钥</strong>： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err = keyExport(tlsDir, filepath.Join(tlsDir, tlsFilePrefix+<span class="string">".key"</span>))</span><br></pre></td></tr></table></figure>将私钥导出到指定文件中。</p></li></ol><p>该函数的主要目的是生成和配置 MSP 和 TLS所需的各种证书和密钥文件。</p><blockquote><p><code>GenerateLocalMSP</code> 和 <code>GenerateVerifyingMSP</code>函数的主要区别在于它们的用途和生成的内容：</p><ol type="1"><li><strong><code>GenerateLocalMSP</code></strong>:<ul><li>主要用于生成本地 MSP（Membership Service Provider）身份工件。</li><li>创建文件夹结构并生成私钥。</li><li>使用签名 CA 生成 X509 证书。</li><li>将签名 CA 证书和 TLS CA 证书分别写入 <code>cacerts</code> 和<code>tlscacerts</code> 文件夹。</li><li>如果启用了节点 OU（Organizational Units），则生成<code>config.yaml</code> 配置文件。</li><li>生成 TLS 工件，包括私钥和 X509 证书。</li><li>适用于需要完整 MSP 身份的节点，如客户端、排序节点或对等节点。</li></ul></li><li><strong><code>GenerateVerifyingMSP</code></strong>:<ul><li>主要用于生成验证 MSP 工件。</li><li>创建文件夹结构并写入签名 CA 和 TLS CA 证书。</li><li>如果启用了节点 OU，则生成 <code>config.yaml</code> 配置文件。</li><li>生成一个临时的管理员证书用于单元测试。</li><li>适用于只需要验证 MSP 身份的场景，不需要生成完整的本地 MSP身份。</li></ul></li></ol>总结：<ul><li><code>GenerateLocalMSP</code> 生成完整的本地 MSP身份，包括私钥和证书。</li><li><code>GenerateVerifyingMSP</code> 生成用于验证的 MSP 工件，主要包含CA 证书和配置文件。</li></ul></blockquote></li><li><p><strong>生成所有用户节点（CLIENT和ADMIN）</strong></p><p>同上，给每一个节点调用 <code>msp.GenerateLocalMSP</code></p></li><li><p><strong>复制管理员证书到相应的文件夹</strong></p></li></ul><h3 id="msp">1.1.2 MSP</h3><p>可见上面的 <code>cryptogen generate</code>只干了两件事，生成各种CA证书和生成MSP。</p><p>那MSP是什么？这几种类型有什么区别？<code>LocalMSP</code> 和<code>VerifyingMSP</code> 有什么区别？<code>nodeOUs</code>的作用是什么？</p><p>身份认证机构（Certificate Authorities,CA）通过生成公钥和私钥对来发行身份，这对密钥可以用来证明身份。这个身份需要被网络识别，这时就需要用到会员服务提供者（MembershipService Provider,MSP）。例如，一个节点（peer）使用其私钥对交易进行数字签名或背书。MSP用来检查该节点是否有权背书交易。然后使用节点证书中的公钥来验证附加在交易上的签名是否有效。因此，MSP是允许该身份被网络其他成员信任和识别的机制。</p><p>可以将CA比作信用卡提供商，它发行多种可验证的身份。而MSP则决定哪些信用卡提供商在商店被接受。</p><p>CA 提供身份，MSP 验证你的身份能不能在我这里用。</p><p>在 <code>fabric-samples</code> 的<code>asset-transfer-basic/application-gateway</code> 中，上面由<code>cryptogen</code> 生成的 MSP 证书和CA签名被用作创建身份和签名，与网关建立连接。</p><p>可以推测，在初始构建区块链网络时，验证MSP会被作为配置加载到网络里。</p><p>在 Hyperledger Fabric 中，<code>NodeOUs</code> 是 Membership ServiceProvider (MSP)配置的一部分，用于定义和区分网络中不同节点的角色（身份）类型。<code>OU</code>代表 "Organizational Unit"（组织单位），通过配置<code>NodeOUs</code>，你可以明确指定每个节点在网络中的角色，例如是 Peer节点、Orderer 节点，还是客户端等。</p><p><code>NodeOUs</code> 的作用：</p><ol type="1"><li><strong>角色区分</strong>：通过<code>NodeOUs</code>，可以在网络中区分不同的节点类型。例如，MSP可以配置哪些证书对应 Peer 节点，哪些证书对应 Orderer 节点。</li><li><strong>访问控制</strong>：在 Hyperledger Fabric中，<code>NodeOUs</code>配置有助于实施更精细的访问控制策略。不同角色的节点可以被赋予不同的权限和职责，从而确保网络的安全性和有效性。</li><li><strong>身份验证</strong>：当一个节点加入网络或执行操作时，MSP会使用 <code>NodeOUs</code>配置来验证该节点的身份，并确保它符合其配置的角色。例如，只有被正确标识为Orderer 的节点，才能参与共识过程。</li></ol><p>MSP 这部分感觉还没有完全理解。因为到这里，才刚刚完成了 MSP配置文件的创建，具体的验证逻辑等等还在后面。先留个印象，MSP的作用是验证用户身份的。</p><h2 id="docker-compose">1.2 docker-compose</h2><p>至此，test-network完成了组织的创建。得到的文件（证书和秘钥）都保存在本地的<code>organization</code> 文件夹中。</p><p>接下来，就是使用 <code>docker-compose</code> 进行网络的创建。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose -f compose/compose-test-net.yaml -f compose/docker/docker-compose-test-net.yaml</span><br></pre></td></tr></table></figure><blockquote><p>在 <code>docker-compose</code> 中，你可以使用多个 <code>-f</code>选项来指定多个 YAML文件。这样做的目的是将这些文件的内容合并起来，以便更灵活地配置和管理Docker 服务。</p></blockquote><h3 id="具体执行内容">1.2.1 具体执行内容</h3><p>具体来说，这个 <code>docker-compose</code> 文件启动了一个 HyperledgerFabric 测试网络，它包括以下组件：</p><ol type="1"><li><strong>网络和卷配置</strong></li></ol><ul><li><strong>Volumes</strong>: 定义了三个卷，用于持久化<code>orderer.example.com</code>、<code>peer0.org1.example.com</code> 和<code>peer0.org2.example.com</code>节点的数据。这些卷确保了即使容器停止或重启，数据仍然可以保留。</li><li><strong>Networks</strong>: 定义了一个名为 <code>fabric_test</code>的 Docker 网络，所有服务将会连接到这个网络中以便相互通信。</li></ul><ol start="2" type="1"><li><strong>服务（Services）</strong></li></ol><ul><li><p><strong>Orderer 节点：orderer.example.com</strong></p><ul><li><p><strong>Container Name</strong>:<code>orderer.example.com</code></p></li><li><p><strong>Image</strong>: 使用了最新版本的<code>hyperledger/fabric-orderer</code> 镜像。</p></li><li><p><strong>Environment</strong>:</p><ul><li>配置了 Fabric 的日志级别为 <code>INFO</code>。</li><li>配置了 Orderer 的监听地址和端口。</li><li>使用 <code>OrdererMSP</code> 作为本地 MSP（Membership ServiceProvider）。</li><li>启用了 TLS，并提供了 TLS 的证书和密钥路径。</li><li>配置了 Orderer 的管理端口（7053）和操作端口（9443），以及相关的 TLS设置。</li></ul></li><li><p><strong>Volumes</strong>: 挂载了组织相关的 MSP 和 TLS证书目录，及 Orderer 的数据存储目录。</p></li><li><p><strong>Ports</strong>: 暴露了 Orderer 的主要端口 7050、管理端口7053、以及操作端口 9443。</p></li><li><p><strong>Networks</strong>: 连接到 <code>fabric_test</code>网络。</p></li><li><p><strong>Command</strong>：<code>orderer</code></p></li></ul></li><li><p><strong>Peer 节点：peer0.org1.example.com</strong></p><ul><li><p><strong>Container Name</strong>:<code>peer0.org1.example.com</code></p></li><li><p><strong>Image</strong>: 使用了最新版本的<code>hyperledger/fabric-peer</code> 镜像。</p></li><li><p><strong>Environment</strong>:</p><ul><li>配置了 Fabric 的日志级别为 <code>INFO</code>。</li><li>启用了 TLS，并提供了 TLS 的证书和密钥路径。</li><li>设置了该节点的 ID 为<code>peer0.org1.example.com</code>，并配置了监听地址。</li><li>配置了节点的 Gossip 协议启动节点和外部端点地址。</li><li>使用 <code>Org1MSP</code> 作为本地 MSP。</li><li>配置了节点的操作端口（9444）和链码执行超时（300秒）。</li></ul></li><li><p><strong>Volumes</strong>: 挂载了组织相关的 MSP 和 TLS证书目录，及节点的数据存储目录。</p></li><li><p><strong>Ports</strong>: 暴露了 Peer 节点的主要端口 7051、操作端口9444。</p></li><li><p><strong>Networks</strong>: 连接到 <code>fabric_test</code>网络。</p></li><li><p><strong>Command</strong>：<code>peer node start</code></p></li></ul></li><li><p><strong>Peer 节点：peer0.org2.example.com</strong></p><ul><li>与上面org1的类似</li></ul></li></ul><ol start="3" type="1"><li><strong>Additional Configuration in the Second ComposeFile</strong></li></ol><p>在第二个 <code>docker-compose</code> 文件中，针对<code>peer0.org1.example.com</code> 和<code>peer0.org2.example.com</code> 这两个节点，增加了一些额外的配置： -<strong>CORE_VM_ENDPOINT</strong>: 配置了 Docker 守护进程的 Unix套接字，用于管理容器内的虚拟机。 -<strong>CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE</strong>: 设置了 Docker网络模式为 <code>fabric_test</code>。</p><h3 id="fabric-orderer-fabric-peer-镜像">1.2.2<code>fabric-orderer</code> / <code>fabric-peer</code> 镜像</h3><p>源码仓库中 <code>fabric/image</code> 路径下可以找到他们的Dockerfile。</p><p>简而言之，这个 Dockerfile 的设计分为两个阶段：</p><ol type="1"><li>首先在构建阶段生成所需的二进制文件（包括<code>peer</code>/<code>orderer</code> 和 CCaaS 相关组件）</li><li>然后在运行时阶段，将这些构建产物打包到一个精简的 Ubuntu镜像中，并配置好环境变量和默认启动命令</li></ol><p>那接下来主要关注的就是 <code>orderer</code> 和 <code>peer</code>的具体实现了。根据镜像启动的顺序，先看 <code>orderer</code>。</p><h3 id="peer">1.2.3 peer</h3><h3 id="orderer">1.2.4 orderer</h3><p>暂时理解不了 <code>peer</code> 和 <code>orderer</code>是怎么进行网络通信的，先放一放，看看后面干了什么，确定一下这两个指令干的事情的范围</p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;开坑，学习 Fabric 的源码。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;思路是根据 &lt;code&gt;fabric-sample&lt;/code&gt; 的
&lt;code&gt;test-network&lt;/code&gt;
中的脚本，一行行分析。遇到里面使用的指令，看源码如何实现。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下面内容非常混乱，写的毫无逻辑，之后有空重新整理一遍。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一口气写完太长了，typora里会卡了，分章节发。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;学习笔记，不保证内容正确性。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://cishoon.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="区块链" scheme="http://cishoon.top/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="go" scheme="http://cishoon.top/tags/go/"/>
    
    <category term="fabric" scheme="http://cishoon.top/tags/fabric/"/>
    
    <category term="超级账本" scheme="http://cishoon.top/tags/%E8%B6%85%E7%BA%A7%E8%B4%A6%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>AXI 系统总线</title>
    <link href="http://cishoon.top/blockchain/AXI/"/>
    <id>http://cishoon.top/blockchain/AXI/</id>
    <published>2024-08-26T16:00:00.000Z</published>
    <updated>2024-09-05T05:37:00.024Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文属于学习笔记，内容可能有误、可能不全面，仅代表个人在学习这一知识时的理解和总结</p></blockquote><p>第一次接触AMBA AXI系统总线，学习 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXJtLmNvbS9kb2N1bWVudGF0aW9uLzEwMjIwMi8wMzAwP2xhbmc9ZW4=">Learnthe architecture - An introduction to AMBA AXI<i class="fa fa-external-link-alt"></i></span> ，做到笔记。</p><span id="more"></span><h1 id="amba">AMBA</h1><h2 id="qa">Q&amp;A</h2><blockquote><p>什么是AMBA？</p></blockquote><p>AMBA（Advanced Microcontroller BusArchitecture）是由ARM公司开发的一种标准化的芯片内部总线协议，简单来说，它就是一种让芯片内部不同部分能够快速、可靠地相互通信的“高速公路”。在一个芯片里，有很多不同的“模块”，比如处理器、内存、输入输出设备等等，这些模块需要彼此传递数据，而AMBA就是负责管理这些数据怎么传输的。</p><blockquote><p>在AMBA提出之前，芯片内部的各个模块应该也能传递数据，那时候是怎么实现数据传递的？</p></blockquote><p>在AMBA提出之前，芯片内部各个模块之间的确已经能够实现数据传递，但方式较为复杂和不统一。以下是一些在AMBA之前常见的数据传输方式：</p><ol type="1"><li><p><strong>定制总线</strong></p><p>在AMBA出现之前，芯片制造商通常会为每个项目定制设计自己的总线系统。这种定制总线完全由设计团队根据具体需求设计，缺乏统一的标准。这意味着每个新项目可能需要重新设计数据传输的方式，耗时且复杂。</p><p>缺点：</p><pre><code>- 缺乏标准化，导致设计难度大。- 不同模块之间的接口可能不兼容，集成和调试复杂。- 难以重复使用设计，增加开发成本和时间。</code></pre></li><li><p><strong>共享总线架构</strong></p><p>在一些设计中，多个模块会共享同一条总线。这种架构较为简单，但由于所有模块都使用同一条总线，可能会产生“总线争用”的问题，即多个模块同时请求访问总线，导致数据传输的延迟或效率下降。</p><p>缺点：</p><ul><li>总线带宽有限，当多个模块同时访问时，容易产生瓶颈。</li><li>缺乏灵活性，难以适应复杂的多模块通信需求。</li></ul></li><li><p><strong>专用接口</strong></p><p>一些芯片设计会为特定模块之间的通信设计专用的接口。这种方式虽然在特定场景下效率较高，但其灵活性很差。每对模块之间需要专用的连接，这使得芯片设计复杂度大幅增加。</p><p>缺点：</p><pre><code>- 专用接口需要针对每对模块单独设计，增加了设计工作量。- 难以扩展，增加新模块时需要重新设计接口。</code></pre></li></ol><p>AMBA的提出为这些问题提供了一个解决方案。它标准化了芯片内部的通信，允许设计者使用一套通用的协议和总线结构来连接不同的模块。这样一来，不仅减少了设计复杂度，也提高了模块之间的兼容性和重用性，使得芯片设计变得更高效、更灵活。</p><p>通过AMBA，总线系统可以自动处理诸如优先级、仲裁等复杂问题，开发者只需要专注于模块本身的设计，而不必再花费大量时间去解决数据传输的问题。</p><blockquote><p>AMBA是什么时候提出的？</p></blockquote><p>AMBA（Advanced Microcontroller BusArchitecture）最早是由ARM公司在<strong>1996年</strong>提出的。最初的版本被称为AMBA2.0，后来逐步发展出更高级的版本，如AMBA 3和AMBA4，分别引入了更先进的功能和特性，以适应不断发展的嵌入式系统需求。</p><p>AMBA 2.0版本主要引入了两种总线：AHB（Advanced High-performanceBus）和 APB（Advanced PeripheralBus）。在后续的版本中，<strong>AXI（Advanced eXtensibleInterface）</strong>等新总线协议被引入，以支持更高性能和更复杂的系统设计。</p><p>AMBA的推出标志着嵌入式系统设计进入了一个新的标准化阶段，使得芯片设计和模块集成变得更加高效和灵活。</p><h2 id="总结">总结</h2><p>AMBA是一个<strong>标准化协议</strong>，用于芯片内部各个模块之间的数据传输。</p><p>使用AMBA，可以一定程度降低嵌入式系统设计的复杂度。</p><p>AXI是AMBA 3.0提出的总线协议，下面详细学习AXI的设计，理解他的工作原理和使用方法，感受为什么AXI总线能够降低设计的复杂度。</p><p>以及，有很多其他现成的IP核，使用的是AXI总线。如果我想设计一个模块与其他IP核连接，必须在我的模块里实现AXI总线。</p><h1 id="axi-总线协议">AXI 总线协议</h1><h2 id="详细架构">详细架构</h2><h2 id="关键特性">关键特性</h2><p>AXI协议具有多个关键特性，这些特性旨在提高数据传输和事务处理的带宽和延迟，如下所示：</p><ul><li><strong>独立的读写通道</strong>：AXI支持两组不同的通道，一组用于写操作，另一组用于读操作。拥有两组独立的通道有助于提高接口的带宽性能，因为读写操作可以同时进行。</li><li><strong>多重未完成地址</strong>：AXI允许存在多个未完成的地址。这意味着管理器可以在不等待先前事务完成的情况下发起新事务。这可以提高系统性能，因为它使得事务的并行处理成为可能。</li><li><strong>地址和数据操作之间没有严格的时间关系</strong>：在 AXI中，地址和数据操作之间没有严格的时间关系。这意味着，例如，管理器可以在写地址通道上发出写地址，但没有时间要求规定管理器何时必须在写数据通道上提供相应的数据。</li><li><strong>支持非对齐数据传输</strong>：对于由宽度超过一个字节的数据传输组成的突发传输，访问的首字节可以与自然地址边界不对齐。例如，起始字节地址为0x1002 的 32 位数据包并未对齐到自然的 32 位地址边界。</li><li><strong>乱序事务完成</strong>：AXI 支持乱序事务完成。AXI协议包含事务标识符，不同 ID值的事务完成顺序没有限制。这意味着单个物理端口可以支持乱序事务，通过充当多个逻辑端口，每个逻辑端口按顺序处理其事务。</li><li><strong>基于起始地址的突发事务</strong>：AXI管理器仅发出第一个传输的起始地址。对于后续的任何传输，受控端将根据突发类型计算下一个传输地址。</li></ul><h2 id="传输和事务">传输和事务</h2><p>https://developer.arm.com/documentation/102202/0300/Channel-transfers-and-transactions?lang=en</p><p>简而言之，分为读写两个部分，分别有以下接口：</p><ul><li><strong>写</strong>：<ul><li>Write Address</li><li>Write Data</li><li>Write Response</li></ul></li><li><strong>读</strong>：<ul><li>Read Address</li><li>Read Data （包括Response的内容）</li></ul></li></ul><p>传输就是读或写1个数据的过程。一个事务可以由一个或多个传输组成，也就是可以一次性传输多次。</p><p>传输前需要先握手配对，即主机的VALID和从机的READY均为1时，开始传输。</p><p>写事务是所有数据写入<strong>之后</strong>，返回一个OK。读事务是每读取一个数据的<strong>同时</strong>，返回一个OK。</p><h2 id="信号">信号</h2><p>https://developer.arm.com/documentation/102202/0300/Channel-signals?lang=en</p><p>定义了各个接口的具体信号实现。</p><p>其中提到了安全支持，这在TrustZone中很有用。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文属于学习笔记，内容可能有误、可能不全面，仅代表个人在学习这一知识时的理解和总结&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第一次接触AMBA AXI系统总线，学习 &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9kZXZlbG9wZXIuYXJtLmNvbS9kb2N1bWVudGF0aW9uLzEwMjIwMi8wMzAwP2xhbmc9ZW4=&quot;&gt;Learn
the architecture - An introduction to AMBA AXI&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt; ，做到笔记。&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://cishoon.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="FPGA" scheme="http://cishoon.top/tags/FPGA/"/>
    
    <category term="ARM" scheme="http://cishoon.top/tags/ARM/"/>
    
    <category term="AMBA" scheme="http://cishoon.top/tags/AMBA/"/>
    
  </entry>
  
  <entry>
    <title>EVM 学习笔记</title>
    <link href="http://cishoon.top/blockchain/EVM/"/>
    <id>http://cishoon.top/blockchain/EVM/</id>
    <published>2024-08-24T16:00:00.000Z</published>
    <updated>2024-08-25T06:09:50.613Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文属于学习笔记，内容可能有误、可能不全面，仅代表个人在学习这一特性时的理解和总结</p></blockquote><p>老师安排的任务是EVM智能合约的加速计算，给我的论文提出了一个新的架构……</p><p>但是我还不知道原始的EVM是怎么实现的，所以先学习一下</p><span id="more"></span><h1 id="solidity">1 Solidity</h1><p>Solidity 是一种为实现智能合约而创建的高级编程语言。</p><p>最终跑在以太坊虚拟机(EVM)上的代码，就是由Solidity编译得到的。所以得先学一下Solidity是怎么写的。</p><p>基本的运算规则、语法等等查阅文档：https://learnblockchain.cn/docs/solidity</p><h2 id="数据位置">1.1 数据位置</h2><h3 id="分类">1.1.1 分类</h3><ul><li><code>storage</code>：用于存储状态变量，即需要长期保存的数据，生命周期与合约相同。</li><li><code>memory</code>：用于存储临时变量，可以读写，生命周期在函数执行期间。</li><li><code>calldata</code>：用于存储函数输入参数，是只读的，生命周期在函数执行期间。</li></ul><p><code>storage</code> 存储在区块链上，<code>memory</code>在合约执行过程中的内存中，<code>calldata</code>中的数据来自执行的交易本身（所以不占据额外空间而且是只读的）</p><p>通过 <code>msg.data</code> 可以获取完整的 <code>calldata</code></p><h3 id="默认位置">1.1.2 默认位置</h3><ul><li><strong>状态变量</strong>：默认在<code>storage</code>中。</li><li><strong>函数内部的局部变量</strong>：值类型默认在<code>memory</code>中。</li><li><strong>函数参数</strong>：<ul><li><code>external</code>函数的引用类型参数默认在<code>calldata</code>中。</li><li>其他函数的引用类型参数需要显式指定<code>memory</code>或<code>storage</code>。</li></ul></li><li><strong>返回值</strong>：引用类型默认在<code>memory</code>中。</li></ul><h2 id="函数调用">1.2 函数调用</h2><p>（GPT）</p><p>内部调用和外部调用在Solidity的合约编程中都有不同的行为，在以太坊虚拟机（EVM）的实现中也有显著的区别。以下是这两种调用方式在EVM层面的差异：</p><h3 id="内部调用internal-call">1. <strong>内部调用（InternalCall）</strong></h3><p><strong>特点：</strong></p><ul><li><strong>直接调用</strong>：内部调用是通过直接跳转到目标函数的代码位置来实现的。这是因为内部调用发生在同一合约内部，EVM不需要额外的处理步骤，调用者和被调用者共享相同的上下文和存储。</li><li><strong>无消息传递</strong>：内部调用不涉及消息传递，也没有额外的Gas消耗。因为调用在相同的合约上下文中进行，所有的状态变量和内存都是直接共享的。</li><li><strong>编译优化</strong>：在内部调用时，Solidity编译器可以进行优化，如内联函数（inlinefunctions），使得调用过程更加高效。</li></ul><p><strong>EVM行为：</strong></p><ul><li>EVM中的内部调用相当于一次代码跳转（jump），指令指针直接跳转到目标函数的起始位置。</li><li>内部调用没有创建新的调用栈帧，保持相同的内存、堆栈和存储上下文。</li><li>因为没有新的消息传递（即没有新的合约上下文被创建），内部调用的成本（Gas）相对较低。</li></ul><h3 id="外部调用external-call">2. <strong>外部调用（ExternalCall）</strong></h3><p><strong>特点：</strong></p><ul><li><strong>消息传递</strong>：外部调用涉及到向另一个合约（即使是调用自身的<code>external</code>函数）发送消息，这会创建一个新的合约执行上下文，包括新的堆栈、内存和存储访问。</li><li><strong>新Gas限制</strong>：每次外部调用会分配一个新的Gas限制，这意味着被调用合约的执行有自己独立的Gas预算。如果这个调用消耗了超出分配的Gas，调用将失败并回滚。</li><li><strong>EVM上下文切换</strong>：外部调用会在EVM中引发上下文切换，即从调用者的上下文切换到被调用合约的上下文。这种切换会涉及到堆栈的保存和恢复，以及传递调用数据。</li></ul><p><strong>EVM行为：</strong></p><ul><li>EVM在执行外部调用时，会创建一个新的消息调用（MessageCall）。这包括构建一个新的堆栈帧，传递调用数据（包括函数选择器和参数），以及初始化一个新的存储和内存上下文。</li><li>外部调用会触发EVM的CALL指令。该指令在EVM中相对昂贵，因为它涉及到一系列的操作，如设置新的Gas限制、管理新的堆栈帧、以及潜在的跨合约调用的风险管理（例如重入攻击的防范）。</li><li>外部调用的结果（如返回值或状态变更）在调用结束后返回给调用者，这通常需要通过<code>abi.decode</code>等方法进行解码。</li><li>在外部调用中，如果调用的合约抛出异常或耗尽Gas，调用者合约将会得到失败的结果，并且可以选择回滚操作。</li></ul><h3 id="调用成本">3. <strong>调用成本</strong></h3><ul><li><strong>内部调用</strong>：由于没有新的消息传递和上下文切换，内部调用的成本（Gas消耗）非常低。它是通过简单的跳转和共享上下文来实现的，因此更加高效。</li><li><strong>外部调用</strong>：外部调用由于需要创建新的上下文、消息传递、处理潜在的返回数据等，成本较高。此外，外部调用可能带来安全风险，如重入攻击，这需要额外的防护措施。</li></ul><h3 id="安全性考虑">4. <strong>安全性考虑</strong></h3><ul><li><strong>内部调用</strong>：通常被认为是安全的，因为它们在相同的合约上下文中运行，没有额外的消息传递和上下文切换。</li><li><strong>外部调用</strong>：外部调用则需要更多的安全性考虑，尤其是在涉及到第三方合约时。常见的攻击手段如重入攻击就是通过外部调用进行的。因此，开发者通常会使用<code>checks-effects-interactions</code>模式来防范这种风险。</li></ul><h3 id="总结">总结</h3><ul><li><strong>内部调用</strong>：是一次简单的代码跳转，没有消息传递和上下文切换，效率高且Gas成本低。</li><li><strong>外部调用</strong>：涉及到新的消息传递和上下文切换，消耗更多Gas，并且需要特别注意安全性，尤其是在跨合约调用时。</li></ul><p>理解这些差异对编写高效和安全的Solidity合约非常重要。开发者应根据实际需求选择合适的调用方式，以优化合约的性能和安全性。</p><hr><p>一个合约最终会编译成一段字节码，函数是字节码中的一个部分。内部调用就是直接把执行的代码跳转到另一个函数；外部调用是发起了一个新的消息，创建了新的上下文。</p><h1 id="evm">2 EVM</h1><p>看了这三篇文章：https://learnblockchain.cn/article/3779</p><p>总而言之，了解了EVM中内存存储方式，以及栈式指令的执行过程。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文属于学习笔记，内容可能有误、可能不全面，仅代表个人在学习这一特性时的理解和总结&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;老师安排的任务是EVM智能合约的加速计算，给我的论文提出了一个新的架构……&lt;/p&gt;
&lt;p&gt;但是我还不知道原始的EVM是怎么实现的，所以先学习一下&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://cishoon.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="区块链" scheme="http://cishoon.top/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="以太坊" scheme="http://cishoon.top/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
  </entry>
  
</feed>
