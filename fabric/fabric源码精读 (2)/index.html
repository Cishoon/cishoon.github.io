<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="5AUIVYTbHIAuz-eQtxSfZbWW5eg9_EVZMSQycIuXrG0">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"cishoon.top","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":true,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.20.0/config.min.js"></script>

    <meta name="description" content="开坑，学习 Fabric 的源码。 思路是根据 fabric-sample 的 test-network 中的脚本，一行行分析。遇到里面使用的指令，看源码如何实现。 下面内容非常混乱，写的毫无逻辑，之后有空重新整理一遍。 一口气写完太长了，typora里会卡，分章节发。 学习笔记，不保证内容正确性。">
<meta property="og:type" content="article">
<meta property="og:title" content="Hyperledger Fabric 源码精读（2）">
<meta property="og:url" content="http://cishoon.top/fabric/fabric%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AF%BB%20(2)/index.html">
<meta property="og:site_name" content="Cishoon&#39;s Blog">
<meta property="og:description" content="开坑，学习 Fabric 的源码。 思路是根据 fabric-sample 的 test-network 中的脚本，一行行分析。遇到里面使用的指令，看源码如何实现。 下面内容非常混乱，写的毫无逻辑，之后有空重新整理一遍。 一口气写完太长了，typora里会卡，分章节发。 学习笔记，不保证内容正确性。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-09-13T16:00:00.000Z">
<meta property="article:modified_time" content="2024-09-15T09:04:06.516Z">
<meta property="article:author" content="Cishoon">
<meta property="article:tag" content="区块链">
<meta property="article:tag" content="go">
<meta property="article:tag" content="fabric">
<meta property="article:tag" content="超级账本">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://cishoon.top/fabric/fabric%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AF%BB%20(2)/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://cishoon.top/fabric/fabric%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AF%BB%20(2)/","path":"fabric/fabric源码精读 (2)/","title":"Hyperledger Fabric 源码精读（2）"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hyperledger Fabric 源码精读（2） | Cishoon's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-43861RVV8R"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-43861RVV8R","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.20.0/third-party/analytics/google-analytics.min.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="Cishoon's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Cishoon's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">83</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">54</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          目 录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#createchannel"><span class="nav-text">2 createChannel</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%88%9B%E4%B8%96%E5%8C%BA%E5%9D%97"><span class="nav-text">2.1 创建创世区块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#configtxgen"><span class="nav-text">2.1.1 configtxgen</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#protoutil"><span class="nav-text">2.1.2 protoutil</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E9%80%9A%E9%81%93"><span class="nav-text">2.2 创建通道</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#osnadmin-channel"><span class="nav-text">2.2.1 osnadmin channel</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E7%AD%89%E8%8A%82%E7%82%B9%E5%8A%A0%E5%85%A5%E9%80%9A%E9%81%93"><span class="nav-text">2.3 对等节点加入通道</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#peer-channel-join"><span class="nav-text">2.3.1 peer channel join</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#viper"><span class="nav-text">2.3.2 viper</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E5%A4%8D%E7%9B%98"><span class="nav-text">2.3.3 总结复盘</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E9%94%9A%E5%AE%9A%E8%8A%82%E7%82%B9"><span class="nav-text">2.4 设置锚定节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E9%80%9A%E9%81%93%E9%85%8D%E7%BD%AE"><span class="nav-text">2.4.1 获取通道配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#peer-channel-fetch-config"><span class="nav-text">2.4.1.1 peer channel fetch
config</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#configtxlator"><span class="nav-text">2.4.1.2 configtxlator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jq"><span class="nav-text">2.4.1.3 jq</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E9%80%9A%E9%81%93%E9%85%8D%E7%BD%AE"><span class="nav-text">2.4.2 修改通道配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E9%85%8D%E7%BD%AE%E6%9B%B4%E6%96%B0"><span class="nav-text">2.4.3 创建配置更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#peer-channel-update"><span class="nav-text">2.4.4 peer channel update</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-text">问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%9A%E8%8A%82%E7%82%B9%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">锚节点的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%84%E4%B8%AAclient%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">各个Client的作用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#endorserclient-pb.endorserclient"><span class="nav-text">1. EndorserClient
(pb.EndorserClient)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#broadcastclient-common.broadcastclient"><span class="nav-text">2. BroadcastClient
(common.BroadcastClient)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#deliverclient-deliverclientintf"><span class="nav-text">3. DeliverClient
(deliverClientIntf)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%99%84%E5%BD%95"><span class="nav-text">附录</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#grpc-%E4%B8%8E%E4%BC%A0%E7%BB%9F-http-%E8%B0%83%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">gRPC 与传统 HTTP 调用的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="nav-text">1. 通信协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="nav-text">2. 数据格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%A7%E8%83%BD"><span class="nav-text">3. 性能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E5%90%91%E6%B5%81%E5%BC%8F%E9%80%9A%E4%BF%A1"><span class="nav-text">4. 双向流式通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%AE%9A%E4%B9%89"><span class="nav-text">5. 服务定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">6. 适用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%83%BD%E5%90%A6%E4%BD%BF%E7%94%A8%E4%BC%A0%E7%BB%9F-http-%E8%BF%9B%E8%A1%8C%E7%9B%B8%E5%90%8C%E7%9A%84%E8%B0%83%E7%94%A8"><span class="nav-text">7. 能否使用传统 HTTP
进行相同的调用？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#go-%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84-context-%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3"><span class="nav-text">Go 标准库中的
context 详细讲解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">1. 基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-text">2. 常用的函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8-context"><span class="nav-text">3. 如何在代码中使用
context</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#context-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE"><span class="nav-text">4. context
的使用建议</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-text">总结</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Cishoon"
      src="/images/cishoon.jpg">
  <p class="site-author-name" itemprop="name">Cishoon</p>
  <div class="site-description" itemprop="description">一条数学公式 + 一个简单的故事</div>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Npc2hvb24=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cishoon"><i class="fab fa-github fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMTA2Njk1NDg4" title="哔哩哔哩 → https:&#x2F;&#x2F;space.bilibili.com&#x2F;106695488"><i class="fa-brands fa-bilibili fa-fw"></i></span>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cishoon.top/fabric/fabric%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AF%BB%20(2)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cishoon.jpg">
      <meta itemprop="name" content="Cishoon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cishoon's Blog">
      <meta itemprop="description" content="一条数学公式 + 一个简单的故事">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Hyperledger Fabric 源码精读（2） | Cishoon's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Hyperledger Fabric 源码精读（2）<span class="exturl post-edit-link" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Npc2hvb24vYmxvZy90cmVlL21haW4vc291cmNlL19wb3N0cy9mYWJyaWMvZmFicmlj5rqQ56CB57K+6K+7ICgyKS5tZA==" title="编辑"><i class="fa fa-pen-nib"></i></span>
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-14 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-14T00:00:00+08:00">2024-09-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>21k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>19 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><ul>
<li><p>开坑，学习 Fabric 的源码。</p></li>
<li><p>思路是根据 <code>fabric-sample</code> 的
<code>test-network</code>
中的脚本，一行行分析。遇到里面使用的指令，看源码如何实现。</p></li>
<li><p>下面内容非常混乱，写的毫无逻辑，之后有空重新整理一遍。</p></li>
<li><p>一口气写完太长了，typora里会卡，分章节发。</p></li>
<li><p>学习笔记，不保证内容正确性。</p></li>
</ul>
<span id="more"></span>
<h1 id="createchannel">2 createChannel</h1>
<p><code>network.sh</code> 的注释里明确说明，这个函数干了两件事：</p>
<ol type="1">
<li>join the peers of org1 and org2：加入两个组织的对等节点</li>
<li>update the <strong>anchor peers</strong> for each
organization：更新每个组织的锚定节点</li>
</ol>
<p>我完善一下：</p>
<ol type="1">
<li>创建创世区块</li>
<li>利用创世区块创建通道</li>
<li>加入对等节点</li>
<li>更新锚定节点</li>
</ol>
<h2 id="创建创世区块">2.1 创建创世区块</h2>
<p>test-network 的脚本固定由第一个组织进行创世区块的创建。</p>
<p>创建创世区块的核心语句是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">configtxgen -profile ChannelUsingRaft -outputBlock ./channel-artifacts/${CHANNEL_NAME}.block -channelID $CHANNEL_NAME</span><br></pre></td></tr></table></figure>
<p>接下来看看configtxgen</p>
<h3 id="configtxgen">2.1.1 configtxgen</h3>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-channelID string</code></td>
<td>指定在配置交易中使用的通道ID。</td>
</tr>
<tr>
<td><code>-configPath string</code></td>
<td>指定包含要使用配置的路径。</td>
</tr>
<tr>
<td><code>-inspectBlock string</code></td>
<td>打印指定路径区块中包含的配置。</td>
</tr>
<tr>
<td><code>-outputBlock string</code></td>
<td>指定写入创世区块的路径。</td>
</tr>
<tr>
<td><code>-profile string</code></td>
<td>指定 <code>configtx.yaml</code> 中用于生成的配置文件。</td>
</tr>
</tbody>
</table>
<p>这个工具的输出主要受 <code>configtx.yaml</code> 文件内容的控制。</p>
<p>默认情况下，<code>configtxgen</code> 工具会依次尝试从
<code>$FABRIC_CFG_PATH</code> 环境变量指定的路径，当前路径和
<code>/etc/hyperledger/fabric</code> 路径下查找
<code>configtx.yam</code> 配置文件并读入，作为默认的配置。或者使用参数的
<code>-configPath</code> 定义。环境变量中以<code>CONFIGTX_</code>
前缀开头的变量也会被作为配置项。</p>
<p>很多功能都被启用了，好像唯一的功能就是创建创世区块？</p>
<p>在源码中，创建创世区块的核心代码都是由 <code>protoutil</code>
这个包实现的。</p>
<h3 id="protoutil">2.1.2 protoutil</h3>
<p><code>protoutil</code> 是 Hyperledger Fabric
中的一个实用工具，用于处理和操作协议缓冲区（protobuf）格式的数据。Hyperledger
Fabric 使用协议缓冲区（Protobuf）作为其内部数据结构的主要序列化格式，而
<code>protoutil</code>
提供了一组工具和函数来简化这些数据的创建、解析、和转换过程。</p>
<p>具体来说，<code>protoutil</code> 可能包括以下功能：</p>
<ul>
<li>序列化和反序列化 Protobuf 消息。</li>
<li>生成交易提案和区块。</li>
<li>解析和检验区块数据结构。</li>
<li>操作链码提案、响应和其他相关的 Protobuf 消息。</li>
</ul>
<p>这些功能对于开发和维护 Fabric 网络至关重要，因为它们简化了与 Fabric
内部数据结构的交互。</p>
<p>什么是协作缓冲区 Protobuf ？https://protobuf.com.cn/overview/</p>
<p>简言之就是类似 Json 但比 Json
更紧凑轻量的数据格式。一个区块，无非就是一个键值对，里面存的数据不同而已。</p>
<table>
<colgroup>
<col style="width: 25%">
<col style="width: 23%">
<col style="width: 50%">
</colgroup>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Header</code></td>
<td><code>*cb.BlockHeader</code></td>
<td>Contains metadata about the block itself.</td>
</tr>
<tr>
<td><code>Header.Number</code></td>
<td><code>uint64</code></td>
<td>The sequence number of the block.</td>
</tr>
<tr>
<td><code>Header.PreviousHash</code></td>
<td><code>[]byte</code></td>
<td>The hash of the previous block.</td>
</tr>
<tr>
<td><code>Header.DataHash</code></td>
<td><code>[]byte</code></td>
<td>The hash of the block's data.</td>
</tr>
<tr>
<td><code>Data</code></td>
<td><code>*cb.BlockData</code></td>
<td>Contains the actual data of the block.</td>
</tr>
<tr>
<td><code>Metadata</code></td>
<td><code>*cb.BlockMetadata</code></td>
<td>Contains metadata for the block.</td>
</tr>
<tr>
<td><code>Metadata.Metadata</code></td>
<td><code>[][]byte</code></td>
<td>Array of metadata entries.</td>
</tr>
</tbody>
</table>
<p>创世区块具体的值如下：</p>
<ul>
<li><code>Header.Number</code>：<code>0</code>，因为这是创世区块。</li>
<li><code>Header.PreviousHash</code>：<code>nil</code>，因为这是创世区块，没有前一个区块。</li>
<li><code>Header.DataHash</code>：由<code>protoutil.ComputeBlockDataHash(block.Data)</code>计算得出。</li>
<li><code>Data</code>：包含一个<code>cb.Envelope</code>，其<code>Payload</code>为<code>cb.Payload</code>，<code>Data</code>为<code>cb.ConfigEnvelope</code>。</li>
<li><code>Metadata.Metadata</code>：包含两个条目：
<ul>
<li><code>cb.BlockMetadataIndex_LAST_CONFIG</code>：包含<code>cb.LastConfig{Index: 0}</code>。</li>
<li><code>cb.BlockMetadataIndex_SIGNATURES</code>：包含<code>cb.OrdererBlockMetadata{LastConfig: &amp;cb.LastConfig{Index: 0}}</code>。</li>
</ul></li>
</ul>
<p>然后把这个东西写入一个文件中
<code>./channel-artifacts/${CHANNEL_NAME}.block</code>
就完成了创世区块的创建。</p>
<h2 id="创建通道">2.2 创建通道</h2>
<p>循环执行以下脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">. scripts/orderer.sh <span class="variable">${CHANNEL_NAME}</span>&gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>.</code> 命令是 <code>source</code> 命令的简写形式，用于在当前
shell 环境中执行一个脚本文件。这意味着文件中的所有命令都会在当前 shell
中运行，而不会创建新的子 shell。这与直接执行脚本文件（如
<code>./script.sh</code>）不同，后者会创建一个新的子 shell
来运行脚本中的命令。</p>
</blockquote>
<p>orderer.sh:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">osnadmin channel <span class="built_in">join</span> </span><br><span class="line">	--channelID <span class="variable">${channel_name}</span> </span><br><span class="line">	--config-block ./channel-artifacts/<span class="variable">${channel_name}</span>.block </span><br><span class="line">	-o localhost:7053 </span><br><span class="line">	--ca-file <span class="string">"<span class="variable">$ORDERER_CA</span>"</span> </span><br><span class="line">	--client-cert <span class="string">"<span class="variable">$ORDERER_ADMIN_TLS_SIGN_CERT</span>"</span> </span><br><span class="line">	--client-key <span class="string">"<span class="variable">$ORDERER_ADMIN_TLS_PRIVATE_KEY</span>"</span> </span><br><span class="line">&gt;&gt; log.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure>
<p>突然出现了一个新工具：<code>osnadmin</code></p>
<h3 id="osnadmin-channel">2.2.1 osnadmin channel</h3>
<p>OSN 是 Ordering Service Node 的缩写。osnadmin channel
命令允许管理员在排序节点上执行与通道相关的操作，例如<strong>加入通道</strong>、<strong>列出排序节点已加入的通道</strong>以及<strong>移除通道</strong>。必须启用通道参与API，并且在每个排序节点的
orderer.yaml 中配置Admin端点。</p>
<p><code>osnadmin channel join</code> 干的事，就是向
<code>https://localhost:7053/participation/v1/channels</code>
发送了一个HTTP POST请求，请求体是上一步生成的创世区块。</p>
<p>顺便的，<code>osnadmin channel list</code> 就是向
<code>https://localhost:7053/participation/v1/channels/${channel-id}</code>
发送 HTTP GET 请求，如果不携带特定的 <code>channel-id</code>
就是返回所有通道。</p>
<p><code>osnadmin channel remove</code> 干的事，就是向
<code>https://localhost:7053/participation/v1/channels</code>
发送了一个HTTP DELETE请求。</p>
<p>这里也表明了，<code>orderer</code>
启动的服务里应该有很多接口可调用。</p>
<h2 id="对等节点加入通道">2.3 对等节点加入通道</h2>
<p>在排序节点上创建好了通道，接下来就是让对等节点加入通道。</p>
<p>同样是循环执行脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">peer channel <span class="built_in">join</span> -b <span class="variable">$BLOCKFILE</span> &gt;&amp;log.txt</span><br></pre></td></tr></table></figure>
<p>其中
<code>BLOCKFILE="./channel-artifacts/${CHANNEL_NAME}.block"</code>
，就是刚刚产生的创世区块。</p>
<p>这里的 <code>peer channel</code> 好像就是
<code>osnadmin channel</code> 的 <code>peer</code> 版。</p>
<h3 id="peer-channel-join">2.3.1 peer channel join</h3>
<ul>
<li><p><strong>ChannelCmdFactory</strong></p>
<p>其中用到了一个工厂模式，<code>InitCmdFactory</code>
，<code>peer channel</code>
会根据不同的指令需求（是否需要背书、是否需要广播给对等节点、是否需要广播给排序节点）打包客户端。</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ChannelCmdFactory holds the clients used by ChannelCmdFactory</span></span><br><span class="line"><span class="keyword">type</span> ChannelCmdFactory <span class="keyword">struct</span> {</span><br><span class="line">	EndorserClient   pb.EndorserClient</span><br><span class="line">	Signer           msp.SigningIdentity</span><br><span class="line">	BroadcastClient  common.BroadcastClient</span><br><span class="line">	DeliverClient    deliverClientIntf</span><br><span class="line">	BroadcastFactory BroadcastClientFactory</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p>执行 join 只需要背书，不需要广播给对等节点和排序节点。</p></li>
<li><p><strong>getJoinCCSpec</strong></p>
<p>听函数名字和链码有关，获取了一个链码的Spec，但是到目前为止我还没有创建过链码？先来看看源码：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getJoinCCSpec</span><span class="params">()</span></span> (*pb.ChaincodeSpec, <span class="type">error</span>) {</span><br><span class="line">	<span class="keyword">if</span> genesisBlockPath == common.UndefinedParamValue {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"Must supply genesis block file"</span>)</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	gb, err := os.ReadFile(genesisBlockPath)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, GBFileNotFoundErr(err.Error())</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// Build the spec</span></span><br><span class="line">	input := &amp;pb.ChaincodeInput{Args: [][]<span class="type">byte</span>{[]<span class="type">byte</span>(cscc.JoinChain), gb}}</span><br><span class="line"></span><br><span class="line">	spec := &amp;pb.ChaincodeSpec{</span><br><span class="line">		Type:        pb.ChaincodeSpec_Type(pb.ChaincodeSpec_Type_value[<span class="string">"GOLANG"</span>]),</span><br><span class="line">		ChaincodeId: &amp;pb.ChaincodeID{Name: <span class="string">"cscc"</span>},</span><br><span class="line">		Input:       input,</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> spec, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p>返回一个 ChaincodeSpec 结构体指针，类型指定为 GOLAN 语言，链码ID为
<strong>cscc</strong>
，并且还设置了这个链码的输入参数：<code>JoinChain: 创世区块字节码</code></p>
<p><strong>cscc</strong>，其实是一个内置的系统链码 (System
Chaincode)，全称为 <strong>Configuration System Chaincode</strong>。</p>
<p>系统链码是由 Hyperledger Fabric
平台内置的特殊链码，负责处理一些核心功能。开发者不需要自己编写或部署这些系统链码，它们在
Fabric 网络启动时自动部署，并在整个网络中使用。</p>
<p>JoinChain 这个函数用于将一个新的节点加入到现有的通道中。当调用
<code>cscc.JoinChain</code>
时，节点会使用给定的创世区块来加入指定的通道。</p></li>
<li><p><strong>executeJoin(cf <em>ChannelCmdFactory, spec
</em>pb.ChaincodeSpec)</strong></p>
<p>最后，将上面两个函数得到的结果（工厂和spec），放到一起执行。</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">executeJoin</span><span class="params">(cf *ChannelCmdFactory, spec *pb.ChaincodeSpec)</span></span> (err <span class="type">error</span>) {</span><br><span class="line">	<span class="comment">// Build the ChaincodeInvocationSpec message</span></span><br><span class="line">	invocation := &amp;pb.ChaincodeInvocationSpec{ChaincodeSpec: spec}</span><br><span class="line">	creator, err := cf.Signer.Serialize()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据序列化的身份（signer）和链码调用规范（invocation）创建提案</span></span><br><span class="line">	<span class="keyword">var</span> prop *pb.Proposal</span><br><span class="line">	prop, _, err = protoutil.CreateProposalFromCIS(pcommon.HeaderType_CONFIG, <span class="string">""</span>, invocation, creator)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据提案和签名者创建签名的提案</span></span><br><span class="line">	<span class="keyword">var</span> signedProp *pb.SignedProposal</span><br><span class="line">	signedProp, err = protoutil.GetSignedProposal(prop, cf.Signer)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// EndorserClient 是背书服务的客户端 API。</span></span><br><span class="line">	<span class="comment">// ProcessProposal 用于处理提案。</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">var</span> proposalResp *pb.ProposalResponse</span><br><span class="line">	proposalResp, err = cf.EndorserClient.ProcessProposal(context.Background(), signedProp)</span><br><span class="line"></span><br><span class="line">	logger.Info(<span class="string">"Successfully submitted proposal to join channel"</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p>还是很清晰的，前两步准备好了请求客户端和要发送的数据，这一步签了名之后，直接调用<code>EndorserClient.ProcessProposal(context.Background(), signedProp)</code>
来执行提议。</p>
<p>封装的很深，执行的逻辑还藏在这个函数里。这个函数奇妙，有一个
<code>context</code> 参数，上下文在这里是怎么用的？</p></li>
<li><p><code>EndorserClient.ProcessProposal</code></p>
<blockquote>
<p>// For semantics around ctx use and closing/ending streaming RPCs,
please refer to
https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.</p>
</blockquote>
<p>这个是一个接口，这里使用的实现是 <code>perr.pb.go</code>
中的实现，具体代码如下：</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> endorserClient <span class="keyword">struct</span> {</span><br><span class="line">	cc *grpc.ClientConn</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *endorserClient)</span></span> ProcessProposal(</span><br><span class="line">        ctx context.Context, in *SignedProposal, </span><br><span class="line">        opts ...grpc.CallOption</span><br><span class="line">    ) (*ProposalResponse, <span class="type">error</span>) </span><br><span class="line">{</span><br><span class="line">	out := <span class="built_in">new</span>(ProposalResponse)</span><br><span class="line">	err := c.cc.Invoke(ctx, <span class="string">"/protos.Endorser/ProcessProposal"</span>, in, out, opts...)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> out, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p><code>c.cc</code> 就是结构体中定义的 <code>cc *grpc.ClientConn</code>
一个普通的客户端连接。</p>
<p>主要方法和属性</p>
<ul>
<li><code>Invoke</code>：用于调用 RPC 方法。</li>
<li><code>NewStream</code>：用于创建流式 RPC 调用。</li>
<li><code>Target</code>：返回连接的目标地址。</li>
<li><code>Close</code>：关闭连接并清理相关资源。</li>
<li><code>State</code>：返回连接的当前状态（例如，<code>Ready</code>、<code>Connecting</code>、<code>Idle</code>
等）。</li>
<li><code>WaitForStateChange</code>：等待连接状态发生变化。</li>
</ul>
<p>这里传了一个 <code>context.Context</code>
参数，目的是允许给用户提供控制权，用户可以通过 ctx 对这个grpc goroutine
进行取消、超时等操作。但是这段代码里没有在上层进行其他控制，所以直接传了一个
<code>context.Background()</code> 进去。</p>
<p>关于 gRPC 和 context 的详细内容见文末的附录。</p></li>
</ul>
<h3 id="viper">2.3.2 viper</h3>
<p>但是我还有个疑问，<code>peer channel join</code>
的参数或者环境变量是在哪里设置的？之前的 <code>osnadmin</code>
直接在参数里设置全了，而 <code>peer</code> 却没有任何参数设置。</p>
<p>其实是 <code>network.sh</code> 设置了这个参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FABRIC_CFG_PATH=$PWD/../config/</span><br></pre></td></tr></table></figure>
<p>在该文件夹里有一个 <code>core.yaml</code>
里面定义了所有配置，里面写死了：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">peer:</span></span><br><span class="line">	<span class="attr">address:</span></span><br><span class="line">		<span class="string">localhost:7051</span></span><br></pre></td></tr></table></figure>
<p>另外，<code>setGlobals</code>
函数设置了全局变量，用于切换两个组织的配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$USING_ORG</span> -eq 1 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">export</span> CORE_PEER_LOCALMSPID=Org1MSP</span><br><span class="line">  <span class="built_in">export</span> CORE_PEER_TLS_ROOTCERT_FILE=<span class="variable">$PEER0_ORG1_CA</span></span><br><span class="line">  <span class="built_in">export</span> CORE_PEER_MSPCONFIGPATH=...org1...</span><br><span class="line">  <span class="built_in">export</span> CORE_PEER_ADDRESS=localhost:7051</span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$USING_ORG</span> -eq 2 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">export</span> CORE_PEER_LOCALMSPID=Org2MSP</span><br><span class="line">  <span class="built_in">export</span> CORE_PEER_TLS_ROOTCERT_FILE=<span class="variable">$PEER0_ORG2_CA</span></span><br><span class="line">  <span class="built_in">export</span> =...org2...</span><br><span class="line">  <span class="built_in">export</span> CORE_PEER_ADDRESS=localhost:9051</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>前三个变量来区别组织1和组织2的证书、MSP，最后一个变量区分节点的监听地址。</p>
<p>（test-network
中一个组织只有一个节点。实际上，同一个组织下会有多个节点，他们的前三个变量相同，最后一个参数不同）</p>
<p>这里我很奇怪，怎么又是环境变量，又是配置文件，他们的命名方式都不一样，甚至环境变量还多了一个前缀
<code>CORE</code> 这怎么关联上的？</p>
<p>fabric 用了一个 go 的开源库 <code>viper</code>
，其功能就是很方便的从配置文件中读取值，也能使用环境变量去覆盖配置文件里的值。他会自动解析环境变量，并把变量名小写、将下划线替换。并且源码中还有：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">viper.SetEnvPrefix(<span class="string">"CORE"</span>)</span><br></pre></td></tr></table></figure>
<p>显而易见，是设置了环境变量的前缀为 CORE 。这就是 fabric
进行配置读取的方式。</p>
<h3 id="总结复盘">2.3.3 总结复盘</h3>
<p>至此，<code>peer channel join -b 创世区块.block</code>
执行完毕。再次复盘提出问题：</p>
<p>具体来说，这个过程调用了一个系统内置的链码函数
<code>cscc.JoinChain</code>
，节点会使用给定的创世区块来加入指定的通道。</p>
<blockquote>
<p><strong>问题1：</strong>新的通道是通过创世区块来标识的吗？如果这个通道已经有好多个区块了，新的节点想加入进来，也是通过创世区块来加入吗？如果是，我这个例子都在本地，创世区块就存在本地，其他新节点想加入的时候，怎么获得创世区块？</p>
<p><strong>通道与创世区块的关系</strong>：</p>
<ul>
<li><strong>创世区块</strong>
是通道的第一个区块，它包含了通道的初始配置和一些重要的元数据。每个通道都有一个唯一的创世区块，通道的标识在区块链中是通过区块链上的区块来维护的，其中创世区块是至关重要的第一块。</li>
<li>当一个新节点要加入到一个已有的通道时，即使这个通道已经包含了很多区块，新节点仍然是通过创世区块来加入的。这是因为创世区块包含了通道的初始配置和结构信息，节点需要这些信息来了解通道的基本设置。</li>
</ul>
<p><strong>获取创世区块</strong>：</p>
<ul>
<li>在生产环境中，新节点通常无法直接从本地获得创世区块，而是通过其他方式获取：
<ol type="1">
<li><strong>通过已经加入通道的节点</strong>：新节点可以从已经是通道成员的节点那里请求创世区块。这通常通过
<code>peer channel fetch</code>
命令来实现，该命令可以从通道的区块链上获取创世区块或其他指定的区块。</li>
<li><strong>从区块存储库中提取</strong>：在某些情况下，创世区块可能会被存储在一个共享的存储库或文件系统中，节点可以从中获取。</li>
<li><strong>通过网络传输</strong>：创世区块也可以通过安全的网络传输从其他节点或管理系统中获取。</li>
</ol></li>
</ul>
<p><strong>加入现有通道</strong>：</p>
<ul>
<li><p>当新节点使用创世区块加入现有的通道时，它首先会同步到当前通道的最新状态（即下载并验证通道中的所有区块，直到最新的区块）。这样，新节点便可以与通道中的其他节点保持一致。</p>
<p>这里提到新节点会同步通道的最新状态，这部分代码在 peer
内部执行。也就是 gRPC 发送请求后，docker 容器里的 peer 执行。</p></li>
</ul>
</blockquote>
<p>调用链码的方式是给背书节点发送 gRPC 请求。</p>
<p><strong>问题2：</strong>通过阅读源码，我发现这里的背书节点，就是要加入的节点。这是为什么？背书节点的作用是什么？有没有其他使用背书节点的例子？</p>
<blockquote>
<p><strong>背书节点的角色</strong>：</p>
<ul>
<li>在 Hyperledger Fabric 中，<strong>背书节点（Endorser Peer）</strong>
是负责模拟和验证交易的节点。每个参与者节点都可以配置为背书节点，背书节点根据链码的逻辑模拟交易，并生成背书（endorsement），背书包含节点对交易的认可。</li>
<li><strong>为什么背书节点就是要加入的节点</strong>：
<ul>
<li>当一个节点想要加入一个通道时，它需要运行一个系统链码（如
<code>cscc</code>）来执行这个操作。在这种情况下，节点实际上是在请求自己作为背书节点来执行这个操作。这是因为加入通道的过程需要在本节点上进行一些检查和操作（例如验证创世区块、更新节点的通道状态等），这些操作都需要由本节点背书和认可。</li>
</ul></li>
<li><strong>背书节点的其他使用例子</strong>：
<ul>
<li><strong>交易提案的背书</strong>：在通常的交易流程中，客户端将交易提案发送给多个背书节点。这些节点分别模拟交易并生成背书响应。客户端收集足够的背书后，将交易提交给排序服务（Orderer）。</li>
<li><strong>链码的安装与实例化</strong>：当一个链码被安装或实例化时，背书节点也会参与其中，模拟链码的执行并生成相应的状态更新或响应。</li>
</ul></li>
</ul>
<p><strong>总结</strong>：</p>
<ul>
<li>背书节点在 Fabric
中不仅用于加入通道的操作，还用于各种交易和链码操作中，是确保区块链数据一致性和安全性的关键组件。</li>
<li>在你提到的场景中，背书节点执行的 <code>cscc.JoinChain</code>
操作是为了确保节点正确加入通道，确保它能够获取到通道的配置并同步到最新状态。</li>
</ul>
</blockquote>
<p>同时 <code>peer</code>
会自动获取配置文件和环境变量。具体让哪个组织、哪个节点加入通道，都是在配置文件和环境变量中设置的。</p>
<h2 id="设置锚定节点">2.4 设置锚定节点</h2>
<p>什么是锚定节点？锚定节点的作用是什么？</p>
<h3 id="获取通道配置">2.4.1 获取通道配置</h3>
<h4 id="peer-channel-fetch-config">2.4.1.1 peer channel fetch
config</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">peer channel fetch config </span><br><span class="line">	<span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/config_block.pb </span><br><span class="line">	-o localhost:7050 </span><br><span class="line">	--ordererTLSHostnameOverride orderer.example.com </span><br><span class="line">	-c <span class="variable">$CHANNEL</span> --tls --cafile <span class="string">"<span class="variable">$ORDERER_CA</span>"</span></span><br></pre></td></tr></table></figure>
<p><code>peer channel fetch</code>
用于获取一个特定的区块，并把它写入文件。后面可跟参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;newest|oldest|config|(number)</span><br></pre></td></tr></table></figure>
<p>除了 <code>config</code> 都好理解。看看源码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> args[<span class="number">0</span>] {</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"oldest"</span>:</span><br><span class="line">		block, err = cf.DeliverClient.GetOldestBlock()</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"newest"</span>:</span><br><span class="line">		block, err = cf.DeliverClient.GetNewestBlock()</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"config"</span>:</span><br><span class="line">		iBlock, err2 := cf.DeliverClient.GetNewestBlock()</span><br><span class="line">		<span class="keyword">if</span> err2 != <span class="literal">nil</span> { <span class="keyword">return</span> err2 }</span><br><span class="line">    </span><br><span class="line">		lc, err2 := protoutil.GetLastConfigIndexFromBlock(iBlock)</span><br><span class="line">		<span class="keyword">if</span> err2 != <span class="literal">nil</span> { <span class="keyword">return</span> err2 }</span><br><span class="line">    </span><br><span class="line">		logger.Infof(<span class="string">"Retrieving last config block: %d"</span>, lc)</span><br><span class="line">		block, err = cf.DeliverClient.GetSpecifiedBlock(lc)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		num, err2 := strconv.Atoi(args[<span class="number">0</span>])</span><br><span class="line">		<span class="keyword">if</span> err2 != <span class="literal">nil</span> {</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">"fetch target illegal: %s"</span>, args[<span class="number">0</span>])</span><br><span class="line">		}</span><br><span class="line">		block, err = cf.DeliverClient.GetSpecifiedBlock(<span class="type">uint64</span>(num))</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>即最新的块里存放了一项数据，记录最近的 config
存放在第几个区块里。</p>
<p>再具体一点，<code>InitCmdFactory</code> 根据有没有设置
<code>-o</code> 决定需要 <code>peerDeliver</code> 还是
<code>ordererDeliver</code>。</p>
<p><code>peerDeliver</code> 还是 <code>ordererDeliver</code>
唯一的区别在于，<code>peer</code> 创建的 <code>CommonClient</code> 的
<code>keepalive</code> 选项为 <code>true</code>。</p>
<blockquote>
<p><code>keepalive</code>
是一种网络层的机制，用于在没有数据流动时通过发送定期的 "心跳"
消息来保持连接的活跃状态。</p>
<p><strong>Peer 节点和 Orderer 节点的通信差异</strong></p>
<ol type="1">
<li><strong>Peer 节点的通信需求</strong>：
<ul>
<li><strong>实时性和持久连接</strong>：Peer 节点之间或客户端与 Peer
节点之间的通信往往涉及长时间的实时交互，如链码执行、状态查询、区块广播等。这些操作可能需要持久的连接，尤其是在监听区块事件或等待交易结果时，连接可能会长时间处于空闲状态。</li>
<li><strong>保持连接稳定</strong>：为了避免在这些操作期间连接断开，<code>keepalive</code>
选项被启用，以确保连接的稳定性，即使在长时间的空闲期内也能保持连接活跃。</li>
</ul></li>
<li><strong>Orderer 节点的通信需求</strong>：
<ul>
<li><strong>批量性和间歇通信</strong>：Orderer
节点的主要职责是排序交易并将它们打包成区块。客户端与 Orderer
节点的通信通常是间歇性的，如提交交易或请求区块。由于这种通信通常不是长时间持续的，连接建立和断开的频率较高，因此不太需要持续的
<code>keepalive</code>。</li>
<li><strong>较短的通信生命周期</strong>：与 Peer
节点的长时间通信不同，Orderer
节点的通信一般是短暂且快速的，通常在完成一次性请求后即关闭连接，因此
<code>keepalive</code> 的需求不大。</li>
</ul></li>
</ol>
</blockquote>
<p>与 <code>EndorserClient</code> 不同的是，<code>peer</code> 和
<code>orderer</code> 使用的是 <code>AtomicBroadcast_DeliverClient</code>
原子的广播。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *atomicBroadcastBroadcastClient)</span></span> Send(m *common.Envelope) <span class="type">error</span> {</span><br><span class="line">	<span class="keyword">return</span> x.ClientStream.SendMsg(m)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *atomicBroadcastBroadcastClient)</span></span> Recv() (*BroadcastResponse, <span class="type">error</span>) {</span><br><span class="line">	m := <span class="built_in">new</span>(BroadcastResponse)</span><br><span class="line">	<span class="keyword">if</span> err := x.ClientStream.RecvMsg(m); err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> m, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>其中 <code>ClientStream</code> 是 <code>gRPC</code> 的内置对象。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DeliverClient)</span></span> GetOldestBlock() (*cb.Block, <span class="type">error</span>) {</span><br><span class="line">	err := d.seekOldest()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.WithMessage(err, <span class="string">"error getting oldest block"</span>)</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> d.readBlock()</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>先发送请求，再读取返回值。go 中使用 gRPC 的请求和返回不用像 Js
那样特意写异步函数。</p>
<p>至此，读取了该通道的配置区块并写入 <code>config_block.pb</code>
本地保存。</p>
<h4 id="configtxlator">2.4.1.2 configtxlator</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">configtxlator proto_decode </span><br><span class="line">	--input <span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/config_block.pb </span><br><span class="line">	--<span class="built_in">type</span> common.Block </span><br><span class="line">	--output <span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/config_block.json</span><br></pre></td></tr></table></figure>
<p>这个函数功能很明显，将区块中的数据转为 JSON
格式。不分析这个工具的源码了，大体上就是用 proto 读取，保存成 json。</p>
<h4 id="jq">2.4.1.3 jq</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jq .data.data[0].payload.data.config</span><br><span class="line">    <span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/config_block.json &gt;<span class="string">"<span class="variable">${OUTPUT}</span>"</span></span><br></pre></td></tr></table></figure>
<p><code>jq</code> 是一个用于处理 JSON 数据的命令行工具，它可以方便地从
JSON 文件中提取数据、进行过滤和格式化。</p>
<p>这段 Bash 代码执行了以下操作：</p>
<ol type="1">
<li>使用 <code>jq</code> 从 <code>config_block.json</code>
文件中提取通道配置块（<code>.data.data[0].payload.data.config</code>
字段）。</li>
<li>提取到的数据被写入到由环境变量 <code>OUTPUT</code>
指定的文件中。</li>
</ol>
<h3 id="修改通道配置">2.4.2 修改通道配置</h3>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">jq '.channel_group.groups.Application.groups.'$<span class="punctuation">{</span>CORE_PEER_LOCALMSPID<span class="punctuation">}</span>'.values += <span class="punctuation">{</span><span class="attr">"AnchorPeers"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"mod_policy"</span><span class="punctuation">:</span> <span class="string">"Admins"</span><span class="punctuation">,</span><span class="attr">"value"</span><span class="punctuation">:</span><span class="punctuation">{</span><span class="attr">"anchor_peers"</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">{</span><span class="attr">"host"</span><span class="punctuation">:</span> <span class="string">"'$HOST'"</span><span class="punctuation">,</span><span class="attr">"port"</span><span class="punctuation">:</span> '$PORT'<span class="punctuation">}</span><span class="punctuation">]</span><span class="punctuation">}</span><span class="punctuation">,</span><span class="attr">"version"</span><span class="punctuation">:</span> <span class="string">"0"</span><span class="punctuation">}</span><span class="punctuation">}</span>' $<span class="punctuation">{</span>TEST_NETWORK_HOME<span class="punctuation">}</span>/channel-artifacts/$<span class="punctuation">{</span>CORE_PEER_LOCALMSPID<span class="punctuation">}</span>config.json &gt; $<span class="punctuation">{</span>TEST_NETWORK_HOME<span class="punctuation">}</span>/channel-artifacts/$<span class="punctuation">{</span>CORE_PEER_LOCALMSPID<span class="punctuation">}</span>modified_config.json</span><br></pre></td></tr></table></figure>
<p>这段代码使用 <code>jq</code> 修改了 Hyperledger Fabric
网络中与某个组织（由 <code>CORE_PEER_LOCALMSPID</code>
环境变量指定）相关的通道配置。具体操作是：</p>
<ol type="1">
<li><strong>定位组织的配置部分</strong>：
<ul>
<li>通过 <code>jq</code> 表达式
<code>'.channel_group.groups.Application.groups.'${CORE_PEER_LOCALMSPID}'.values'</code>
定位到通道配置 JSON 文件中，特定组织的配置部分。</li>
</ul></li>
<li><strong>添加或更新锚节点配置</strong>：
<ul>
<li>在定位到的组织配置部分中，使用 <code>+=</code> 操作符向
<code>values</code> 字段中添加或更新一个名为 <code>AnchorPeers</code>
的配置项。这个配置项包含锚节点的信息，包括
<code>mod_policy</code>、<code>value</code> 和
<code>version</code>。</li>
<li><code>value</code> 字段中嵌套了 <code>anchor_peers</code> 信息，其中
<code>host</code> 和 <code>port</code> 的值分别从环境变量
<code>HOST</code> 和 <code>PORT</code>
中获取，代表了锚节点的主机和端口。</li>
</ul></li>
<li><strong>保存修改后的配置</strong>：
<ul>
<li>将修改后的 JSON 数据保存到一个新的文件中，该文件路径由
<code>TEST_NETWORK_HOME</code> 和 <code>CORE_PEER_LOCALMSPID</code>
环境变量指定，表示该组织的修改后的通道配置。</li>
</ul></li>
</ol>
<h3 id="创建配置更新">2.4.3 创建配置更新</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">createConfigUpdate <span class="variable">${CHANNEL_NAME}</span> <span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/<span class="variable">${CORE_PEER_LOCALMSPID}</span>config.json <span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/<span class="variable">${CORE_PEER_LOCALMSPID}</span>modified_config.json <span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/<span class="variable">${CORE_PEER_LOCALMSPID}</span>anchors.tx</span><br></pre></td></tr></table></figure>
<p><code>createConfigUpdate</code>
函数的总体作用是生成一个配置更新交易（configuration update
transaction）。这个过程涉及将原始和修改后的通道配置转换为二进制格式，计算出两者之间的差异，并将这个差异打包为一个可以提交的交易。</p>
<p>其具体实现如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">configtxlator proto_encode --input <span class="string">"<span class="variable">${ORIGINAL}</span>"</span> --<span class="built_in">type</span> common.Config --output <span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/original_config.pb</span><br><span class="line"></span><br><span class="line">configtxlator proto_encode --input <span class="string">"<span class="variable">${MODIFIED}</span>"</span> --<span class="built_in">type</span> common.Config --output <span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/modified_config.pb</span><br><span class="line"></span><br><span class="line">configtxlator compute_update --channel_id <span class="string">"<span class="variable">${CHANNEL}</span>"</span> --original <span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/original_config.pb --updated <span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/modified_config.pb --output <span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/config_update.pb</span><br><span class="line"></span><br><span class="line">configtxlator proto_decode --input <span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/config_update.pb --<span class="built_in">type</span> common.ConfigUpdate --output <span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/config_update.json</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'{"payload":{"header":{"channel_header":{"channel_id":"'</span><span class="variable">$CHANNEL</span><span class="string">'", "type":2}},"data":{"config_update":'</span>$(<span class="built_in">cat</span> <span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/config_update.json)<span class="string">'}}}'</span> | jq . &gt; <span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/config_update_in_envelope.json</span><br><span class="line"></span><br><span class="line">configtxlator proto_encode --input <span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/config_update_in_envelope.json --<span class="built_in">type</span> common.Envelope --output <span class="string">"<span class="variable">${OUTPUT}</span>"</span>  </span><br></pre></td></tr></table></figure>
<ol type="1">
<li><strong>编码原始配置文件为二进制格式</strong>：
<ul>
<li><strong>目的</strong>：将原始的 JSON 格式配置文件
(<code>${ORIGINAL}</code>) 编码为 <code>protobuf</code> 格式的二进制文件
<code>original_config.pb</code>。<code>protobuf</code> 是 Hyperledger
Fabric 用于内部数据表示的格式。</li>
</ul></li>
<li><strong>编码修改后的配置文件为二进制格式</strong>：
<ul>
<li><strong>目的</strong>：将修改后的 JSON 格式配置文件
(<code>${MODIFIED}</code>) 编码为 <code>protobuf</code> 格式的二进制文件
<code>modified_config.pb</code>。</li>
</ul></li>
<li><strong>计算配置更新的差异</strong>：
<ul>
<li><strong>目的</strong>：比较原始配置和修改后的配置，计算出两者之间的差异，并生成一个表示这些差异的配置更新文件
<code>config_update.pb</code>。这个文件以 <code>protobuf</code>
格式保存，包含了需要应用的配置更改。</li>
</ul></li>
<li><strong>解码配置更新为 JSON 格式</strong>：
<ul>
<li><strong>目的</strong>：将 <code>protobuf</code> 格式的配置更新文件
<code>config_update.pb</code> 解码回 JSON 格式的文件
<code>config_update.json</code>，方便后续处理或查看。</li>
</ul></li>
<li><strong>创建包含配置更新的信封（Envelope）</strong>：
<ul>
<li><strong>目的</strong>：将配置更新嵌入到一个 <code>Envelope</code>
中，添加必要的元数据（如 <code>channel_id</code>
和类型）。这是为了将配置更新打包成一个完整的交易，可以提交到区块链网络中。</li>
</ul></li>
<li><strong>编码带信封的配置更新为二进制格式</strong>：
<ul>
<li><strong>目的</strong>：将包含信封的配置更新（<code>config_update_in_envelope.json</code>）再次编码为
<code>protobuf</code> 格式的二进制文件，生成最终可以提交的配置更新交易
<code>anchors.tx</code>。</li>
</ul></li>
</ol>
<h3 id="peer-channel-update">2.4.4 peer channel update</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">peer channel update </span><br><span class="line">	-o localhost:7050 </span><br><span class="line">	--ordererTLSHostnameOverride orderer.example.com </span><br><span class="line">	-c <span class="variable">$CHANNEL_NAME</span> </span><br><span class="line">	-f <span class="variable">${TEST_NETWORK_HOME}</span>/channel-artifacts/<span class="variable">${CORE_PEER_LOCALMSPID}</span>anchors.tx </span><br><span class="line">	--tls --cafile <span class="string">"<span class="variable">$ORDERER_CA</span>"</span> &gt;&amp;log.txt</span><br></pre></td></tr></table></figure>
<p>已经很明白这段代码的目的了。看看具体实现有没有特别的地方。</p>
<p>工厂什么都不需要：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">InitCmdFactory(EndorserNotRequired, PeerDeliverNotRequired, OrdererNotRequired)</span><br></pre></td></tr></table></figure>
<p>官方文档说，Use the orderer at ip address
<code>orderer.example.com:7050</code> to send the configuration
transaction to all peers in the channel to update their copy of the
channel configuration.</p>
<p>即这段代码是指定一个排序节点向通道内的所有对等节点广播，修改他们的配置。</p>
<p>要记住什么操作室部署好的节点服务做的，什么是调用的指令做的。广播的操作是
orderer 服务内部做的，<code>peer channel update</code>
只负责向排序节点发送一个 gRPC。</p>
<h2 id="问题">问题</h2>
<h3 id="锚节点的作用">锚节点的作用</h3>
<ol type="1">
<li><strong>跨组织的区块传播</strong>：
<ul>
<li>锚节点是用于在不同组织之间进行区块传播的关键节点。当一个新的区块被
Orderer
节点生成并分发时，它首先会发送给每个组织的锚节点。然后，锚节点负责将这些区块传递给本组织内的其他
Peer 节点。</li>
<li>这种机制确保了区块能够在不同组织的节点之间有效传播，保持所有节点的数据同步。</li>
</ul></li>
<li><strong>跨组织的服务发现</strong>：
<ul>
<li>锚节点用于跨组织的服务发现。在 Hyperledger Fabric
中，当客户端（或其他 Peer
节点）需要与其他组织的节点通信时，它们可以通过查询锚节点来获取目标组织内的其他
Peer 节点的信息。</li>
<li>例如，在执行一个跨组织的链码调用时，客户端可能需要发送交易提案到多个组织的
Peer 节点。锚节点提供了一个入口，使得客户端能够发现并连接到这些 Peer
节点。</li>
</ul></li>
<li><strong>优化网络流量</strong>：
<ul>
<li>通过将区块传播的责任集中到少数锚节点，可以减少网络中全网广播带来的流量开销。这种集中化传播可以提高网络的效率和性能，避免不必要的数据冗余和延迟。</li>
</ul></li>
</ol>
<p>有点类似于网关。</p>
<h3 id="各个client的作用">各个Client的作用</h3>
<p>在 Hyperledger Fabric 的源码中，<code>ChannelCmdFactory</code>
结构体中的几个客户端（<code>EndorserClient</code>、<code>BroadcastClient</code>、<code>DeliverClient</code>）各自承担着不同的角色和职责，它们分别用于与不同类型的
Fabric 节点通信。以下是对这些客户端的具体实现及其用途的详细解释：</p>
<h4 id="endorserclient-pb.endorserclient">1. EndorserClient
(<code>pb.EndorserClient</code>)</h4>
<ul>
<li><strong>作用</strong>：<code>EndorserClient</code>
是用于与背书节点（Endorser
Peer）进行通信的客户端。它的主要职责是发送交易提案给背书节点，并接收背书节点返回的背书响应。</li>
<li><strong>具体实现</strong>：
<ul>
<li><code>EndorserClient</code> 通常实现了 gRPC 接口，负责与 Peer 节点的
<code>ProcessProposal</code>
方法交互。背书节点会对交易提案进行模拟执行，并返回模拟的结果（包括读取集和写入集），这个过程称为“背书”。</li>
<li><code>EndorserClient</code> 的具体实现类可能是通过 gRPC
框架生成的客户端代码，例如 <code>endorserClient</code>，它封装了与
<code>ProcessProposal</code> 的 gRPC 调用。</li>
</ul></li>
<li><strong>使用场景</strong>：
<ul>
<li>在客户端提交交易之前，会使用 <code>EndorserClient</code> 向多个 Peer
节点请求交易提案的背书。</li>
</ul></li>
</ul>
<h4 id="broadcastclient-common.broadcastclient">2. BroadcastClient
(<code>common.BroadcastClient</code>)</h4>
<ul>
<li><strong>作用</strong>：<code>BroadcastClient</code> 是用于与 Orderer
节点通信的客户端。它的主要职责是将经过背书的交易提交给 Orderer
节点，以便将交易排序后打包进区块。</li>
<li><strong>具体实现</strong>：
<ul>
<li><code>BroadcastClient</code> 也通常通过 gRPC 与 Orderer
节点通信。它实现了与 Orderer 节点的 <code>Broadcast</code>
方法的交互，负责将交易数据发送给 Orderer，Orderer
节点接收到交易后会对其进行排序，并打包到区块中。</li>
<li>一个常见的实现类可能是 <code>broadcastClientImpl</code>，它封装了与
<code>Broadcast</code> 方法的 gRPC 调用。</li>
</ul></li>
<li><strong>使用场景</strong>：
<ul>
<li>在交易得到足够的背书之后，客户端会使用 <code>BroadcastClient</code>
将交易提交给 Orderer 节点进行排序和区块打包。</li>
</ul></li>
</ul>
<h4 id="deliverclient-deliverclientintf">3. DeliverClient
(<code>deliverClientIntf</code>)</h4>
<ul>
<li><strong>作用</strong>：<code>DeliverClient</code> 是用于从 Orderer
或 Peer
节点接收区块和事件的客户端。它的主要职责是监听区块的传递或接收事件通知。</li>
<li><strong>具体实现</strong>：
<ul>
<li><code>DeliverClient</code> 通过 gRPC 接口与 Orderer 或 Peer
节点进行通信，通常会实现 <code>Deliver</code>
方法的调用。<code>Deliver</code> 方法允许客户端从 Peer 节点或 Orderer
节点获取区块的传递或接收区块的通知。</li>
<li>实现类可能是 <code>deliverClientImpl</code> 或者其他实现了
<code>deliverClientIntf</code> 接口的类，它封装了与 <code>Deliver</code>
方法的 gRPC 交互。</li>
</ul></li>
<li><strong>使用场景</strong>：
<ul>
<li>当客户端需要获取通道中的最新区块或监听特定事件（如区块提交事件）时，会使用
<code>DeliverClient</code> 来实现这一功能。</li>
</ul></li>
</ul>
<h3 id="总结">总结</h3>
<ul>
<li><code>EndorserClient</code>：用于与 Peer
节点通信，发送交易提案并接收背书响应。</li>
<li><code>BroadcastClient</code>：用于与 Orderer 节点通信，将交易提交给
Orderer 进行排序和区块打包。</li>
<li><code>DeliverClient</code>：用于接收区块或事件通知，可以从 Orderer
或 Peer 节点获取区块信息。</li>
</ul>
<h1 id="总结-1">总结</h1>
<p>至此，已经完成了 test-network 中网络的启动和通道的创建。</p>
<p>主要分析了如何使用 fabric 提供的工具（如 <code>peer</code>
<code>osnadmin</code> <code>cryptogen</code> 等）进行构建网络。</p>
<p>但是网络的启动中留了一个问题：<code>peer node start</code> 和
<code>orderer start</code>
干了什么。源码中哪里进行了端口的开放，这些节点收到 gRPC
请求之后，后续进行了什么操作。</p>
<p>下一节完成了这部分问题。</p>
<h1 id="附录">附录</h1>
<h2 id="grpc-与传统-http-调用的区别">gRPC 与传统 HTTP 调用的区别</h2>
<p>gRPC 和传统的 HTTP
调用虽然都用于客户端与服务器之间的通信，但它们在底层实现、性能、数据格式、传输协议等方面有显著的区别。以下是一些关键的差异：</p>
<h4 id="通信协议">1. <strong>通信协议</strong></h4>
<ul>
<li><strong>gRPC</strong>：基于 HTTP/2 协议，这使得 gRPC
具备了流式通信、多路复用、头部压缩、双向流等特性。HTTP/2
的多路复用允许多个请求和响应通过单个 TCP 连接同时传输，减少了延迟。</li>
<li><strong>传统 HTTP</strong>：基于 HTTP/1.1（或
HTTP/2，但应用较少），主要通过请求-响应的方式进行通信，每次请求通常会创建一个新的连接（除非使用了持久连接）。</li>
</ul>
<h4 id="数据格式">2. <strong>数据格式</strong></h4>
<ul>
<li><strong>gRPC</strong>：使用 Protocol
Buffers（protobuf）作为其序列化协议。这是一种高效的二进制格式，体积小、解析速度快，非常适合跨语言通信。</li>
<li><strong>传统 HTTP</strong>：通常使用 JSON、XML 等文本格式。虽然 JSON
可读性好，但在性能和数据大小方面不如 protobuf 高效。</li>
</ul>
<h4 id="性能">3. <strong>性能</strong></h4>
<ul>
<li><strong>gRPC</strong>：由于使用了 HTTP/2 和 protobuf，gRPC
在性能和资源利用率上要优于传统的 HTTP 调用。gRPC
提供更低的延迟和更高的吞吐量。</li>
<li><strong>传统
HTTP</strong>：相对较慢，尤其是在处理大规模通信或需要高并发的场景下，性能不如
gRPC。</li>
</ul>
<h4 id="双向流式通信">4. <strong>双向流式通信</strong></h4>
<ul>
<li><strong>gRPC</strong>：支持双向流式通信，这意味着客户端和服务器可以在单个
gRPC 调用中同时发送和接收消息。这对实时通信和流式数据处理特别有用。</li>
<li><strong>传统
HTTP</strong>：基于请求-响应模型，通常是一对一的交互方式。虽然可以通过
WebSocket 实现双向通信，但这不是 HTTP 协议的原生功能。</li>
</ul>
<h4 id="服务定义">5. <strong>服务定义</strong></h4>
<ul>
<li><strong>gRPC</strong>：服务接口使用 protobuf
文件定义，强类型化，接口可以跨语言调用，且编译器自动生成客户端和服务器代码。</li>
<li><strong>传统 HTTP</strong>：没有标准化的接口定义方式，通常使用
OpenAPI（Swagger）来定义 RESTful
API，但客户端和服务器代码需要手动编写。</li>
</ul>
<h4 id="适用场景">6. <strong>适用场景</strong></h4>
<ul>
<li><strong>gRPC</strong>：非常适合微服务架构、大规模分布式系统、实时通信、跨语言服务调用等场景。</li>
<li><strong>传统
HTTP</strong>：适合需要高可读性、与浏览器交互、简单或公开的 API
服务，通常用于 Web 服务和 RESTful API。</li>
</ul>
<h4 id="能否使用传统-http-进行相同的调用">7. <strong>能否使用传统 HTTP
进行相同的调用？</strong></h4>
<p>在技术上，你可以使用传统的 HTTP 来实现类似的 RPC
调用，但这会带来一些挑战：</p>
<ul>
<li>你需要自己定义数据格式（例如 JSON），处理序列化和反序列化。</li>
<li>缺乏 gRPC
提供的许多高级功能，如双向流、自动代码生成、负载均衡、强类型接口等。</li>
<li>性能和资源利用率可能不如 gRPC 高效。</li>
</ul>
<h2 id="go-标准库中的-context-详细讲解">Go 标准库中的
<code>context</code> 详细讲解</h2>
<p><code>context</code> 是 Go 标准库中的一个包，用于在不同的 goroutine
之间传递请求范围内的元数据、取消信号和超时信息。<code>context</code>
在处理并发操作时特别有用，尤其是在 gRPC、HTTP
服务器、数据库操作等场景下。</p>
<h4 id="基本概念">1. <strong>基本概念</strong></h4>
<ul>
<li><strong><code>context.Context</code> 接口</strong>：
<ul>
<li><code>context.Context</code> 是一个接口，它定义了在不同的 goroutine
之间传递请求范围内的信息的标准方法。</li>
<li>它是不可变的，一旦创建，就不能修改，而是通过派生（创建子
context）的方式来添加新的信息。</li>
</ul></li>
<li><strong>背景上下文</strong>：
<ul>
<li><strong><code>context.Background()</code></strong>：通常作为根
context
使用，没有携带任何信息，一般在主函数、初始化或者测试时使用。</li>
<li><strong><code>context.TODO()</code></strong>：占位用的
context，当你不确定应该使用什么 context 时，可以使用
<code>TODO()</code>。</li>
</ul></li>
</ul>
<h4 id="常用的函数">2. <strong>常用的函数</strong></h4>
<ul>
<li><strong><code>context.WithCancel(parent Context) (ctx Context, cancel CancelFunc)</code></strong>：
<ul>
<li>创建一个子 context，并返回一个取消函数 <code>cancel</code>。</li>
<li>调用 <code>cancel()</code> 时，会向所有使用该 context 的 goroutine
发送取消信号。</li>
</ul></li>
<li><strong><code>context.WithDeadline(parent Context, d time.Time) (Context, CancelFunc)</code></strong>：
<ul>
<li>创建一个子 context，该 context 会在指定的时间点自动取消。</li>
<li>同样返回一个 <code>CancelFunc</code>，可以主动取消。</li>
</ul></li>
<li><strong><code>context.WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)</code></strong>：
<ul>
<li>与 <code>WithDeadline</code>
类似，但这里是指定一个相对的超时时间。</li>
</ul></li>
<li><strong><code>context.WithValue(parent Context, key, val interface{}) Context</code></strong>：
<ul>
<li>返回一个子
context，携带一个键值对，可以用于传递请求范围内的特定数据（例如用户身份、请求
ID 等）。</li>
<li>注意：<code>WithValue</code> 应该谨慎使用，避免滥用造成混乱。</li>
</ul></li>
</ul>
<h4 id="如何在代码中使用-context">3. <strong>如何在代码中使用
<code>context</code></strong></h4>
<p>使用 <code>context</code>
的典型场景包括取消正在进行的操作、设置超时、传递元数据等。以下是一个简单的使用示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// 创建一个带有超时的 context</span></span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), <span class="number">5</span>*time.Second)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> doSomething(ctx, ch)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> {</span><br><span class="line">    <span class="keyword">case</span> result := &lt;-ch:</span><br><span class="line">        fmt.Println(<span class="string">"Received result:"</span>, result)</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">        fmt.Println(<span class="string">"Operation timed out:"</span>, ctx.Err())</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">(ctx context.Context, ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">select</span> {</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">10</span> * time.Second): <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        ch &lt;- <span class="number">42</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">        fmt.Println(<span class="string">"Operation cancelled:"</span>, ctx.Err())</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>在这个例子中，如果 <code>doSomething</code> 操作超过 5
秒没有完成，<code>ctx.Done()</code> 会被触发，导致操作取消。</p>
<h4 id="context-的使用建议">4. <strong><code>context</code>
的使用建议</strong></h4>
<ul>
<li><strong>传递上下文</strong>：函数之间传递 context 时，通常将
<code>context.Context</code> 作为第一个参数。</li>
<li><strong>及时取消</strong>：使用
<code>WithCancel</code>、<code>WithTimeout</code>、<code>WithDeadline</code>
创建的 context 一定要在不需要时调用返回的
<code>CancelFunc</code>，否则可能导致资源泄露。</li>
<li><strong>避免滥用
<code>WithValue</code></strong>：<code>WithValue</code>
适合传递请求范围内少量的信息，但不应该用它来传递大量数据或者频繁使用。</li>
</ul>
<h3 id="总结-2">总结</h3>
<ul>
<li><strong>gRPC</strong> 是一个高性能的 RPC
框架，适合微服务和高并发场景，与传统 HTTP
调用在协议、数据格式、性能和功能上有显著差异。</li>
<li><strong>Go 的 <code>context</code></strong>
用于在并发操作中传递元数据、取消信号和超时控制，是处理并发任务时的重要工具。它有助于管理资源，避免资源泄露或长时间未完成的任务。</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" rel="tag"><i class="fa fa-tag"></i> 区块链</a>
              <a href="/tags/go/" rel="tag"><i class="fa fa-tag"></i> go</a>
              <a href="/tags/fabric/" rel="tag"><i class="fa fa-tag"></i> fabric</a>
              <a href="/tags/%E8%B6%85%E7%BA%A7%E8%B4%A6%E6%9C%AC/" rel="tag"><i class="fa fa-tag"></i> 超级账本</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/fabric/fabric%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AF%BB%20(3)/" rel="prev" title="Hyperledger Fabric 源码精读（3）">
                  <i class="fa fa-angle-left"></i> Hyperledger Fabric 源码精读（3）
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/fabric/fabric%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AF%BB%20(1)/" rel="next" title="Hyperledger Fabric 源码精读（1）">
                  Hyperledger Fabric 源码精读（1） <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2024 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Cishoon</span>
  </div><div class="footer-custom">
Website source code <span class="exturl theme-link" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Npc2hvb24vYmxvZw==">here</span>
</div>


    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Npc2hvb24=" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.20.0/comments.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.20.0/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.20.0/motion.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.20.0/sidebar.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.20.0/next-boot.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.20.0/pjax.min.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.20.0/third-party/search/local-search.min.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.20.0/third-party/tags/mermaid.min.js"></script>

  <script class="next-config" data-name="wavedrom" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/wavedrom.min.js","integrity":"sha256-INLAoJc6quTNfiMWkGZniYO2cxE8mHpddnLow1m6RFs="}}</script>
  <script class="next-config" data-name="wavedrom_skin" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/skins/default.js","integrity":"sha256-fduc/Zszk5ezWws2uInY/ALWVmIrmV6VTgXbsYSReFI="}}</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.20.0/third-party/tags/wavedrom.min.js"></script>




  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":"true                   ---------------------> 设置为true","tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.20.0/third-party/math/mathjax.min.js"></script>



</body>
</html>
